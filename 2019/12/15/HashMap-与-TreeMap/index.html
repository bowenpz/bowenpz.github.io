<!DOCTYPE html>
<html lang=Ch>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="十二月的第三周，来补习 Java 基础，学习 HashMap 与 TreeMap 的原理。 上周看 HashMap 的迭代器源码看上头了，觉得真巧妙哈哈，顺便还看了一点 TreeMap 的源码（但是没写），也觉得挺精妙的。那么这周来学习这两种 map 的实现。 本次所看的 Java 源码均来自于 JDK 1.8，无视之前版本的实现。  由于 HashMap 的实现需要红黑树的基础支持，因此我们">
<meta name="keywords" content="Weekly Post,java">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap 与 TreeMap">
<meta property="og:url" content="http://hellopz.netlify.com/2019/12/15/HashMap-与-TreeMap/index.html">
<meta property="og:site_name" content="这里是pz阁下">
<meta property="og:description" content="十二月的第三周，来补习 Java 基础，学习 HashMap 与 TreeMap 的原理。 上周看 HashMap 的迭代器源码看上头了，觉得真巧妙哈哈，顺便还看了一点 TreeMap 的源码（但是没写），也觉得挺精妙的。那么这周来学习这两种 map 的实现。 本次所看的 Java 源码均来自于 JDK 1.8，无视之前版本的实现。  由于 HashMap 的实现需要红黑树的基础支持，因此我们">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://hellopz.netlify.com/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg">
<meta property="og:image" content="http://hellopz.netlify.com/assets/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="http://hellopz.netlify.com/assets/%E7%BA%A2%E9%BB%91%E6%A0%91.png">
<meta property="og:updated_time" content="2019-12-16T10:38:37.986Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HashMap 与 TreeMap">
<meta name="twitter:description" content="十二月的第三周，来补习 Java 基础，学习 HashMap 与 TreeMap 的原理。 上周看 HashMap 的迭代器源码看上头了，觉得真巧妙哈哈，顺便还看了一点 TreeMap 的源码（但是没写），也觉得挺精妙的。那么这周来学习这两种 map 的实现。 本次所看的 Java 源码均来自于 JDK 1.8，无视之前版本的实现。  由于 HashMap 的实现需要红黑树的基础支持，因此我们">
<meta name="twitter:image" content="http://hellopz.netlify.com/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>HashMap 与 TreeMap</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/2019/07/21/helloworld/">About</a></li>
         
          <li><a href="/tags/Weekly-Post/">Weekly Post</a></li>
         
          <li><a href="/tags/tips/">Tips</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2019/12/08/各容器迭代器的实现/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://hellopz.netlify.com/2019/12/15/HashMap-与-TreeMap/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://hellopz.netlify.com/2019/12/15/HashMap-与-TreeMap/&text=HashMap 与 TreeMap"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://hellopz.netlify.com/2019/12/15/HashMap-与-TreeMap/&is_video=false&description=HashMap 与 TreeMap"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TreeMap"><span class="toc-number">1.</span> <span class="toc-text">TreeMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Entry"><span class="toc-number">1.1.</span> <span class="toc-text">Entry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#红黑树"><span class="toc-number">1.2.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TreeMap-的-put-方法"><span class="toc-number">1.3.</span> <span class="toc-text">TreeMap 的 put() 方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-number">2.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#存储结构"><span class="toc-number">2.1.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-的-put-方法"><span class="toc-number">2.2.</span> <span class="toc-text">HashMap 的 put() 方法</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        HashMap 与 TreeMap
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">这里是pz阁下</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-12-15T06:02:35.000Z" itemprop="datePublished">2019-12-15</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Weekly-Post/">Weekly Post</a>, <a class="tag-link" href="/tags/java/">java</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <br>

<p>十二月的第三周，来补习 Java 基础，学习 HashMap 与 TreeMap 的原理。</p>
<p>上周看 HashMap 的迭代器源码看上头了，觉得真巧妙哈哈，顺便还看了一点 TreeMap 的源码（但是没写），也觉得挺精妙的。那么这周来学习这两种 map 的实现。</p>
<p>本次所看的 Java 源码均来自于 JDK 1.8，无视之前版本的实现。</p>
<hr>
<p>由于 HashMap 的实现需要红黑树的基础支持，因此我们先看 TreeMap，一个基于红黑树实现的 map。</p>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>TreeMap：形式为 tree 的 map，确切地讲，这里的 tree 是 red black tree（红黑树）。</p>
<p>TreeMap 实现了 SortedMap 接口，因此是一个有排序的 map，表内每个元素在存储时都是按照规则排序的。</p>
<p>我们在使用 TreeMap 时，不论使用哪个方法，在内部基本都会使用到 TreeMap 的基本元素 Entry 类。Entry 本身的含义指键值对（key-value），这里是一个 TreeMap 自己定义和实现的类。从结构上看，TreeMap 对象就是由一个个的 Entry 对象所组成的。因此 TreeMap 在使用方法 get()、put()、remove()……时，实际上都是在操作它自己的一个个元素 Entry。</p>
<p>这里以 TreeMap 的 get() 方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是在调用 getEntry() 方法，根据 key 值获取一个基本存储元素：Entry。</p>
<p>TreeMap 的各个方法都在使用内部类 Entry，TreeMap 本身也就是由一个个的 Entry 对象组成的，因此我们先看看这个类的内部是什么样子。</p>
<br>

<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get、set方法等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap 内部自定义了 Entry 类，这个类实现了 Map.Entry 接口，也就是说，它是一个键值对（key-value）。</p>
<p>我们这里只需关注它的内部变量，其他的没必要关心（其他的是构造方法，get、set 方法，以及重写的 equals()、hashCode()、toString() 方法）。</p>
<p>Entry 类一共有六个成员变量：</p>
<ul>
<li>key  键</li>
<li>value  值</li>
<li>left  左节点</li>
<li>right  右节点</li>
<li>parent  父节点</li>
<li>color 颜色</li>
</ul>
<p>Entry 类除了 key 和 value 这两个所有 map 都必需的变量之外，还有四个成员变量，分别是左、右、父节点，以及一个布尔值变量：颜色。</p>
<p>成员变量里面有三个节点变量，以此能够猜出，这个类是一个节点类，比如链表里面的节点、树里面的节点等等，它能够从本节点找到其他的节点。而且变量里有左、右、父三个节点，看着就很像是二叉树的结构。</p>
<p>此外它还有一个布尔值变量：颜色。这个变量初见不是很理解，它有两种值，分别是红色（RED false）和黑色（BLACK true），默认是黑色的。这个布尔值变量，使得 Entry 类不光是二叉树的节点类，还是二叉树中红黑树的节点类，它在树节点之外还保留了另一种信息：类型。</p>
<br>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>写到这里必须要开始学习红黑树了。</p>
<p>我把基础设定为二叉树，二叉树及之前的内容不写了。我认为二叉树作为一种数据结构，它本身是没有功能的，只能算是有实现某些功能的潜质，比如有查找速度快的潜质。为了让二叉树能够真的查找速度变快，能快速地找到存储节点，需要给二叉树增加一些规则，比如存储时要按照某种顺序，分支的深度要有限制等等。</p>
<p>红黑树就是一种具有一些规则的二叉树，由于这些规则的限制，使得这种数据结构在查找存储内容时会快速很多。与红黑树作用类似的还有两种（我觉得看这两种也就够了叭），一种是二叉查找树（BST, Binary Search Tree），一种是平衡二叉树/ AVL 树（G. M. <font color="#32CD32"><strong>A</strong></font>delson-<font color="#32CD32"><strong>V</strong></font>elsky 和 E. M. <font color="#32CD32"><strong>L</strong></font>andis 发明的平衡二叉树）。当面试问到红黑树时，经常会被问到，既然有另外两种能够提高查询速度的二叉树了，为什么还需要红黑树（言下之意是问红黑树对比另外两种二叉树有什么不同），尤其是问红黑树相比于二叉查找树的优势。那么我从二叉查找树和 AVL 树开始写起，然后引到红黑树。</p>
<p>（这一部分基本上参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/72505589" target="_blank" rel="noopener">《记一次腾讯面试：有了二叉查找树、平衡树（AVL）为啥还需要红黑树？》</a>）</p>
<p>（以及所有的图片都来源于维基百科， 本周懒得画图hhh）</p>
<br>

<p><font color="#32CD32"><strong>二叉查找树</strong></font>给二叉树增加的规则是，左边比中间小，中间比右边小（左子树的节点值 &lt; 父节点值 &lt; 右子树的节点值），在存储的时候按照顺序存，找的时候就能很快地找到（因为有顺序了，不是漫无目的地找了）。</p>
<p>正常情况下，它是按照类似于二分查找法的思路去查询的。但是二叉查找树的规则约束性很有限，实际上即使按照规则，值依据链表的形式去存储也是合规的，但这样查询速度就又会慢了下来。</p>
<p><img src="/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" alt="二叉搜索树"></p>
<br>

<p><font color="#32CD32"><strong>平衡二叉树</strong></font>在定义上有些模糊，我暂时认为，在通常情况下，平衡二叉树是二叉查找树的一种，即平衡二叉树的全称是【平衡二叉查找树】。在这种定义之下，平衡二叉树在二叉搜索树的基础之上，为二叉树增加了新的规则，它不光要求二叉树按照顺序存储，还要求二叉树要存储地更均衡一些，不能出现左子树一堆节点而右子树为空的情况（也就是刚才所说的类链表情况）。在维基百科里，平衡二叉树的英文名是 self-balancing binary search tree，自动平衡的二叉查找树。</p>
<p>平衡二叉树有好多种，最常被 cue 的是 AVL 树，因为它是所有平衡二叉树中最平衡的那种。AVL 树在二叉查找树的基础之上，为二叉树增加的规则是，二叉树的左右子树，最大深度的差不能超过 1。下图就是 AVL 树最不平衡的状态，存在左右子树高度差达到 1 的情况，但是你应该也会觉得：这又怎么样呢，差一点点就完美平衡了。</p>
<p><img src="/assets/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="1576491211135"></p>
<p>AVL 树是最为平衡的，排列有序的二叉树，因此它在查找节点时，查询速度是相当之快的，理论上应该是平衡二叉树中查询速度最快的。但是平衡是有代价的，存储得那么有序，找起来快，存起来、删起来也慢啊。AVL 树每次插入新的节点时，如果不平衡，是通过旋转来调整平衡的。我没兴趣去探索它具体的旋转过程，但是我大概知道结论：当插入/删除节点是，AVL 树会很频繁地旋转来调整，消耗很大。</p>
<br>

<p><font color="#32CD32"><strong>红黑树</strong></font>出现的意义就在于，它是平衡二叉树，但它不需要那么平衡，差不多就行，这样查询也快，插入也快。</p>
<p>红黑树为二叉树制定了五条规则（在数量上令小白发指）：</p>
<ol>
<li>每个节点有颜色，不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶子节点也是黑色的（NIL 节点）</li>
<li>中间的节点可以是红色的，但是红色节点不能连在一起（红色节点只能跟黑色节点相连）</li>
<li>（平衡的核心）从任意节点出发，到每个叶子节点，应途径数量一样的黑色节点。</li>
</ol>
<p><img src="/assets/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<p>边看图边思考上面的规则，主要是第四、五两条规则，会发现红黑树它的平衡之处就在于，受到这些规则约束的二叉树，深度就是差得再多，在最坏的情况下，也只会差一倍（从根到叶子的最长的可能路径不多于最短的可能路径的两倍长），这种二叉树大致上是平衡的。</p>
<p>红黑树插入节点时同样要通过旋转来调整，但是调整的次数比 AVL 树小了很多，它虽然比 AVL 树查得慢，但是它增改节点快，是一种不错的折中选择。</p>
<p>终于讲完了红黑树的引入部分。</p>
<br>

<h2 id="TreeMap-的-put-方法"><a href="#TreeMap-的-put-方法" class="headerlink" title="TreeMap 的 put() 方法"></a>TreeMap 的 put() 方法</h2><p>我这几个周看迭代器，看容器设计，感觉认识一个容器最直接、最迅速的方法，就是去看这个容器是怎么添加元素的，list 去看 add() 方法，map 去看 put() 方法。按照这种思路，去了解 TreeMap 的容器设计，应该首先去看 TreeMap 的 put() 方法，去看 TreeMap 怎么添加新的键值对。</p>
<p>从整体上看，TreeMap 的 put() 方法分三部分：</p>
<ol>
<li>如果是首次添加，初始化容器，并直接返回。</li>
<li>按照顺序<strong>直接</strong>插入新节点。</li>
<li>调整结构，以符合红黑树的规则。</li>
</ol>
<p>先把全部的代码展示出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;                                       |</span><br><span class="line">    Entry&lt;K,V&gt; t = root;                                             |</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;                                                 ■  若首次添加，初始化根节点</span><br><span class="line">        compare(key, key);                                           |</span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);                        |</span><br><span class="line">        size = <span class="number">1</span>;                                                    |</span><br><span class="line">        modCount++;                                                  |</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;                                                 |</span><br><span class="line">    &#125;                                                                |</span><br><span class="line">    <span class="keyword">int</span> cmp;                                                         |</span><br><span class="line">    Entry&lt;K,V&gt; parent;                                               |</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;                          |</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;                                               ■    如果有特定的Comparator比较器</span><br><span class="line">        <span class="keyword">do</span> &#123;                                                         | \  按照该Comparator的排序逻辑插入节点</span><br><span class="line">            parent = t;                                              |  \</span><br><span class="line">            cmp = cpr.compare(key, t.key);                           |   \</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                             |    \</span><br><span class="line">                t = t.left;                                          |    |</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)                                        |    |</span><br><span class="line">                t = t.right;                                         |    |</span><br><span class="line">            <span class="keyword">else</span>                                                     |    |</span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);                            |    |</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);                                         |    |</span><br><span class="line">    &#125;                                                                |    |</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                           |    ■  如果没有Comparator比较器</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)                                             |    |  按照默认逻辑排序（根据key的类型）</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                        |    |</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)                               |    |</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;   |    |</span><br><span class="line">        <span class="keyword">do</span> &#123;                                                         |    |</span><br><span class="line">            parent = t;                                              |    |</span><br><span class="line">            cmp = k.compareTo(t.key);                                |    |</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                             |    |</span><br><span class="line">                t = t.left;                                          |    |</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)                                        |    |</span><br><span class="line">                t = t.right;                                         |    |</span><br><span class="line">            <span class="keyword">else</span>                                                     |   /</span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);                            |  /</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);                                         | /</span><br><span class="line">    &#125;                                                                ■</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);                  |</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                                     |</span><br><span class="line">        parent.left = e;                                             |</span><br><span class="line">    <span class="keyword">else</span>                                                             |</span><br><span class="line">        parent.right = e;                                            |</span><br><span class="line">    fixAfterInsertion(e);                                            ■  调整结构，以符合红黑树规则</span><br><span class="line">    size++;                                                          |</span><br><span class="line">    modCount++;                                                      |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;                                                     |</span><br><span class="line">&#125;                                                                    |</span><br></pre></td></tr></table></figure>

<p>代码属于清晰简单的范畴，按代码的顺序简单阅读一下这段 put() 方法。</p>
<br>

<ol>
<li><p>初始化</p>
<p>put() 方法首先获取 TreeMap 对象的根节点，这个根节点的类型就是我们最开始时说的 Entry 类，是一个存储着键值对信息的红黑树节点。</p>
<p>如果发现没有根节点，就说明这个 TreeMap 对象从来没有执行过 put() 方法，没有存储任意一个键值对，那么在这种情况下，把本次 put() 方法带进来的键值对作为根节点保存起来，直接返回，不执行后续内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// TreeMap的key和value均不能为null，这里是在检查key是否是null</span></span><br><span class="line">        compare(key, key);</span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后续代码...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入节点</p>
<p>在拿到根节点之后，put() 方法就准备插入节点了。插入节点的这部分，并不关心红黑树的约束条件，也就是说如果插入之后不满足红黑树的条件了，也是没关系的。调整树的结构以符合红黑树的约束条件，这段逻辑在 put() 方法的最后一部分。</p>
<p>因此，插入节点时关注的，不在于插入前后是否都符合红黑树的要求，而在于找到插入点的位置。对于 TreeMap 而言，一切节点都是按照顺序存储的，找插入点，实际上就是在找新节点应该排在什么位置上，它应该插入到<code>左边的节点比它小，而右边的节点比它大</code>的位置处，当然了，前提是有一套计算顺序的规则。</p>
<p>根据有没有计算顺序的规则，put() 方法做了一层 if-else 的判断，如果有比较器，按比较器的来，如果没有比较器，按默认排序方式来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...找到根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;                       <span class="comment">// 有比较器，按比较器排序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                   <span class="comment">// 没有比较器，按默认规则排序</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">    parent.left = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    parent.right = e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续代码...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="#32CD32"><strong>if</strong></font>-else：有 Comparator</p>
<p>说来又是我的知识盲区，我从来没有用过 Comparator 比较器，也是因为自己函数式编程写得少。</p>
<p>这里的 Comparator 对象，是 TreeMap 实例化时使用构造方法带进来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有比较器，那么在插入节点时，按照二分查找法的思路执行。取父节点，计算大小关系（比较器的 compare() 方法），判断往左子树走还是往右子树走，直到再无子树。</p>
<p>这里的 Comparator 是自己实现的，意义就在于：自己指定了一套排序规则，让 TreeMap 中的元素按照这种规则存储。</p>
</li>
<li><p>if-<font color="#32CD32"><strong>else</strong></font>：无 Comparator</p>
<p>如果没有自己指定排序规则，那么 TreeMap 就会按照默认的方式进行排序。默认的排序方式是，让存储的 key-value 中的 key 提供排序规则，依照 key 的类型自带的排序规则进行排序。</p>
<p>具体来讲，就是 【treeMap.put(<font color="#CD32"><strong>key</strong></font>, value)】中的 key 需要实现 Comparable 接口。再换种说法解释，TreeMap 要求必须排序，如果你不主动提供排序规则，那就让 key 提供默认的排序规则（如果 key 没有排序规则，那只好报错）。</p>
<p>以最常见的情况举例：key 是 String 字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">treeMap.put(<span class="string">"str1"</span>, <span class="number">1</span>);</span><br><span class="line">treeMap.put(<span class="string">"str2"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这里有一处潜在的事情，那就是 String 类是实现了 Comparable 接口的，它有默认的排序规则。去看 String 类的结构体就能够发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 Comparable 接口，就必须重写 compareTo() 方法，也就是比较大小。String 类重写的 compareTo() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑大意就是，字符逐个比较先后顺序，比到最后比字符串的长度。按照这种逻辑，”str1” &lt; “str2”（结果为 -1 小于 0）。</p>
<p>回看刚才向 treeMap 里 put 进两个键值对（”str1” -&gt; 1 和 “str2” -&gt; 2)，不管怎么插入，最终 treeMap 存储这两个键值对，都会是 key 为 “str1” 的键值对在前，因为在字符串的排序当中，它居前位。此时打印出 treeMap，总是会按照如下顺序输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;str1=1, str2=2&#125;</span><br></pre></td></tr></table></figure>

<p>如果 key 的类型并没有实现 Comparable 接口，没有重写 compareTo() 方法，在存入 TreeMap 时就会报错，抛出类型转换异常（ClassCastException）。</p>
</li>
</ul>
</li>
<li><p>调整树结构</p>
<p>这部分 TreeMap 抽出了一个单独的方法，用以调整插入新节点之后的树，调整成红黑树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...已插入新节点</span></span><br><span class="line"></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分是红黑树调整树结构的具体算法，枯燥、易忘、烧脑，正常人遇到这里都会绕开走……我只简单地看一遍，混个面熟就好。</p>
<p>插入的新节点默认是红色的，然后根据父节点和 uncle 节点判断左旋右旋之类的。</p>
<p>哎，找了个视频看，觉得麻烦得要命，算了算了，等自己强一点再回来看叭……下面是该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<br>

<p>TreeMap 的其他方法暂且就不看了，转 HashMap 去了。</p>
<br>

<hr>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap 就是跟 hash 走得特别近的 map。</p>
<p>TreeMap 是通过 key 按顺序找到存储位置的，HashMap 是通过 key 的 hashCode 计算算出来存储位置的。</p>
<br>

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>HashMap 通过【数组+链表+红黑树】的数据结构存储键值对，很精巧的一种设计。</p>
<p>// 图</p>
<p>大体的存储逻辑是这样的：</p>
<ol>
<li>先在数组里存：计算哈希值，并根据哈希值取余，得知存在数组的第几个格子中，存入。</li>
<li>有则转链表：存数组时，如果格子里面已经有数据了，则按链表的结构存（尾插法）。</li>
<li>过长则转红黑树：存链表时，如果链表过长（超过 8 个），将链表转成红黑树，之后再插入新元素，按红黑树存储。</li>
</ol>
<br>

<h2 id="HashMap-的-put-方法"><a href="#HashMap-的-put-方法" class="headerlink" title="HashMap 的 put() 方法"></a>HashMap 的 put() 方法</h2><p>跟 TreeMap 一样，我们了解 HashMap 也是通过 put() 方法。</p>
<p>put() 方法的源码只有三行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>HashMap 的 put() 方法调用了一个私有方法，所有的代码逻辑都装在私有方法里。</p>
<p>这么看肯定是看不出 HashMap 的存储逻辑，但是通过 putVal() 方法的结构体，还是能够看出些东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="#32CD32"><strong>hash</strong></font>：key 的类哈希值</p>
<p>调用 hash() 方法获得，将 key 的哈希值前后 16 位进行与运算，以扩大 key 的哈希值差异。这样做能够使 hashMap 在存储数据时，存储地更平均。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="#32CD32"><strong>key</strong></font>：键</p>
</li>
<li><p><font color="#32CD32"><strong>value</strong></font>：值</p>
</li>
<li><p><font color="#32CD32"><strong>onlyIfAbsent</strong></font>：key 重复时是否保留原数据。</p>
<p>true：保留原 value</p>
<p>false：使用新 value</p>
</li>
<li><p><font color="#32CD32"><strong>evict</strong></font>：留给子类 LinkedHashMap 使用的，但无论是 true 还是 false 在 LinkedHashMap 里结果都是一样的，哎懒得看了，之后有机会再看吧。</p>
</li>
</ul>
<br>

<p>看完结构体，来看 putVal() 的具体实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  |</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;                                       |</span><br><span class="line">   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)                           ■  初始化（第一次的话）</span><br><span class="line">       n = (tab = resize()).length;                                              |</span><br><span class="line">   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)                                    ■  如果没有hash碰撞，直接插入</span><br><span class="line">       tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);                                 | \</span><br><span class="line">   <span class="keyword">else</span> &#123;                                                                        |   ■ 如果发生hash碰撞...</span><br><span class="line">       Node&lt;K,V&gt; e; K k;                                                         |   |</span><br><span class="line">                                                                                 |   |</span><br><span class="line">       <span class="keyword">if</span> (p.hash == hash &amp;&amp;                                                     |   ■  处理key已存在的情况</span><br><span class="line">           ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))               |   | \</span><br><span class="line">           e = p;                                                                |   |  \</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)                                           |   |   ■  以红黑树的结构存储</span><br><span class="line">           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);       |   |   | \</span><br><span class="line">       <span class="keyword">else</span> &#123;                                                                    |   |   |   ■  以链表的结构存储</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;                                |   |   |   |</span><br><span class="line">               <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                                       |   |   |   |</span><br><span class="line">                   p.next = newNode(hash, key, value, <span class="keyword">null</span>);                     |   |   |   |</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)                        |   |   |   |</span><br><span class="line">                       treeifyBin(tab, hash);                                    |   |   |   |</span><br><span class="line">                   <span class="keyword">break</span>;                                                        |   |   |   |</span><br><span class="line">               &#125;                                                                 |   |   |   |</span><br><span class="line">               <span class="keyword">if</span> (e.hash == hash &amp;&amp;                                             |   |   |   |</span><br><span class="line">                   ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))       |   |   |  /</span><br><span class="line">                   <span class="keyword">break</span>;                                                        |   |   | /</span><br><span class="line">               p = e;                                                            |   |   |/</span><br><span class="line">           &#125;                                                                     |   |  /</span><br><span class="line">       &#125;                                                                         |   | /</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;                                                          |   ■  替换key已存在时的value</span><br><span class="line">           V oldValue = e.value;                                                 |   |</span><br><span class="line">           <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)                                |   |</span><br><span class="line">               e.value = value;                                                  |   |</span><br><span class="line">           afterNodeAccess(e);                                                   |   |</span><br><span class="line">           <span class="keyword">return</span> oldValue;                                                      |  /</span><br><span class="line">       &#125;                                                                         | /</span><br><span class="line">   &#125;                                                                             ■</span><br><span class="line">   ++modCount;                                                                   |</span><br><span class="line">   <span class="keyword">if</span> (++size &gt; threshold)                                                       ■  扩容内部数组（若有需要）</span><br><span class="line">       resize();                                                                 |</span><br><span class="line">   afterNodeInsertion(evict);                                                    ■  为子类LinkedHashMap提供</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;                                                                  |  HashMap这里只是空实现</span><br><span class="line">&#125;                                                                                |</span><br></pre></td></tr></table></figure>

<p>HashMap 的 putVal() 方法逻辑，跟 HashMap 的存储结构是完全契合的：</p>
<ol>
<li>初始化 hashMap（即第一次使用 put() 方法）</li>
<li>算出数组位置后，能插入数据就插进去</li>
<li>如果不能插进去，分三种情况分析<ol>
<li>key 已存在，将新的 value 替换掉旧的 value</li>
<li>数组位置内已经存了链表：链表长度超过 8 则转红黑树，没超过则尾插链表</li>
<li>数组位置内已经存了红黑树：红黑树插入数据</li>
</ol>
</li>
<li>hashMap 内部数据过多则扩容数组（默认下，过多的标志：size &gt; 数组长度 × 0.75）</li>
</ol>
<br>

<p>HashMap 里的 put() 方法里有很多可以看的地方，包括【链表转红黑树】、【数组扩容】、【hash 值和负载值等的位运算】等，大概看了几眼，时间赶就不详叙述了。</p>
<p>这周就看到这里吧。</p>
<br>


  </div>
</article>



    </div>
    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 pz
  </div>
  <div class="footer-right">
    <nav>
      pz阁下的blog
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



