<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FreeMarker</title>
    <url>/2019/12/29/FreeMarker/</url>
    <content><![CDATA[<br>

<p>十二月的第六周，来学习 FreeMarker。</p>
<p>在我敲出上句话时，我甚至都不知道 FreeMarker 是什么……工作需要，硬头皮写。</p>
<hr>
<p>FreeMarker 是一种模板引擎，通过 Java 语言使用。<a href="http://freemarker.foofun.cn/" target="_blank" rel="noopener">官方</a>是这么解释“模板引擎”的：</p>
<blockquote>
<p> （模板引擎是）一种基于模板和要改变的数据，用来生成输出文本的通用工具。</p>
</blockquote>
<p>又是一个不说人话的解释。</p>
<p>我理解的模板引擎，就是让程序自动使用模板生成结果的工具，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：$&#123;name&#125;</span><br><span class="line">                                            ↓</span><br><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：张三</span><br><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：李四</span><br><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：王二麻子</span><br></pre></td></tr></table></figure>

<p>FreeMarker 能够读取模板中的占位符 <code>${...}</code>，并根据外部输入的值，自动替换掉占位符，生成最终的结果。</p>
<p>如此一个替换文本的工具，广泛使用在 web 前端、配置文件、源代码中。它是一种老派的 old school 工具，现在前端都没什么人用了。</p>
<hr>
<p>一会再学习 FreeMarker 的语法，暂且认为 FreeMarker 就是在替换字符串，把 <code>${...}</code> 换成具体的值。</p>
<p>最为基础的使用 FreeMarker 的方式，就是 IO 输入模板文件，然后 FreeMarker 咣咣工作，最终 IO 输出生成文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于处理IO异常太过繁琐，模糊了主干内容，这里忽略处理异常的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IO输入模板文件</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);</span><br><span class="line">configuration.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(<span class="string">"C:\\Users\\thinkpad\\Desktop"</span>));</span><br><span class="line">Template template = configuration.getTemplate(<span class="string">"template.ftl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置替换值</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO输出结果文件</span></span><br><span class="line">File out = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\thinkpad\\Desktop\\"</span> + <span class="string">"result.txt"</span>);</span><br><span class="line">Writer outWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(out)));</span><br><span class="line">template.process(map, outWriter);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>输入（template.ftl）</th>
<th>输出（result.txt）</th>
</tr>
</thead>
<tbody><tr>
<td>人员信息<br>姓名：${name}<br>年龄：${age}</td>
<td>人员信息<br>姓名：张三<br>年龄：18</td>
</tr>
</tbody></table>
<br>

<p>上面的代码是在做这样一件事：</p>
<ol>
<li>实例化一个 FreeMarker 对象出来（configuration）</li>
<li>配置 FreeMarker 的参数，其中包括输入地址（模板）、输出地址（结果）、FreeMarker 的版本。</li>
<li>给定想替换成的值，让 FreeMarker 去工作（替换）。</li>
</ol>
<br>

<p>顺便提一嘴，模板文件 <code>template.ftl</code> 的后缀名是 <code>ftl</code>，全称是 FreeMarker Template Language，是 FreeMarker 的标准模板文件格式。</p>
<p>上面这种方式，是显式地配置 FreeMarker，手动给定输出输出的文件地址，设定好 FreeMarker 的版本号，然后去使用。除了这种方式之外，还可以以配置文件的方式，在外部去设定好 FreeMarker 的各项参数，然后直接使用。比如在 Spring 框架下，都是外部设定好 FreeMarker 的参数，然后注入到要使用的地方。</p>
<p>但是我看了看，有点复杂……算了，看看语法就行了，佛了。</p>
<hr>
<p>来看 FreeMarker 的语法。</p>
<p>首先推荐<a href="http://freemarker.foofun.cn/dgui_template_overallstructure.html" target="_blank" rel="noopener">官方文档</a>，尽管官方的介绍有一些翻译腔，但是在语法介绍部分，是极尽所能地把用户当小白来教学。</p>
<p><img src="/assets/FreeMarker%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.png" alt="FreeMarker官方文档"></p>
<p>（你看看这个恳切程度！）</p>
<p>粗略地学习之后发现，FreeMarker 不仅仅是一个替换字符串的工具，而像是一个完整的语言体系，除了基本的替换，还有许多内置函数和逻辑控制，实际上要学习的内容是非常多的。</p>
<p>本周又是摸鱼的一周，仅将常用的替换语法写在下面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置准备替换的值</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">Map person = <span class="keyword">new</span> HashMap();</span><br><span class="line">person.put(<span class="string">"age"</span>, <span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">"person"</span>, person);</span><br><span class="line">List hobby = Arrays.asList(<span class="string">"唱"</span>, <span class="string">"跳"</span>, <span class="string">"RAP"</span>, <span class="string">"篮球"</span>);</span><br><span class="line">map.put(<span class="string">"hobby"</span>, hobby);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>模板文件</th>
<th>输出文件</th>
</tr>
</thead>
<tbody><tr>
<td>人员信息<br><br>姓名：${name}<br><br>年龄：${person.age}<br><br>&lt;#if (person.age &gt;= 18)&gt;<br>成年<br>&lt;#else&gt;<br>未成年<br>&lt;/#if&gt;<br><br>爱好：&lt;#list hobby as h&gt;${h} &lt;/#list&gt;<br><br>当前时间：${.now?string[“yyyy-MM-dd HH:mm:ss”]}</td>
<td>人员信息<br><br>姓名：张三<br><br>年龄：17<br><br>未成年<br><br>爱好：唱 跳 RAP 篮球 <br><br>当前时间：2019-12-29 09:40:58</td>
</tr>
</tbody></table>
<br>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator 迭代器</title>
    <url>/2019/12/01/Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<br>

<p>十二月了，今年要结束了。</p>
<p>这周学习 Java 的迭代器原理，迭代器是各编程语言都会有的设计，这里只关注 Java 的实现。</p>
<hr>
<p>迭代的意思是重复地同一样事，比如写一个 for 循环，每层循环内部执行一些逻辑，就是在迭代。</p>
<p>迭代器，用字面上的意思去理解，就是专注做迭代这件事的工具，即这个工具持续地、专注地做一件重复的事情。</p>
<p>实际上，编程中的迭代器，做的那件重复的事情是有所特指的，专指访问容器中的元素。例如一个列表（list）中有十个元素，使用迭代器可以重复性地逐个访问这十个元素，就跟写一个 for 循环一样。</p>
<p>容器分很多种，array 是容器、list 是容器、set 是容器、map 是容器，如果你的目的是遍历某一种容器，你应该写不一样的 for 循环（而且有些容器你无法通过 for 循环来遍历），但是如果你使用迭代器，你可以用同一种逻辑来遍历任何一种容器。迭代器的好处在于，你可以无视容器的类型，用同样的逻辑来处理它们。</p>
<p>所以我觉得吧，迭代器也可以简单粗暴地称为遍历器。</p>
<p>再体会一下维基百科对于迭代器的解释：</p>
<blockquote>
<p>迭代器（iterator）是可在容器物件（container，例如链表或阵列）上遍访的介面，设计人员无需关心容器物件的内存分配的实现细节。 </p>
</blockquote>
<hr>
<p>Java 的迭代器是 Iterator 类，是一个从 JDK 1.2 起就存在的元老设计。</p>
<p>Iterator 类是一个接口，规范了迭代器的基本规则。它在 1.2 版本时只有三个方法，在 1.5 版本时开始支持泛型，在 1.8 版本时引入函数式编程。不过在学习时，只关注 1.2 版本的最初那三个方法即可。</p>
<p>以下是 Iterator 类的三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>boolean hasNext()：是否有下一个元素（即是不是还没有遍历完容器）</li>
<li>Object next()：取出来下一个元素并返回，可以使用泛型来指定类，当执行完该方法，迭代器将自动挪到下一个元素</li>
<li>void remove()：删除上一个元素（即删除刚刚越过的那个元素）</li>
</ul>
<br>

<p>由于这三个方法非常简单，含义也很清晰，在此只给出一段代码，表个意思。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"list初始值为："</span> + list);</span><br><span class="line"><span class="comment">// list初始值为：[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">Integer next1 = iterator.next();</span><br><span class="line">System.out.println(<span class="string">"第一次执行next()方法："</span> + next1);</span><br><span class="line"><span class="comment">// 第一次执行next()方法：1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer next2 = iterator.next();</span><br><span class="line">System.out.println(<span class="string">"第二次执行next()方法："</span> + next2);</span><br><span class="line"><span class="comment">// 第二次执行next()方法：2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iterator.remove();</span><br><span class="line">System.out.println(<span class="string">"执行完remove()方法后，此时的列表值为："</span> + list);</span><br><span class="line"><span class="comment">// 执行完remove()方法后，此时的列表值为：[1, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasNext1 = iterator.hasNext();</span><br><span class="line">System.out.println(<span class="string">"此时是否有下一个元素："</span> + hasNext1);</span><br><span class="line"><span class="comment">// 此时是否有下一个元素：true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer next3 = iterator.next();</span><br><span class="line"><span class="keyword">boolean</span> hasNext2 = iterator.hasNext();</span><br><span class="line">System.out.println(<span class="string">"此时是否有下一个元素："</span> + hasNext2);</span><br><span class="line"><span class="comment">// 此时是否有下一个元素：false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>这周又是懒得不行，暂且写到这里。下周开始看各容器的迭代器实现源码，进入源码的世界。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2020/04/15/ConcurrentHashMap/</url>
    <content><![CDATA[<br>

<p>本篇着重学习 JDK 8 的ConcurrentHashMap，对于 JKD 7 的设计也顺便学习一下。</p>
<p>学习来源基本上源自博文<a href="https://www.javadoop.com/post/hashmap" target="_blank" rel="noopener">《Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析》</a>，这篇文章已经写得非常不错了，就是无奈道格李的代码太难读了，因此还是要很认真地学习才能看懂。</p>
<hr>
<p>首先简单提一下 JDK 7 时的 ConcurrentHashMap 的设计（下图来自前面提到的博文）。</p>
<p><img src="/assets/3.png" alt="JDK7的表设计"></p>
<p>JDK 7 时 ConcurrentHashMap 采用分段锁的设计，维护一个 Segment 数组，每个 Segment 都是一个锁（继承自 ReentrantLock），该 Segment 内部有一个可扩容数组（同 HashMap 的设计）用于真正存储元素。相比于 Hashtable 对整个方法加 synchronized 锁，ConcurrentHashMap 对 Segment 上锁，相当于降低了锁的颗粒度，提高了性能。</p>
<p>不看源码了，只写一点实现细节吧：</p>
<ol>
<li><p>Segment 数组初始化后不可扩容，默认是 16 个 Segment，可通过构造方法改变初值（初值会自动上抬为 2 的幂数，构造方法与 HashMap 有不同）。</p>
</li>
<li><p>存储元素时分段存储，算法是取 hash 的高位（如果 Segment 数组长度是 16，那么就取 hash 的高 4 位），然后算出存储在哪个 Segment。比如 hash 高 4 位是 1010，那么存储在 Segment[10]，如果 hash 高 4 位是 0011，那么存储在 Segment[3]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当有16个Segment时，hash无符号右移28位（剩下高4位），然后与操作15，得出存储的Segment的位置</span></span><br><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></pre></td></tr></table></figure>

<p>（看到这里你应该明白，为什么 Segment 的个数也需要是 2 的幂数了）</p>
</li>
<li><p>Segment 内部由数组+链表组成（跟 HashMap 的原理相同，拉链法），链表采用尾插法。存 entry 前先获取 Segment 的锁，在保证持有锁的前提下存储 entry。</p>
</li>
<li><p>构造方法初始化时，会创建 Segment 数组，并只会创建出第 0 个 Segment：Segment[0]，Segment[0] 内部的数组长度初值为 2，根据负载因子扩容（默认 0.75），这样插入第一个元素不扩容，插入第二个元素才扩容。其他 Segment[i] 会在存储 entry 时再创建，数组长度和负载因子同当时的 Segment[0]（有可能 Segment[0] 扩容过，那么就使用扩容之后 Segment[0] 的长度）。</p>
</li>
<li><p>ConcurrentHashMap 的 get() 方法没有做任何并发处理，主要是依赖于 volatile 关键字配合 UNSAFE 包实现读取时的数据一致（具体原理略）。</p>
</li>
</ol>
<hr>
<p>JDK 8 的 ConcurrentHashMap 放弃了 Segment 分段锁的设计，转而使用跟 HashMap 相同的数据结构，但是实现上考虑并发。</p>
<p><img src="/assets/4.png" alt="JDK8的表设计"></p>
<p>推测一下放弃分段锁的原因：</p>
<p>原先采取 Segment 分段，默认情况下最多分 16 段，而 Segment 是通过继承 ReentrantLock 实现的，这就意味着可能同一时间需要维护 16 个 AQS 队列，对内存的消耗还是比较大的。</p>
<p>如果联想下 HashMap，同一时间不太会有多个线程对同一个数组格子进行编辑，那么可以使用 synchronized 修饰每一个格子，锁的优化让 JVM 去处理。</p>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;                   |</span><br><span class="line">                                                                         |</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  ■ key和value均不能为<span class="keyword">null</span>（HashMap可以）</span><br><span class="line">                                                                         |</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());                                   ■ hash:key的哈希值（经过高低位与运算）</span><br><span class="line">                                                                         |</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;                                                    ■ binCount:链表长度</span><br><span class="line">                                                                         |</span><br><span class="line">                                                                         ├---------------------------------</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;                                 |                        （无限循环）</span><br><span class="line">                                                                         |</span><br><span class="line">        Node&lt;K, V&gt; f; <span class="keyword">int</span> n, i, fh;                                      ■ f:新entry  n:数组长度</span><br><span class="line">                                                                         |  i:数组下标  fh:数组下标头节点的哈希值</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;...&#125;                  ■ （若首次）初始化数组</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;...&#125;     ■ 找到数组下标，如果空链表则CAS加</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;...&#125;                           ■ 多线程帮助数组扩容</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">else</span> &#123;                                                           ■ （已经找到数组下标）链表非空</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;                                             |  通过<span class="keyword">synchronized</span>阻塞加</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;...&#125;                                       |</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;...&#125;                                     ■ 如果链表长度过长，则转红黑树</span><br><span class="line">        &#125;                                                                |</span><br><span class="line">    &#125;                                                                    |</span><br><span class="line">                                                                         ├---------------------------------</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);                                              |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;                                                         |</span><br><span class="line">&#125;                                                                        |</span><br></pre></td></tr></table></figure>

<p>源码点到为止（真不喜欢看道格李的代码= =），一些实现细节列在下面：</p>
<ol>
<li><p>ConcurrentHashMap 的 key 和 value 都不支持 null 值，这点跟 HashTable 一致，但是 HashMap 是支持的（key 和 value 都支持）。</p>
<p>关于这点我曾在分析 HashTable 的源码时提过，明面上的原因是：如果 value 允许 null，那么当 <code>map.get(...) == null</code> 时，不能知道返回的 null 是代表 value 为 null，还是说根本没有 key，对于 HashMap 单线程可以使用 containsKey() 方法判断，但是多线程并发的 ConcurrentHashMap 和 HashTable 是判断不出来的。还有一层原因是，道格李不希望在 Map 和 Set 容器中支持 null，他认为这是定时炸弹。</p>
<p>有关这个问题可以参考该网站：<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002485.html" target="_blank" rel="noopener">道格李对 ConcurrentHashMap 不支持 null 的解释</a></p>
</li>
<li><p>在 JDK8 的代码实现中，ConcurrentHashMap 和 HashMap 是比较像的，放弃了原先分段锁的设计，转而对每一个数组格子加 synchronized 锁。我发现道格李写代码很喜欢写循环，循环进入的每一轮，状态是不同的，进而进到不同的分支中。我们具体看一下 HashMap 和 ConcurrentHashMap 的实现：</p>
<ul>
<li>HashMap 加 entry 时，顺序执行一堆 if-else 的判断，先判断数组是否已被创建，然后判断是否发生哈希碰撞，如果哈希碰撞再判断是否是红黑树节点……</li>
<li>ConcurrentHashMap 加 entry 时，在一个无限循环当中，首次进来创建数组，再次进来判断是否是空链表，如果是空链表就直接 CAS 加入，如果加入失败了没关系，退出去，循环再进来的时候，进入到不是空链表的分支里，用 synchronized 阻塞尾插链表……</li>
</ul>
<p>在实现 AQS 队列的时候，我就觉得道格李用循环用得是炉火纯青了……一方面体现在每次进入循环，执行的代码都不一样，另一方面体现在循环内部的各个 if 条件是有关联的（往回看代码就能看出来，第二个 if 条件获得了数组下标，结果用到了第四个 if 条件中）。</p>
</li>
<li><p>ConcurrentHashMap 同样采用<code>数组+链表+红黑树</code>的设计，但是红黑树稍有区别，HashMap 的转红黑树条件是链表长度超过 8，ConcurrentHashMap 的转红黑树条件，在链表长度超过 8 的基础上，还需要数组长度超过 64。我猜测这跟 synchronized 锁有关，如果数组长度太小了，加锁会比较容易阻塞。</p>
</li>
<li><p>ConcurrentHashMap 数组扩容跟 HashMap 一样，都是两倍，具体实现很复杂，支持多线程一起帮助扩容。在 putVal() 方法中就有判断 hash 值是否是 -1，如果是 -1 就代表着去帮助扩容数组。</p>
</li>
<li><p>JDK7 和 JDK8 的 ConcurrentHashMap 的 get() 方法都没有做并发处理，逻辑比较简单，主要依靠 volatile 关键字和 UNSAFE 包来确保并发安全。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins</title>
    <url>/2020/01/05/Jenkins/</url>
    <content><![CDATA[<br>

<p>2020 年的第一周，来学习 Jenkins。</p>
<hr>
<p>Jenkins 是一个人名，音译为詹金斯，读起来是一个很英国绅士的声音。</p>
<p>以 Jenkins 命名的这个工具/软件，是一个给编程开发人员当管家的存在，它的作用是自动化各种任务，包括构建、测试和部署软件，总之是给编程人员打下手。以一个英国绅士的名字命名，听起来就像是一个老管家，真的是很贴切。</p>
<p>Jenkins 不光名字起得贴切，连 logo 都设计为一个管家，见图明义。很草的是，Jenkins 可以使用插件扩展功能，插件官网的配图，是管家穿着高达。</p>
<p><img src="/assets/JenkinsLogo.jpg" alt="Jenkins logo"></p>
<p>说回 Jenkins 的作用。如果用术语来解释 Jenkins，它是一款开源 CI&amp;CD 软件。</p>
<p>CI&amp;CD 是编程运维中的概念，CI(Continuous Integration) 指持续集成，CD(Continuous Delivery) 指持续交付。我在阅读相关博文时，发现有两个 CD（Continuous Deployment 持续部署、Continuous Delivery 持续交付），但是一般提到时是指持续交付。</p>
<p>CI&amp;CD 的意义在于解放人力，让集成、打包、部署等流水线式的固定工作，不再需要程序员/运维人员手动去做，而交由工具去做。这在项目快速迭代功能时尤其有必要，以前我每写好一个小功能点，都要手动用 Maven 清掉编译文件，重新打包，提交给发布人员，再由发布人员去更新，整套流程耗时耗心，还有可能犯人类的低级错误。有了 CI&amp;CD 的工具之后，开发人员只需要提代码到 SVN 或者 Git 上就可以了，剩下的部署交由工具完成。</p>
<p>更多有关 CI&amp;CD 的概念可以参看博文<a href="https://linux.cn/article-9926-1.html?pr" target="_blank" rel="noopener">《什么是 CI/CD？》</a>。</p>
<hr>
<p>这周写 Jenkins 是一个非常错误的决定，因为我完全不知道写点什么……Jenkins 使用起来，就跟使用迅雷、QQ 音乐、360 杀毒软件似的，都是软件级别的交互，写起来跟写百度经验似的。而且我本地没有配置自己的 SVN 或 Git，使用 Jenkins 时都没有切身的实操体验。</p>
<p>我暂且想写什么点，就写什么点了，尽可能地学习到东西。</p>
<br>

<p>嗯……果然看了一通，什么都写不了，要不然是接触不到，要不然是水平不足。基本上，Jenkins 的自定义配置都是靠 Shell 脚本语言来实现的，我 Linux 的使用水平实在是捉襟见肘，啧，佛掉了新年第一个周。</p>
<p>下周补基础，看 Java 的容器设计。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>三层架构和MVC模式</title>
    <url>/2019/08/13/Software%20Architecture/</url>
    <content><![CDATA[<br>

<p>八月的第二周，来整理工作一个多月对于架构、模式的认识。</p>
<p>反思了一下，博客内容应该是自己在学习过程中的总结与思考，而不应该是科普与教学，应当写得更倾诉一些。</p>
<p>今天要整理的内容有两方面，一种是三层架构，另一种是MVC模型。</p>
<hr>
<p>架构，是指设计一个程序的结构，是一个相当宏观的概念。</p>
<p>我觉得要理解架构这个概念，最主要的是去把握<strong>宏观</strong>这个特征。换句话说，当考虑架构的时候，是不去思考软件的应用场景、实现细节这些的，而是站在一个统领全局的角度，去思考一个庞大的程序应该怎么部署的。</p>
<p>一个庞大的程序，应当采用什么样的结构，应当划分成哪几个模块，怎么设计才能实现高效开发，才能让一群码农共同实现进度，这是架构要去解决的问题。所以你看，这真的是一个很宏观的问题，是一个统筹部署的设计问题。</p>
<p>有许多被广泛使用的架构模式，其中最简单、最基础的是三层架构，我们来聊聊这种架构。</p>
<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p>三层架构是指，把一个项目拆成三层：第一层跟用户打交道，第二层处理业务逻辑，第三层处理数据库。</p>
<p>这三层的名字分别叫做表示层（PL）、业务逻辑层（BLL）、数据访问层（DAL）。</p>
<p><img src="/assets/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.jpg" alt="三层架构"></p>
<p>这三层的名字起得相当虎逼，煞有其事的，其实指的是很简单的东西。</p>
<ol>
<li>表示层：给用户看的，给用户操作的。</li>
<li>业务逻辑层：后台处理，干活的。</li>
<li>数据访问层：管数据的。</li>
</ol>
<p>一个项目拆成了  <code>数据 —&gt; 处理 —&gt; 展示</code>  三个部分，竖着看是不是三层。</p>
<p>你稍微一想，就会觉得这么分层是挺有逻辑、挺有道理的。不用说编程，做什么事情不都是这样子吗：首先拿到原材料，然后加工处理，最后展示出去。尽管有很多细节不一样，但是大致的流程就是这样子的。</p>
<p>通过三层架构，把一个项目的全部内容拆成三个层面的事情。最上面一层只跟用户打交道，用户看到什么，用户操作什么，用户输入了什么，全都在这一层；中间一层只跟业务逻辑打交道，拿到数据怎么处理，收到用户信息怎么加工，全在这一层；最底下一层只跟数据打交道，数据存放在哪里，怎么取出来，怎么把新数据存进去，全在这一层。</p>
<p>这种架构能够实现初步的“分而治之”，把大事拆成小块，每一部分做自己的事情，这是为了编程中的“解耦”。解耦就是解除耦合，关联得不要那么密切，这样好开发。</p>
<p>关于三层架构先说到这里。</p>
<hr>
<p>设计模式是针对于某一类场景而言的，是一个<strong>不太宏观</strong>的概念。</p>
<p>当面对着某一类情况，尽管细节上各有不同，但是这类情况有共性之处，有可以解决这类情况的一种方案，这就是设计模式。</p>
<p>你可以感受到，架构和设计模式不是同一高度的，架构非常宏观，设计模式没那么宏观，这是两个纬度的概念。再换个说法，架构面对的是所有情况，设计模式面对的是某一类情况。</p>
<p>我很努力地去表述，架构与设计模式不是同一个纬度的东西，尽管它们都是用来解决泛化场景的，但是层级是的的确确有差异的，设计模式是比架构低一个level的东西。这样去表述的目的，是为了解释清楚一个经常被问到的代码相关问题：三层架构与MVC模式的区别是什么？</p>
<p>现在我先这么回答：</p>
<blockquote>
<p>三层架构是一种架构，MVC模式是一种设计模式，它们解决问题的高度不同：</p>
<p>三层架构是为所有情景设计的，MVC模式是为其中一类情景设计的。</p>
</blockquote>
<p>接着来聊一聊MVC模式。</p>
<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p>MVC是<code>Model-View-Controller</code>的首字母合称，就是说把一个软件项目拆成三个基本部分——模型（Model）、视图（VIew）、控制器（Controller）。</p>
<p>你首先要认识到，MVC模式不是为所有场景设计的，它只是web应用的一种设计模式。为了更好地开发网页，前人设计了一种名叫“MVC模式”的设计模式，它就是为了web应用开发而存在的。</p>
<p>然后我们来仔细说说MVC模式是什么。</p>
<p>MVC模式有三个部分，但是为了说明方便，还要在这三个部分之外加上“人”的角色（也就是用户），来理解人是怎么跟这三个部分打交道的。</p>
<p><img src="/assets/MVC%E6%A8%A1%E5%BC%8F.jpg" alt="MVC模式"></p>
<p>我画了一张图，你能够看到MVC其实就是三个模块，与人直接打交道的是View和Controller模块：人看View模块（例如看静态网页、看网站视频），人操作Controller模块（例如点击鼠标选择）；而Model模块是藏在后面的，是View模块和Controller模块的桥梁。</p>
<p>也就是说：</p>
<ul>
<li>Model（模型）：后台处理逻辑</li>
<li>View（视图）：可视化部分</li>
<li>Controller（控制器）：</li>
</ul>
<br>

<br>

<br>

<br>

<br>

<hr>
<p>听到了一声灾厄。</p>
<p>不想写下去了，这一篇就写到这里吧。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC的引入</title>
    <url>/2019/08/04/SpringIoC/</url>
    <content><![CDATA[<br>

<p>八月的第一周，我们来说IoC</p>
<p>IoC是Spring框架的核心思想其一，原理不算复杂。</p>
<hr>
<p>Spring家族是Java中风光无限的一族，几乎所有Java项目所使用的框架，都跟Spring家族有关。有一些介绍中说，Spring框架是一种全栈式框架（或者是一站式框架），全栈（Full-stack）的意思就是说，编程里能干的所有活，它一家可以全包了，一条龙服务，可以应用于一切场景。</p>
<p>Spring在2004年发布了1.0版本。创建Spring的那哥们叫Rod Johnson，他自己写了本书，说当时的主流框架EJB可以换个思路写代码，后来觉得不痛快，就又写了一本书，说我们干脆换个框架算了，于是就有了Spring。说起来这哥们也是个神人，他本科计算机专业毕业的，然后读了个音乐博士。</p>
<p>Spring现在那么盛行，几乎所有公司都在用Spring框架，倒不是因为技术、架构这些，而是跟思想有关。一说思想这个词，一般事情就变得玄妙了起来，简单点说呢，用Spring这套模式写代码，写起来感觉得心应手，少了很多麻烦，写着写着代码冥冥之中感觉很轻便，这就是因为Spring在思想上很先进。Spring的核心思想有两种，一种是IoC，一种是AOP，我们今天说前面那个IoC。</p>
<hr>
<p>IoC的全称是Inversion of Control，翻译过来叫控制反转。这并不是一个见名知意的名词，首先要解释一下这个概念。</p>
<p>好比我现在要制造一辆汽车，从无到有一步一步地建造。</p>
<p>首先我要先制造出汽车底盘，根据底盘的大小来确定汽车的外壳有多大。如果我建造了一个5米长的底盘，我不可能再建造一个10米长的汽车外壳，装不上去呀。所以你发现了，汽车外壳必须要根据汽车底盘来制造，这也就是汽车外壳依赖于汽车底盘，换句话说，我们造外壳的时候，是被底盘牵着鼻子走的。</p>
<p>对于有设计欲望的汽车制造师来讲，这很让人不爽，明明我要大显身手地去设计汽车外壳，让自己的车外观上十分拉风，结果却要根据汽车底盘来设计，这不行。因此我们找到了一家汽车零件厂，我就先造外壳，造完之后需要多大的底盘，去找汽车零件厂给我提供。让汽车制造师一番折腾，现在可以直接造汽车外壳，然后再管汽车底盘了。汽车底盘反依赖于汽车外壳，也就是说，底盘被外壳牵着鼻子走了。</p>
<p>我们要讨论的IoC控制反转，这里的控制，其实说的就是谁牵着谁鼻子走。按照原先的理解，A是B的底层，A要控制B；现在B先行，A跟着B走，B反而控制A了，这就是控制反转。</p>
<p>你应该感受到了，Ioc并不是什么具体的技术，而是一种思想，或者更确切地说是一种设计模式。</p>
<hr>
<p>我们说了半天控制反转，怎么控制的，怎么反转的，都快绕晕了。其实谁控制谁根本就不重要，不管是A控制B还是B控制A，也没什么区别，反转了又能怎么样嘛。</p>
<p>关键是在于，原来A控制B，那是一点点往上搭积木，A也得搭，B也得搭。控制反转之后，现在B还是要做，但是A怎么来的，我们就不管了。</p>
<p>就像是刚才举的造汽车的例子，原来汽车是怎么造的，先造底盘，再造外壳，一步一步地很是繁琐，约束还多。后来我们只造外壳，那底盘呢，底盘让汽车零件厂造去了，我们不造了。怎么来的我也不管，反正到时候你给我就行了。</p>
<p>你说是不是省很多事？</p>
<p>总结一下，IoC思想有两点好处：</p>
<ul>
<li>其一，再也不用写一大堆的初始化代码了，这些扔给别人去做。</li>
<li>其二（这个更重要），我们把代码松绑了，原本紧密依赖的两部分如今拆开了，用祖师爷的话说就是“降低了耦合度”。</li>
</ul>
<hr>
<p>我们再来聊Spring。</p>
<p>Spring框架实现IoC主要是这样子的，它在A类和B类之外增设了一个管理区，A类写好之后放进管理区里，B类要用A类的时候就去找管理区，管理区自动为B类分配。</p>
<p>知乎上有个哥们挺逗的，他这么形容Spring实现IoC的过程：</p>
<blockquote>
<p>农业社会中，你需要一个对象，你必须亲手把它 new 出来。 </p>
<p>工业社会中，你需要一个对象，可以去工厂那里获取。 </p>
<p>共产主义社会中，你需要一个对象，只需要凭 ID 去对象池里面领。 </p>
<p>这是何等的共产主义精神！</p>
</blockquote>
<p>让Spring这么一处理，对于B类而言，原来是自己主动获取A类，现在是需要的时候管理区自动给我（用术语来说，这一步叫做<code>注入</code>），原来A类相关的代码都是自己管理，现在交给管理区去管理。这就叫做“降低了代码之间的耦合性”。</p>
<p>这个管理区叫做<code>IoC容器</code>，容器（Container）是编程里面装东西的。</p>
<p>好的，我们说的概念已经够多了，就说到这里吧。关于Spring实现IoC的具体过程，我们之后再说吧。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2019/07/21/helloworld/</url>
    <content><![CDATA[<br>

<p>你好呀。</p>
<p>这里是我写编程相关文章的地方，每周更新一篇，来强迫自己学习。</p>
<p>我努力以<font color="#32CD32">说人话</font>为目标来写东西，尽量组织语言到谁都能听懂为止，虽然最终也不会有什么人来看啦。</p>
<p>我不会留任何联系方式的，这样你就没办法骂我写得渣了，有错误的话，也让我自己后知后觉吧。</p>
]]></content>
  </entry>
  <entry>
    <title>(tips) hexo图片加载</title>
    <url>/2019/08/11/hexo%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<br>

<p>hexo搭配typora加载图片时，要设置图片路径。</p>
<p>共分两步走：</p>
<ol>
<li>设置typora的图片根目录</li>
<li>粘贴图片时，图片要放进assets文件夹中</li>
</ol>
<p>具体操作如下：</p>
<br>

<p>首先点击typora工具栏的<code>格式</code>，然后选择<code>图像</code>，再选择<code>设置图片根目录</code>，就会在markdown文件的页首（header）中出现这样一句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typora-root-url: ..</span><br></pre></td></tr></table></figure>

<p>注意冒号后面要设置成 <code>..</code> ，意思是说typora的图片根目录，是文件的上一级文件夹。</p>
<p>（页首header截图如下）</p>
<p><img src="/assets/%E5%9B%BE1.png" alt="图1"></p>
<br>

<p>设置完typora的图片根目录后，就可以粘贴图片了，但是要注意图片要放进<code>assets</code>文件夹当中。</p>
<p>拿刚刚粘贴进来的上张图片来说，在markdown文件中，路径是这么写的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图1</span>](<span class="link">/assets/图1.png</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/assets/%E5%9B%BE2.png" alt="图2"></p>
<p>这样就可以了。</p>
<br>

<p>目录结构是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _posts</span><br><span class="line">│   └── (tips) hexo图片加载.md</span><br><span class="line">└── assets</span><br><span class="line">    ├── 图1.png</span><br><span class="line">    └── 图2.png</span><br></pre></td></tr></table></figure>

<hr>
<p>每次用hexo写文章，都要被环境配置搞得心态崩溃 = =</p>
<br>]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的反射机制</title>
    <url>/2019/07/25/reflect/</url>
    <content><![CDATA[<br>

<p>七月的第四周，来写反射。</p>
<p>反射是java很有意思的机制，有一点注入灵魂的感觉。</p>
<hr>
<p>写程序可以认为是女娲捏泥人的过程，女娲和了一团稀泥，揉捏出一个小人，放在地上，活了。</p>
<p>你设身处地想象一下，如果你是女娲造的其中一个小人，在落地之前一直都没有活。</p>
<p>那在你还没活的时候，你是不知道外面的世界长什么样子的，也不知道将来会遇到哪些小人。你不知道还有小王、小张、小李一起被造出来，你也不知道他们是什么样子的。</p>
<p>总之你只知道你自己的事情，你对其他的一无所知。</p>
<p>这就是你在活之前的状态。</p>
<hr>
<p>写程序如果按照正常理解，就应该是程序运行，安分守己地完成自己的任务。</p>
<p>如果写了一个名叫 <code>apple</code> 的类，程序运行的时候， <code>apple</code> 就应该安分守己地做 <code>apple</code> 的事情，它不会知道，在程序中还有 <code>banana</code> 、 <code>peach</code> 、 <code>watermelon</code> ，也没有办法知道，除了自己以外的其他类能够做什么。</p>
<p>反射是做什么的呢？</p>
<p>就像是你刚被女娲捏出形状时，女娲对你说：“以后你将遇到一个叫‘小王’的人，记得找他玩。”然后你活了之后，果然找到了小王，愉快地跟他玩了起来。</p>
<p>程序在运行的时候，具有了访问别人的能力，甚至还能用别人的东西，这就是反射。</p>
<hr>
<p>反射（reflect）是一个让人听了一头雾水的名字，但实际上确实也没有别的更好的表述方法，这就是一种比较难以形容的特性。如果暂时忘了这个名字，直接去理解这种特性，隐约理解之后再回来看反射这两个字，会稍微容易一些。</p>
<p>维基百科对于反射的描述，还是大概能看懂的，不然你试着搜搜百度百科的解释，当你精通概念之后回看才能勉强看懂。维基百科是这么说的：</p>
<blockquote>
<p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p>
</blockquote>
<p>java是一门具有动态性的语言，反射就是动态性的典型代表，这里的动态，说的就是程序正在运行。程序一边运行着，一边去查看自己的状态，然后做出修改，全程不停，就是动态。（但是java只能说有动态性，不能算动态语言）</p>
<hr>
<p>反射的原理是较为复杂的，这里面涉及到java虚拟机相关的内容，我基本也是小白，尽量按照自己的理解写清楚。</p>
<p>打开编程软件之后，我首先创建一个文件，然后在里面写上一段代码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello word!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件，它的文件名是<code>Hello.java</code>（就像是新建一个word文件，随便写了句话，保存之后文件名叫做<code>Hello.doc</code>一样），现在这个文件的后缀名是<code>.java</code>，这是我们的源代码文件。</p>
<p>你一定听过编译这个词，编译的意思是说，你写完代码之后，会有一种叫做编译器的东西帮我们把代码变成一堆010101……的二进制数字文件，也就是翻译成机器语言。编译器翻译完，会生成一个<code>Hello.class</code>文件，这时这个文件的后缀名是<code>.class</code>，这是我们的二进制流文件。</p>
<p>现在有了翻译给机器听的<code>Hello.class</code>文件之后，这个文件就要加载进java虚拟机当中，让电脑自己去读程序运行了。java虚拟机读取<code>Hello.class</code>文件的过程，是<font color="#32CD32">类加载过程</font>。</p>
<p>我们今天说的反射，它的原理就是这个<font color="#32CD32">类加载过程</font>。</p>
<p><img src="/assets/%E5%8F%8D%E5%B0%84%E5%89%8D.jpg" alt="反射前"></p>
<p>类加载的具体过程比较复杂，涉及到java虚拟机的很多内容，我们来说简化的过程。</p>
<p>简单来说呢，<code>.java</code>文件里写了很多代码，但是归归类可以分成这么几种：</p>
<ul>
<li>干垃圾</li>
<li>湿垃圾</li>
<li>有害垃圾</li>
<li>可回收垃圾</li>
</ul>
<p>java虚拟机中，也有相对应的区域，来分类存放写好的代码（以二进制数字的形式）：</p>
<ul>
<li>干垃圾桶</li>
<li>湿垃圾桶</li>
<li>有害垃圾桶</li>
<li>可回收垃圾桶</li>
</ul>
<p>类加载就是一一对应，垃圾分类的过程。</p>
<p>反射就是要在垃圾分类之后，问垃圾管理员要垃圾。</p>
<blockquote>
<p>你好，我是收废品的，请问有废易拉罐吗，给我一个。</p>
</blockquote>
<hr>
<p>我们再来重新看一下维基百科对于反射的定义：反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>比如我想知道，某一个类，它叫什么，它有哪些成员变量。</p>
<p>java虚拟机会在类加载过程中，生成一个Class类的对象，比如我之前写的那个<code>Hello.java</code>文件，java虚拟机将实例化一个Hello对象，我们之后可用直接用这个对象的各个方法，来进行反射操作（我们终于走到反射了）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class testClass = Hello.class;</span><br><span class="line"><span class="comment">// 获取类的名字</span></span><br><span class="line">testClass.getName();</span><br><span class="line"><span class="comment">// 获取类的成员方法</span></span><br><span class="line">testClass.getDeclaredFields();</span><br></pre></td></tr></table></figure>

<p>所以现在，我们通过反射，可以获知某一个类叫什么名字、父类是什么、限定符是什么、有什么成员变量、有什么构造方法……等等关于这个类的一切，我想知道什么，全都可以知道了。</p>
<p>那么我们现在梳理一下步骤：</p>
<ol>
<li>实例化一个Class类</li>
<li>调用这个Class类的方法，以获取到想要的东西</li>
</ol>
<p>如果Class类的功能，你觉得不够用，或者用起来不顺手，还有别的几种类可以去用，分别是Constructor（构造方法）、Field（成员变量）、Method（成员方法）和其他。</p>
<p>相关的方法列表有人帮忙总结出来了，详见下图。</p>
<p><img src="/assets/%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.png" alt="1564150307754"></p>
<hr>
<p>参考文献：</p>
<p><a href="https://www.imooc.com/article/8021" target="_blank" rel="noopener">https://www.imooc.com/article/8021</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></p>
<p><a href="https://zh.wikipedia.org/wiki/反射_(计算机科学)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)</a></p>
<br>

<p>第一篇怎么写的这么烂呜呜呜……不改了，没时间了，到新的一周了= =</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：排序</title>
    <url>/2020/04/26/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<br>

<p>四月的第四周，来整理排序算法，本篇文章基于 CS-Notes 的《算法-排序》，那篇文章的代码写得非常通用，使用泛型并继承 Comparable 接口来进行，本篇只针对数字做排序，重点放在算法而不是兼容上。</p>
<p>算法写完这一篇就暂时不写了，每天细水长流做一做题，多积累一点算法底蕴再抽空回来写。</p>
<hr>
<p>总结写在最前面，方便查看。本篇文章涉及七种排序算法（以及几种亚种），时间和空间复杂度的对比汇总如下：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>×</td>
<td>N²</td>
<td>1</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>√</td>
<td>N²</td>
<td>1</td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>N ~ N²</td>
<td>1</td>
</tr>
<tr>
<td>希尔排序</td>
<td>×</td>
<td>N 的若干倍乘于递增序列的长度</td>
<td>1</td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>NlogN</td>
<td>N</td>
</tr>
<tr>
<td>快速排序</td>
<td>×</td>
<td>NlogN</td>
<td>logN</td>
</tr>
<tr>
<td>堆排序</td>
<td>×</td>
<td>NlogN</td>
<td>1</td>
</tr>
</tbody></table>
<p>P.S. 稳定性的意思是，相同项排序前后不能调换位置，例如 1、[2]、(2)、3 排序后不能变成 1、(2)、[2]、3。</p>
<hr>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>遍历最小的交换</p>
<p><img src="/assets/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 从第一个开始，执行到倒数第二个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>相邻比较，最小的升到最前面</p>
<p><img src="/assets/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序">（这个 gif 是反过来的，最大的挪到最后）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 从倒数第一个开始，执行到第i+1个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>每个数字一路往前交换，等效为插入</p>
<p><img src="/assets/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 从第二个开始，每个数字一路往前交换，直到前面比它小为止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>改进的插入排序，设置了间隔</p>
<p><img src="/assets/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 间隔数量，初始值为[1, 4, 13, 40……]数列中最接近n的那个</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 从第h+1个开始，每个数字一路往前交换（间隔为h），直到前面比它小为止</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j--) &#123;</span><br><span class="line">                swap(nums, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>将数组分成两个子数组，分别排序，再合并</p>
<p><img src="/assets/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="归并排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] helpArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    helpArray = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">return</span> doMergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] doMergeSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        doMergeSort(nums, l, mid);</span><br><span class="line">        doMergeSort(nums, mid + <span class="number">1</span>, h);</span><br><span class="line">        merge(nums, l, h, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 技巧：用辅助数组</span></span><br><span class="line">    System.arraycopy(nums, l, helpArray, l, h - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, curr = l;</span><br><span class="line">    <span class="keyword">while</span> (curr &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid &amp;&amp; j &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helpArray[i] &lt;= helpArray[j]) &#123;</span><br><span class="line">                nums[curr++] = helpArray[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[curr++] = helpArray[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">            nums[curr++] = helpArray[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[curr++] = helpArray[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>让某数左边都是小于等于它的数，右边都是大于等于它的数，再二分递归</p>
<p><img src="/assets/%E5%BF%AB%E6%8E%92.png" alt="快排"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    doQuickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doQuickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="comment">// mid左边都是小于等于它的数字，右边都是大于等于它的数字</span></span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, l, h);</span><br><span class="line">        doQuickSort(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">        doQuickSort(nums, mid + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第一个数作为比较基础</span></span><br><span class="line">    <span class="keyword">int</span> target = nums[l];</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 左 -&gt; 右  找更大的数</span></span><br><span class="line">        <span class="keyword">while</span> (++i != h &amp;&amp; nums[i] &lt; target) ;</span><br><span class="line">        <span class="comment">// 左 &lt;- 右  找更小的数</span></span><br><span class="line">        <span class="keyword">while</span> (--j != l &amp;&amp; nums[j] &gt; target) ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 i&gt;j 要跟坐标小的交换，并返回这个小坐标</span></span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>数组中坐标 2k 和 2k+1 的数字，是 k 的叶子</p>
<p><img src="/assets/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 从倒数第二层预排一次，大顶堆</span></span><br><span class="line">        sink(nums, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最大的数交换到数组尾，将交换来的数再大顶堆下沉</span></span><br><span class="line">        swap(nums, <span class="number">1</span>, n--);</span><br><span class="line">        sink(nums, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent * <span class="number">2</span> &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> son = parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (son &lt; n &amp;&amp; nums[son] &lt; nums[son + <span class="number">1</span>]) &#123;</span><br><span class="line">            son++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父亲一定比孩子大，排到某层符合就不用排了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[parent] &gt;= nums[son]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, parent, son);</span><br><span class="line">        parent = son;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>整理完算法，顺便学习一下 Java 默认提供的一些排序 API。</p>
<h1 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable &amp; Comparator"></a>Comparable &amp; Comparator</h1><p>Java 排序相关的内容，最常用到的就是 Comparable 和 Comparator，这两个都是接口类。</p>
<p>Java 对容器、数组进行排序时调用的 sort() 方法（例如 <code>Collections.sort(list)</code>、<code>Arrays.sort(array)</code>）时，要不然让容器内的元素实现 Comparable 接口，要不然自己重写 Comparator 接口说明排序逻辑。知乎文章<a href="https://zhuanlan.zhihu.com/p/55934430" target="_blank" rel="noopener">《Java 中的排序》</a>对此解释得清晰明了：</p>
<blockquote>
<ul>
<li><p>如果一个类实现了 Comparable 接口，那么它“天生”就是可以借助 Collections、Arrays、SortedMap、SortedSet 等类来进行排序。</p>
</li>
<li><p>但是，如果一个类没有实现 Comparable 接口，却也想利用 Collections、Arrays、SortedMap、SortedSet 等来进行排序，就可以通过指定一个自定义的 Comparator 来实现。</p>
</li>
</ul>
</blockquote>
<p>如果觉得两个接口容易记混，可以思忖一下名字，一个叫做 Comparable（可以比较），表明实现该接口的类是可以进行比较的，另一个叫做 Comparator（比较器），表明该接口是用来确定比较大小逻辑的。</p>
<p>具体使用逻辑懒得写了，看看之后有没有写的动力吧……</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>线程入门</title>
    <url>/2019/10/27/%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<br>

<p>十月的第四周，学习多线程。</p>
<p>借着工作需求入门了线程，但是需求并不用考虑并发风险，使用的也是封装好的对象，因此这次入门入得比较浅。</p>
<p>这篇博文偏实用，有关概念解释的部分就略过不提了。</p>
<hr>
<p>原始的创建线程的方法有三种，分别是：</p>
<ol>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
</ol>
<p>注意，这里说的是创建线程，因此只总结怎么【搭架子】，不总结怎么【使用线程】。</p>
<p>这一部分基本全部参考<a href="http://zhangchangle.com/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e4%ba%8c%e3%80%81%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b" target="_blank" rel="noopener">博客《CS-Notes》</a>对于 Java 并发的梳理，这个博客的内容非常优质（不只是 Java 多线程与并发的部分），十分推荐。</p>
<h1 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h1><p>这是一种最为原始的方式，继承 Thread 类，重写 run 方法以实现线程功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PzThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,pz."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是指，我创建了一个名为 <code>PzThread</code> 的类，该类由于继承 Thread 类因而是一个线程类，它重写了父类的 run 方法，打印了一句话：【hello,pz.】。</p>
<p>使用时也异常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> PzThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>首先实例化一个线程出来，然后启动线程，当线程启动之后，控制台上打印了一句话：【hello,pz.】。</p>
<br>

<p>一般情况下不要使用这种方式来创建线程，因为通过继承来实现实在是太臃肿了，很多场景下我们只需要让线程跑起来，实现某个功能（即重写 run 方法），但是继承会实现 Thread 类的全部信息，性能消耗太大。而且 Java 是单继承的，继承了 Thread 类就不能继承其他类了。</p>
<br>

<h1 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h1><p>Runnable 接口是一切线程创建的根源，其实上面【继承 Thread 类】的途径，也是间接使用了本途径来创建线程的。</p>
<br>

<p>比较传统的实现 Runnable 接口的方式是，创建一个类，该类 <code>implements Runnable</code> 来实现 Runnable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PzRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是创建一个类，未免太大张旗鼓了些，还要新建一个类，设置好类名，实现接口，之后再实例化，兴师动众。其实实例化对象并不需要创建一个类出来，实现接口就行，用匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable pzRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，Runnable 接口是一个函数式接口，只定义了 run 方法，可以使用 lambda 表达式的方式来实例化，那就更简单了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable pzRunnable = () -&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面三种实现，都只是写了外壳，里面没有写具体的实现过程，具体的实现是要重写 Runnable 接口的 run 方法的。</p>
<p>我写了三种实现 Runnable 接口的代码，第一种最容易懂，后面两种如果有困惑，看一看 lambda 表达式就能理解了。</p>
<br>

<p>实现了 Runnable 接口之后，把它作为参数，放进 Thread 的构造方法里就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>这样就可以了。</p>
<br>

<p>要不再完整地走一遍？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口，重写 run 方法 （这里使用匿名内部类的方式，即上面的第二种）</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"by runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程并开启</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台上会打印出这样一句话：by runnable</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h1><p>以上两种方式，都没有任何的返回值，线程执行动作，执行完就结束了，无声无息。实现 Callable 接口的目的，就是为了让线程执行完之后，能返回信息。</p>
<p>简单对比一下，Runnable 接口和 Callable 接口，在代码上的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Callable 接口</span></span><br><span class="line">Callable callable = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你会发现，实现两个接口都只需要重写一个方法：</p>
<ul>
<li>实现 Runnable 接口需要重写【没有返回值】的 run 方法</li>
<li>实现 Callable 接口需要实现【返回一个对象】的 call 方法。</li>
</ul>
<p>其他的地方，在用法上仿佛没有什么不同。</p>
<p>实际上，Callable 接口还支持泛型，你可以指定返回值的数据类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定返回 String 类型</span></span><br><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<p>传统的线程设计，是没有返回值的概念的，因此没办法用线程类来获得返回值。JUC 包设计了一个新的接口：Future，来接收线程的返回值（和其他的功能）。Future 类是一个接口，无法直接实例化，因此又设计了一个名为 FutureTask 的类，该类实现了Future 接口和 Runnable 接口，打通了【线程功能】和【返回值功能】。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br></pre></td></tr></table></figure>

<p>上面这两行代码，是将刚才写好的 callable 对象，放进 futureTask 中，辗转放进线程中。你可以感受到，FutureTask 类是一个中介，它也支持泛型（不过上面这两行代码没写泛型）。</p>
<p>FutureTask 类有一个 get 方法，用于获取 callable 的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object returnStr = futureTask.get();</span><br></pre></td></tr></table></figure>

<p>（如果指定了 FutureTask 的泛型，上面还可以更确切地指定数据类型，例如把上面代码的 Object 改成 String）</p>
<p>这个 get 方法需要处理两类异常：InterruptedException 和 ExecutionException。</p>
<hr>
<p>需求一不小心写完了……啥都没学到，算了先写到这里叭。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>没写完的递归</title>
    <url>/2019/09/01/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>八月和九月交界的一周，来学习递归算法。</p>
<p>真的是被递归给搞怒了，拿出一周来跟它谈谈。</p>
<hr>
<p>递归是一个反复调用自己的过程，<font size="7">A</font> →  <font size="6">A</font> → <font size="4">A</font> → <font size="6">A</font> →  <font size="7">A</font> ，一层层进去，再一层层出来。我觉得自己一直以来对递归感到迷惑，主要是因为只注意到了进去的过程，而忽视了出来的过程。至于什么停止条件的判断，其实倒还在其次。</p>
<p>我隐约感觉，真正理解递归，能够很熟练地凭感觉写递归，应该要去学习函数式编程，但是这周权且只能写写初级认知了。</p>
<p>我认为写递归要搞清楚两个地方：</p>
<ol>
<li>用递归做什么</li>
<li>在乎的是【递归前】还是【递归后】</li>
</ol>
<p>第一个问题，是要清楚为什么需要使用递归，在什么地方使用递归。思考清楚了使用递归的场景，也就顺便思考清楚了递归函数的传参、返回值是什么。</p>
<p>第二个问题，是搞清楚在调用递归时，究竟是关注一步步进去，还是关注一点点出来。</p>
<p><img src="/assets/%E9%80%92%E5%BD%92.jpg" alt="递归"></p>
<p>画了一张简图，把递归的过程比作【下楼梯】再【上楼梯】的过程。</p>
<p>哎鸭，写着写着发现跟自己想的不太一样，好像要推导重来，可是又到了下一周的周一了。</p>
<p>这周每天晚上都在写一封十年的仪式信，周末又赶上搬家和无手机日，时间没有规划好，不写了，呜呜呜。</p>
<p>下一周学习 spring cloud 。</p>
<br>

<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN 与 Git</title>
    <url>/2019/11/20/SVN-%E4%B8%8E-Git/</url>
    <content><![CDATA[<br>

<p>十一月的第二周，来学习版本控制系统。</p>
<p>整顿一下，最近写博文总是拖到下一周的周一或者周二才完成，这周一定要努力在周日结束之前发文。</p>
<hr>
<p>版本控制系统是一个初听有点唬人的名字，版本、控制、系统，这三个词都是带几分黑金属性的气质词汇，合在一起颇有架势。它代表的是这样一个概念：我希望有一个文件库，里面不光存放了所有文件，还保留了每一次的修改信息，如果我想查看某个文件三天前是什么样子的，我仍能看到。</p>
<p>当下常见的版本控制系统就两种，一种是 SVN，另一种是 Git。这两种系统从架构上，到功能实现上，再到价值观上，都是不一样的。总体来说，Git 处于鄙视链的上游地位，代表着信仰，SVN 处于备受唾弃可又怎么都淘汰不了的状态中，充满着妥协。（言重了，言重了）</p>
<hr>
<h1 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h1><p>我目前工作中使用的是 SVN，实际上我到写博文之前，都是没有使用过 Git 的。所以只能说基本整理一下 SVN 的使用逻辑与方法，但对于 Git 就是浅尝辄止了。</p>
<p>SVN（Subversion），是阿帕奇（Apache）家出的版本控制系统，这家公司（或者应该叫基金会吧）从 HTTP 起家，贡献了 Maven、Kafka、Tomcat 等一堆开源软件或框架，实乃业界良心大佬。SVN 本是为了取代 CVS（一种上古的版本控制系统）而推出的，应当视作一种特定的软件/框架。但是目前看来，SVN 实在是太过成功，以至于成为了一种标杆的存在，代表着中心式的版本控制系统。</p>
<br>

<p>中心式的意思是，文件集中起来，由一台服务器进行管理，进行版本控制。如果一个团队有 10 个人，这 10 个人如果想提交代码，或是更新代码，则必须和中心服务器连接起来，提交则上传上去，更新则下载下来。除此之外，我认为中心式还有两层表现：</p>
<ol>
<li>中心只维护一套文件，换句话说，使用 SVN 控制的文件，只会有一种表现结果。如果 A 和 B 一起写东西，A 说豆腐脑要吃甜的，B 说豆腐脑要吃咸的，那么上传到中心服务器中的文件，豆腐脑要不然吃甜的，要不然吃咸的，不可以共存。而且，由于只有一套文件，如果文件的内容发生冲突了，提交时必须要自己合并代码，要不然你早点传文件占得先机，要不然就后传文件做冲突处理。</li>
<li>版本的最终解释权和维护权，在中心。如果你和中心断开了连接，最直接的，你将无法提交代码，也无法更新代码；其次，你没有办法查看某个特定版本的文件，因为所有版本是什么样子的，只有中心才知道，如果觉得自己的代码写得有问题想回滚，那么请先连接中心。</li>
</ol>
<p>我们在讨论 SVN 和 Git 之间的区别时，大多数情况下，是在讨论<code>中心式管理</code>和<code>分布式管理</code>之间的区别。SVN 没有本地库，无法断网开发，几乎不搞分支等等，这些背后基本都是因为它中心式的架构。</p>
<br>

<p>SVN 的使用，说实话没什么好写的，因为日常操作实在是太过简单。</p>
<p>平常能够使用 SVN 的地方有两处，一处是 IDE，写代码的时候用到，另一处是 SVN 的客户端 TortoiseSVN（小乌龟），不写代码的时候用到。</p>
<p>使用 SVN，最稀疏平常的两个操作是<code>提交代码</code>和<code>下载（更新）代码</code>，提交代码是 commit，更新代码是 update，这两个操作都可以在 IDE 中通过点击鼠标完成（其他操作基本也都可以通过点鼠标完成）。</p>
<p>除了这两项天天都会用到的操作之外，还有<code>检出代码</code>（checkout），即把最新的代码拷贝出来一份，<code>回滚代码</code>（revert），即把代码还原到上一次的提交状态。<code>对比代码</code>（compare with…），即对比自己写的代码和某个版本的代码，<code>显示版本历史</code>（show history），即查看每次的提交记录，以及最最最让人厌烦的<code>代码合并</code>（merge），这并不是一个 SVN 的功能，而是每次提交/更新代码时，如果你的代码和中心代码同时修改了某一处地方，造成了冲突，你需要手动合并。</p>
<p>SVN 的客户端小乌龟，是在不需要写代码的时候使用到的，例如拷贝出来一份代码，修改配置文件的一点参数等等。</p>
<p>实在话，SVN 的使用凭直觉去使用就可以了。</p>
<br>

<p>最后我们记录一点 SVN 使用背后的事情。</p>
<p>SVN 是基于文件的来进行版本控制与管理的，如果有三个文件进行改动，就把这三个文件的变化内容记录下来，其他文件不变，并为此赋予一个版本号。<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">下图</a>是 Git 文档对于 SVN 文件版本的演变示意图。</p>
<p><img src="/assets/SVN%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC.jpg" alt="SVN文件版本"></p>
<p>我认为，浅尝辄止地认识 SVN 存储原理，需要认识到两个方面：</p>
<ol>
<li>SVN 的存储是基于文件的，而且它存储的是文件差异。如果文件内容有变化，记录下来，如果文件内容没有变化，无视。</li>
<li>SVN 的版本号是全局的，它描述的是所有文件。所有人都可以向中心指定一个版本号，来获取一整套完整的文件。</li>
</ol>
<hr>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>惭愧地讲，我至今都没有在 IDE 中使用过 Git，本来想借着这篇博文开始使用，但是用的梯子太不稳定，我连不上高墙之外的 github。</p>
<br>

<p>Git 是 Linux 社区搞出来的东西，因为原先用的版本控制工具不让用了，Linux 内核组的大佬花了俩周捣鼓出来一个分布式版本控制系统，也就是 Git，这可真是大佬的任性与倔强……</p>
<p>Git 是分布式版本控制系统的代表，分布式换个表述就是“去中心化”，这是 Git 的核心。稍一思索就会明白，Git 是一个典型的脱胎自 Linux 的产品，Linux 的开发人员是全球的草莽程序员，代码组起来讲究一个英雄不问出处，你指望一个中心式的版本控制系统是不可能的，Git 的出现就是为了实现分布式版本控制系统，分布式是刻在 Git 骨子里的。</p>
<p>Git 为了实现分布式，在设计上就与 SVN 完全不同，主要体现在这些地方上：</p>
<ol>
<li><p>Git 同样有中心服务器（远程仓库），但是还有本地仓库。在 SVN 中你只能从中心拉取代码，但是在 Git 中你可以向另一个人的本地仓库处拉取代码。</p>
<p>事实上，Git 在文件存储位置上的设计远非如此，它设计了四个区域：工作区、暂存区、本地仓库、远程仓库，写代码时你在工作区内写，写完之后保存在暂存区中，当你觉得应该提交代码了，就可以向本地仓库和远程仓库提交代码。</p>
<p>这种设计造成了两点不同：第一，你可以在暂存区中“攒够”了代码之后再提交，暂存区中的代码可以有好几种版本，你选取一种最好的提交；第二，版本信息不再只保存在中心服务器中，每个人本地也有版本信息，你可以在脱网的情况下查看版本信息（例如对比代码、回滚代码）。</p>
</li>
<li><p>Git 可以随随便便开分支。分支是相对于主线的概念，在 SVN 中大家共用的那套文件一般情况下只会有一条主线，荣也同荣，损也同损，但在 Git 中你可以随便开一个分支，在主线之外处理自己的事情。例如开一个分支实现自己的某个想法，成立则合并进主线，不成立则扔掉这个分支。分支这个概念，使个人能够随便试错，也使团队可以包容多元。</p>
<p>但是在我查资料的时候，发现很多大佬在讨论 merge 和 rebase 命令之间的选择问题，实际上是在讨论如何让共用版本的分支变少，让版本主线变得“清爽”。这个我大概要用到才能真的体会到，在此只是记录下来。</p>
</li>
</ol>
<br>

<p>Git 存储文件的原理，我至今不是很理解，这里记录一下我整理的材料以及认知程度。</p>
<p>每一次提交代码时，Git 将生成一个全部文件的<code>快照</code>。这跟 SVN 的处理方式是完全不同的，SVN 通过记录文件的差异来存储最新的版本内容：我有 A 文件，我有一个文件记录新旧文件的差异，我就可以通过计算得出最新的 A1 文件。你应该注意到，SVN 存储是基于文件的，三个文件改动了就记录下三个差异文件，五个改动就记录五个。但是 Git 每次都是同时记录所有文件，以<code>快照</code>的原理来实现。</p>
<p>我花了好几天，仍不理解快照是什么，我只知道快照不是什么。首先，快照不是文件差异，快照记录下的不光是差异，而是全部信息，有篇博文解释了这件事情：<a href="https://www.optbbs.com/thread-3985923-1-1.html" target="_blank" rel="noopener">《Git 快照与 SVN 文件差异区别》</a>，但是我对它的正确性存疑（因为没有其他相同观点的文章佐证）。其次，快照不是备份，备份相当于把文件拷贝一份保存在另外一个地方，可以独立存在，而快照需要基于原文件才能读取。</p>
<p>使用快照的好处一在快，二在保存全部文件信息。似乎这是一种用空间换时间的技术方法，但我实在是知之甚少，不敢断言。</p>
<br>

<p>记录下两个学习 Git 的公认必备网站，<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰 Git 教程》</a>、<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">《Pro Git 电子版》</a>。总体感觉上，前者论术，后者论道。论术的那个，语言轻浮且不是我喜欢的那类轻浮，论道的那个，翻译腔重（或者说原文就不适合用中文理解），两个都不是我很喜欢的类型。在此记录一下，日后还是要勤读。</p>
<hr>
<p>就不该开篇立 flag，说什么周日前发文，这篇拖更两周才写完……</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式</title>
    <url>/2019/10/20/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<br>

<p>十月的第三周，来学习 Lambda 表达式。</p>
<p>这周休息一下，本来呢要学习 Java 8 的函数式编程特性，Lambda 表达式只是其中的一部分，结果为了写之前的博文每周都欠债，这周水一下……</p>
<hr>
<p>先来讨论，lambda 表达式是干什么的。</p>
<p>Java 是一门面向对象的语言，万物皆对象，做什么也都离不开对象。对象内可能有属性，可能有对象，也有可能有方法，就比如说：我，18 岁（属性），有只猫（对象），我喜欢撸猫（方法）。Java 面向对象的体现就在于，我多少岁、有什么、做什么（也就是对象的属性、方法等等），前提都在于“我”的存在。</p>
<p>所以说，Java 里存在着对象，也存在着行为（方法），但是行为一定要有对象作为前提，不存在脱离了对象的行为。就好比说我喜欢撸猫，【喜欢撸猫】这个行为，一定是要有“人存在”作为前提的，不存在着没有执行动作人的行为。</p>
<p>可如果，我只需要行为，不在乎对象是谁呢？</p>
<p>我举一个例子。比如说，有一个列表需要排序，排序是一种行为，但是列表本身没有排序的能力。那么，列表要实现排序这种行为，就要先找一个【排序者】，让它去执行排序这个行为。这是一条很清晰的逻辑线：列表要排序，先找一个【排序人】，让它去排序。这个逻辑看上去很正常，可问题在于，列表根本就不在乎，到底是谁去执行排序这个行为，列表在乎的，只是它需要排序这个行为本身。在这种场景下，我们只需要行为，而不需要去关心拥有行为能力的那个对象是谁。</p>
<p>说得再清晰一些：我们不想传入对象，我们只想传入行为。</p>
<p>这就是 lambda 表达式存在的意义。</p>
<hr>
<p>所有教程介绍 lambda 表达式，上来就是一通劈头盖脸的匿名内部类代码，你想清楚逻辑就知道为什么要这么介绍。我们的目标是什么，是为了传入行为，而不在乎对象是谁。原来怎么解决的，用匿名内部类，虽然为了传入行为还是传入了对象，但是这个对象是一个匿名的对象。理解了吗，为什么用匿名内部类，是为了用一个匿名的对象传入我们想要的行为，对象是谁不重要，行为本身才重要。</p>
<p>Jdk 8 之后，函数式编程出头了，lambda 表达式出现了，既然对象是谁不重要，那么我们也就不用匿名了，干脆只传行为就行了。</p>
<p>你看这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">"按钮被点击了"</span>));</span><br></pre></td></tr></table></figure>

<p>这一行代码的意思是：在小括号内，我传入了一个行为，而且我只传入了一个行为。</p>
<p>我对于 lambda 表达式的解释到此为止，我建议再去看看这篇知乎问答：<a href="https://www.zhihu.com/question/20125256/answer/324121308" target="_blank" rel="noopener">《Lambda 表达式有何用处？如何使用？》</a>，写得行云流水，逻辑上非常舒畅。如果看后面的内容觉得云里雾里，可以再回头看一下这篇回答。</p>
<hr>
<p>当我要开始写 lambda 表达式具体如何使用时，内容分成了两部分：</p>
<ol>
<li>lambda 表达式怎么使用（语法）</li>
<li>lambda 表达式用在哪里</li>
</ol>
<p>实际上，我一直都对 lambda 表达式的语法不存疑惑，它在语法上就已经足够让人看懂了，即使是不会写，但也能大致看懂别人写的代码想做什么。我一直以来不理解的地方在于，lambda 表达式到底要用在哪里，当我写哪些代码的时候，可以使用 lambda 表达式？</p>
<p>所以我们先来看，lambda 表达式要用在哪里，lambda 表达式的类型究竟是什么。</p>
<br>

<p>我们先搞清楚，lambda 表达式的类型是什么。</p>
<p>在 Java 中，lambda 表达式依旧是一个类，它是一个接口的实现类。</p>
<p>我们来举一个例子，一个列表排序的例子。</p>
<ol>
<li><p>一个排序的场景</p>
<p>我们自定义一个 Person 类（代码略），该类有两个属性：姓名、年龄。我们实例化三个 Person 对象，然后把这三个 Person 对象放进一个列表里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">21</span>);</span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line">Person person3 = <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">22</span>);</span><br><span class="line">List&lt;Person&gt; personList = Arrays.asList(person1, person2, person3);</span><br></pre></td></tr></table></figure>

<p>此时这个列表里面有三个对象，它们的排列顺序是往里添加的顺序，也就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [Person&#123;name='张三', age=21&#125;, Person&#123;name='李四', age=20&#125;, Person&#123;name='王五', age=22&#125;]</span></span><br></pre></td></tr></table></figure>

<p>我们现在希望，这个列表里面的三个 Person 对象，能够按照年龄的大小排序。我们可以通过 lambda 表达式来实现排序（暂且先看着，不要理语法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personList.sort((a, b) -&gt; a.getAge() - b.getAge());</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Person&#123;name='李四', age=20&#125;, Person&#123;name='张三', age=21&#125;, Person&#123;name='王五', age=22&#125;]</span></span><br></pre></td></tr></table></figure>

<p>你看，此时这个列表里面，就按照年龄排序了。</p>
</li>
<li><p>拆解看实现过程</p>
<p>上面通过 lambda 表达式实现了按照年龄排序，只用了一行代码。实际上这是两行代码合了起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personList.sort((a, b) -&gt; a.getAge() - b.getAge());</span><br><span class="line"><span class="comment">//  ↓↓↓  （实际上，上面这行代码，就是下面这两行代码的组合）</span></span><br><span class="line">Comparator&lt;Person&gt; comparator = (a, b) -&gt; a.getAge() - b.getAge();</span><br><span class="line">personList.sort(comparator);</span><br></pre></td></tr></table></figure>

<p>你观察那句 lambda 表达式，即 <code>(a, b) -&gt; a.getAge() - b.getAge()</code>，它被赋给了 Comparator，而 Comparator 实际上就是一个接口，一个负责排序的接口。</p>
<p>那么这行代码：<code>Comparator&lt;Person&gt; comparator = (a, b) -&gt; a.getAge() - b.getAge();</code>，它的意思是说：</p>
<ul>
<li>我们写了一句 lambda 表达式。</li>
<li>这句 lambda 表达式，实际上是 Comparator 接口的一个实现类。</li>
</ul>
</li>
</ol>
<br>

<p>我们来思考一下，通过 lambda 表达式，到底做了一件什么事情。</p>
<p>在通常情况下，某一个方法需要一个接口的具体实现类的对象，那我们就要自己去写一个类，让该类继承接口，实现接口的方法，从而获得一个实现了接口的类，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（如果觉得这样子很繁琐，也可以通过匿名内部类的方式去实现。）</p>
<p>而通过 lambda 表达式，我们不再需要自己写一个类出来，让这个类去继承接口实现方法，这非常麻烦，而且会模糊掉我们的目的。我们不再新建一个类，而是使用 lambda 表达式，lambda 表达式本身，就是一个接口的实现类。</p>
<p>这样做最大的好处（在我看来），就是我们无视了对象，直视行为本身。</p>
<p>你重新来看这行排序代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personList.sort((a, b) -&gt; a.getAge() - b.getAge());</span><br></pre></td></tr></table></figure>

<p>你不用管它是什么意思，实现了什么功能，你是不是能非常直观地看出，小括号里面【在做某件事】，括号里面它是一个很清晰可知的行为。我们通过拆解代码能知道，括号里面的这句 lambda 表达式，实际上是一个类，但是在代码的直观性上，它是什么不重要，在这里，它就代表了一个行为。</p>
<p>简洁，直观。</p>
<hr>
<p>我再次把 lambda 表达式的类型表述一遍：</p>
<blockquote>
<p>lambda 表达式是函数式接口的一个实例，但 Lambda 表达式本身不包含它要实现的函数式接口的信息，这要由它所在的上下文推断出来。</p>
</blockquote>
<p>这句话摘自<a href="http://www.lambdafaq.org/what-is-the-type-of-a-lambda-expression/" target="_blank" rel="noopener">《What is the type of a lambda expression?》</a>。这句话表达了两件事：</p>
<ol>
<li>lambda 表达式的类型是一个函数式接口</li>
<li>lambda 表达式本身不含接口信息，接口信息是编译器根据上下文猜出来的。</li>
</ol>
<p>第一条多了一点信息，它说 lambda 表达式的类型不光是接口，还是函数式接口。这个我觉得顺带一提就可以了，函数式接口的意思是，只包含一个抽象方法声明的接口。你设想一下，lambda 表达式的作用是传入行为，一个方法对应一个行为，如果接口中有多个抽象方法，那岂不是就有多个可传入的行为，那一条 lambda 表达式肯定做不到。我们这里是反推了，其实函数式接口的概念应该先于 lambda 表达式。</p>
<p>这第二条，就要说到 lambda 表达式的语法了。</p>
<br>

<p>lambda 表达式的基本样板长这样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(      ) -&gt; </span><br><span class="line">(      ) -&gt; &#123;       &#125;</span><br></pre></td></tr></table></figure>

<p>左边的小括号放参数，右边要不然没有大括号，放表达式；要不然有大括号，放执行语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">()              5</span><br><span class="line">x               2 * x</span><br><span class="line">(x, y)      -&gt;  x + y</span><br><span class="line">(int x)         &#123; return 2 * x; &#125;</span><br><span class="line">(String s)      System.out.println(s)</span><br></pre></td></tr></table></figure>

<p>以上是几个例子，大致观察一下就能看出，lambda 表达式是一种崇尚简洁的表达式，大小括号、参数类型、返回体等等都是能省则省，总之能让编译器分析上下文猜出来的，都尽量不写。如果原接口声明了参数类型，那么就可以不在 lambda 表达式中写清楚数据类型，如果原接口声明了返回值类型，并且比较简单，那么在 lambda 表达式中就可以只写一句表达式，而无需写执行语句，编译器会猜到我们想返回这个表达式。</p>
<p>例如，对于这句 lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure>

<p>你可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure>

<p>但是当所有的信息（包括很多冗余信息）都写出来时，会让代码丧失掉直观性，你可能无法看一眼就知道这句 lambda 表达式想做什么。因此在编译器能够分析出来的前提下，应当尽量少写，让 lambda 表达式想传入的行为变得尽可能直观。</p>
<p>本篇就写到这里。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflux 入门</title>
    <url>/2020/06/30/Spring-Webflux/</url>
    <content><![CDATA[<br>

<p>真是混沌的一个月呀，不管第几周啦，就当做六月的最后一个周吧。</p>
<p>这个周入门 Spring Webflux，归纳学习响应式编程，但只从两个最常用的两个类：Mono 和 Flux 入手，关注一下基本使用。</p>
<hr>
<p>响应式编程（Reactive programming）是一种不好形容的编程模式，常见的描述语或定义语中会出现：异步、非阻塞、传递变化、支持背压。我觉得自己的理解还不到位，决定本篇不定义或是阐述响应式编程是什么，只入个门，之后回来补这部分功课。</p>
<p>抛开定义，仅从代码的形式上来看，响应式编程跟 JDK 8 中常见的 stream 流，在使用上很接近，例如下面这段响应式代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mono.just(jsonParam)</span><br><span class="line">        .map(param -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"随便打印点东西：&#123;&#125;"</span>, param);</span><br><span class="line">            <span class="keyword">return</span> param.get(<span class="string">"user"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .onErrorResume(Mono::error)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<br>

<p>我在工作中使用的响应式编程框架是 Spring Webflux，它基于 Reactor 3 实现（由 Spring 母公司 Pivotal 的某团队开发），论辈分可能是第四代，或者是第五代。</p>
<p>响应式编程的历史渊源有点复杂，简单来说，最早是微软一帮人在 2010 年写出了 Rx.NET，运行在 .NET 平台上，后来在各个平台上都做了类似的实现，例如 RxJs、RxJava等（Rx 是 ReactiveX 的缩写），其中 RxJava 就是在 Java 平台上的实现。后来出现了 Project Reactor、Akka-Streams 之类的响应式框架。在 2013 年末，Netflix、Pivotal、Typesafe 等公司开始牵头制定响应式流规范，并在 2015 年正式发布了 Reactive Streams 规范，这个规范直接表现在 JDK 9 JUC 包中的 Flow API。如今的响应式框架基本都实现了 Reactive Streams 规范，业界主流的是 RxJava 2 和 Reactor 3。</p>
<p>响应式编程的历史还可以参考这篇文章《<a href="http://akarnokd.blogspot.com/2016/03/operator-fusion-part-1.html" target="_blank" rel="noopener">Advanced Reactive Java</a>》（偶然搜到的，不知是何方神圣）。</p>
<p>本篇学习的内容是 Reactor 中的 Mono 和 Flux 两个类的使用，我也懒得介绍这两个类了，下面的内容会很干。</p>
<hr>
<h1 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>just</td>
<td>Mono.just(user)…</td>
<td>把元素加入流中</td>
<td>元素不能是null，否则抛空指针</td>
</tr>
<tr>
<td>justOrEmpty</td>
<td>Mono.justOrEmpty(user)…</td>
<td>把元素（可能为null）加入到流中</td>
<td>元素如果是null，返回Mono.empty()</td>
</tr>
<tr>
<td></td>
<td>Mono.justOrEmpty(optional)…</td>
<td>把元素（Optional对象）加入到流中</td>
<td>元素如果是空，返回Mono.empty()</td>
</tr>
<tr>
<td>defer</td>
<td>Mono.defer(() -&gt; Mono.error(new RuntimeException(“懒异常”)))…</td>
<td>把Mono元素加入流中，但是延时加载，直到有subscribe时才会加载元素</td>
<td>可以理解为懒加载，当subscribe时才加载元素（每次subscribe都会重新加载）。<p>例如有一个用法是，当需要定义异常Mono.error()，并不需要每次都创建，而是在出现异常时才加载，可以节省内存</p></td>
</tr>
<tr>
<td>deferWithContext</td>
<td>Mono.deferWithContext(context -&gt; Mono.just(“test”)))…</td>
<td>与defer()方法几乎完全相同，只是接受参数变成了Function，可以拿到流的context</td>
<td>context来自reactor.util.context包，代表流的上下文，用法不明，待后续</td>
</tr>
<tr>
<td>fromCallable</td>
<td>return Mono.fromCallable(() -&gt; {     Thread.sleep(1000 * 3);     return “休眠了三秒”; })…</td>
<td>通过Callable获取元素加入到流中，是支持阻塞的一种实现</td>
<td>有很多类似的fromXXX()方法，例如fromFuture()、fromRunnable()等</td>
</tr>
<tr>
<td>empty</td>
<td>Mono.empty()…</td>
<td>创建流，但流中没有任何元素</td>
<td>后续如果有flatmap()、map()等，都不会执行，但then()等可以执行，可以用于忽略后续数据</td>
</tr>
<tr>
<td>never</td>
<td>Mono.never();</td>
<td>永不停止，不搭理任何数据，就此睡死</td>
<td></td>
</tr>
<tr>
<td>error</td>
<td>Mono.error(new RuntimeException(“失败”))…</td>
<td>将一个异常加入流中，并立即停止后续操作</td>
<td>参数是Throwable对象，error立即加载，无论是否用到</td>
</tr>
<tr>
<td></td>
<td>Mono.error(() -&gt; new RuntimeException(“失败”))</td>
<td>将一个异常加入流中，并立即停止后续操作</td>
<td>参数是Supplier函数，error懒加载</td>
</tr>
<tr>
<td></td>
<td>Mono.delay(Duration.ofSeconds(3))…</td>
<td>上来就延时</td>
<td>延时后返回0</td>
</tr>
</tbody></table>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>flatMap</td>
<td>…flatMap(t -&gt; {<br>     return Mono.just(t); })…</td>
<td>将一个Mono转换成另一个Mono（异步）</td>
<td>参数是一个Function（接收Mono中的值，返回一个新的Mono）</td>
</tr>
<tr>
<td>map</td>
<td>…map(t -&gt; {<br>     return t; })…</td>
<td>将Mono中的内容进行更改</td>
<td>参数是一个Function（接收Mono中的值，返回另一个值）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cast</td>
<td>Mono.just(map)         .cast(HashMap.class)…</td>
<td>将Mono中的对象，从A类转换成B类</td>
<td>等价于map(clazz::cast)</td>
</tr>
<tr>
<td>sequenceEqual</td>
<td>Mono.sequenceEqual(monoA, monoB)…</td>
<td>比较两个Publisher（Mono、Flux）是否相同</td>
<td>返回的是一个<code>Mono&lt;Boolean&gt;</code></td>
</tr>
<tr>
<td></td>
<td>Mono.sequenceEqual(monoA, monoB, (a, b) -&gt; a.length() == b.length())…</td>
<td>比较两个Publisher（Mono、Flux）是否相同（可以指定条件）</td>
<td></td>
</tr>
<tr>
<td>zip</td>
<td>Mono.zip(mono1, mono2, mono3)…</td>
<td>将多个Mono合并成一个Mono（内部是Tuple对象），可以通过tuple.getT1()等类似方式取出一个个内容</td>
<td>如果其中一个Mono发生异常，逻辑同抛出Mono.error()，如果有多个Mono发生异常，将按顺序取第一个异常</td>
</tr>
<tr>
<td>zipDelayError</td>
<td>Mono.zipDelayError(mono1, mono2, mono3)…</td>
<td>功能上同zip()，但在处理异常的时候逻辑不同</td>
<td>如果多个Mono发生异常，将组合成一个新的异常</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>retry</td>
<td>Mono.just(10/0).retry(10)…</td>
<td>遇到异常重试</td>
<td>从头执行，而不是只执行上一步<br>有很多变种，参数总体与异常类型和重试次数有关</td>
</tr>
<tr>
<td>repeat</td>
<td>Mono.just(“.”).repeat(10)…</td>
<td>重复（在非异常情况下），会从Mono变成重复元素的Flux</td>
<td>有很多变种，并且跟retry一样，都不算最开始的一次</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><p>跟 Mono 相同的就不写了，下面的内容全都是 Flux 独有的</p>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>fromIterable</td>
<td>Flux.fromIterable(list)…</td>
<td>从一个迭代器对象（实现Iterable接口的对象）中，把所有元素加入Flux中</td>
<td>类似的还有fromArray、fromStream</td>
</tr>
<tr>
<td>range</td>
<td>Flux.range(20, 5)…</td>
<td>把一系列数字加入Flux中，这些数字间距为1</td>
<td>例如示例中加入Flux中的数字是20、21、22、23、24，从20开始，一共5个</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="转换-1"><a href="#转换-1" class="headerlink" title="转换"></a>转换</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Flux.fromIterable(list).index()…</td>
<td>给Flux内的多个元素加下标</td>
<td>例如从[“a”,”b”,”c”]变成[{0:”a”},{1:”b”},{2:”c”}]，转换后每个<strong>T</strong>变成一个二元元祖Tuple2&lt;Long, <strong>T</strong>&gt;</td>
</tr>
<tr>
<td>startWith</td>
<td>.startWith(list)…</td>
<td>将某些内容塞到Flux的最前面</td>
<td>比如原Flux里有[1,2,3]，新插入[8,9]，然后Flux变成[8,9,1,2,3]</td>
</tr>
<tr>
<td></td>
<td>.startWith(mono)…</td>
<td></td>
<td>同上，接收一个Publisher对象</td>
</tr>
<tr>
<td></td>
<td>.startWith(t1, t2, t3)…</td>
<td></td>
<td>同上，接收若干个和Flux中其他元素相同的对象</td>
</tr>
<tr>
<td>concatWith</td>
<td>.concatWith(mono)…</td>
<td>将某些内容塞到Flux的最后面</td>
<td>与startWith的左右相反，但只接收Publisher对象</td>
</tr>
<tr>
<td>take</td>
<td>Flux.fromIterable(list).take(10)…</td>
<td>只取前面几个元素，后面的舍弃</td>
<td>有很多种变种，例如前N个、某段时间之前、某条件没改变之前等</td>
</tr>
<tr>
<td>collect</td>
<td>Flux.fromIterable(list).collect(Collectors.toList())…</td>
<td>把Flux中的多个元素封装成一个Mono集合</td>
<td>使用起来跟JDK 8的Stream一个逻辑，例如<br>list.stream().filter(num -&gt; num &gt; 10).collect(Collectors.toList());</td>
</tr>
<tr>
<td>collectList</td>
<td>Flux.fromIterable(list).collectList()…</td>
<td>把Flux中的多个元素封装成一个Mono列表</td>
<td>例如从<code>Flux&lt;String&gt;</code>转变成<code>Mono&lt;List&lt;String&gt;&gt;</code>，还有很多类似的collect()方法</td>
</tr>
<tr>
<td>window</td>
<td>Flux.just(1,2,3,4,5,6,7,8,9).window(3)…</td>
<td>把一个Flux拆成多个Flux，拆后的Flux的元素个数是window内的个数</td>
<td>例如左边示例代码，会把[1,2,3,4,5,6,7,8,9]转换成[1,2,3]、[4,5,6]、[7,8,9]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>我发现 Mono 和 Flux 的 Api 实在是太多太多了……我都已经整理三周了，还是没有整理完，不能再拖下去了hhh</p>
<p>本篇文章先写到这里，之后用到哪个新的 Api 就回来接着补充。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>java 异常</title>
    <url>/2019/08/22/java-exception/</url>
    <content><![CDATA[<p>八月的第四周，来学习 Java 的异常处理机制。</p>
<p>异常就是不正常，程序不能正常执行，中途遇到了的问题就是异常。这次来写异常分哪些情况，以及怎么处理异常。</p>
<hr>
<p>首先需要厘清的是，几乎所有介绍异常的总结贴，以及面试时对异常的提问，基本上说的都不光是异常，而是整个异常体系。</p>
<p><img src="/assets/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%EF%BC%88%E7%AE%80%E7%95%A5%EF%BC%89.png" alt="异常体系（简略）"></p>
<p>看一下简图就很明白了：父类 Throwable 有两个子类，一个是 Error （错误），另一个才是 Exception （异常）。也就是说，异常体系说的不光是异常，还把他爸和他哥一起介绍了，一家包圆了。</p>
<p>光从词语的表达上就能感受到，Error 和 Exception 的严重程度是不同的，Error （错误）是非常严重的事情，而 Exception （异常）是可以商量的事情。</p>
<ul>
<li>Error ：错误，指的是程序中很严重的问题，严重到 Java 虚拟机都无法处理，只能停止程序改bug。</li>
<li>Exception ：异常，指的是程序中的轻度问题，程序运行时遇到了之后，处理一下还可以继续执行下去（当然了，一定要处理，不能随便放任不管）。</li>
</ul>
<p>上面那张图只是一张表示 Error 和 Exception 之间关系的图，实际上的异常体系还是比较庞大的，我找到了一张稍微全一些的体系图（<a href="https://juejin.im/post/5c863f48e51d45192c4a701f" target="_blank" rel="noopener">图片来源</a>）。</p>
<p><img src="/assets/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.jpg" alt="异常体系"></p>
<p>现在你要注意到，上图中的所有东西，比如 <code>Error</code> ，比如 <code>Exception</code> ，比如 <code>Exception</code> 里的 <code>NullPointerException</code> ，不论是错误也好异常也罢，以上的所有东西，统统都是类。Java 作为一门面向对象的语言，已经连错误、异常这些东西，都封装起来看作是一种类了。上图中的所有东西都是类，都有继承关系，都有方法，都是当做一个个的封装起来的对象来处理的。</p>
<h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>Error （错误）不是这周学习的重点，事实上其内容需要好几年 Java 实战的积累才能逐渐掌握，因为里面涉及到的具体情况都是偏硬件、偏底层的东西，比如 <code>OutOfMemoryError</code> （内存溢出错误类）。</p>
<p>我们目前只需要知道，Java 虚拟机并不会处理 Error 类，也就是说编译器不会检查 Error 类，我们在做程序设计的时候，也不应该去尝试捕获 Error 类。</p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>Exception （异常）是这周关注的重点。</p>
<p>Exception 有许许多多的子类，其中一类 <code>RuntimeException</code> 即<code>运行时异常</code>，这个子类和其他子类有所不同，怎么不同的一会再说。总之 Exception 可以分成两类，一类叫做<code>运行时异常</code>，另一类叫做<code>非运行时异常</code>。</p>
<p>怎么不同的呢？</p>
<ul>
<li><code>RuntimeException</code> 运行时异常，就是程序真的运行起来了，才能发现的异常。</li>
<li>非运行时异常，意思是说，程序即使不运行，编译器都知道将会有异常发生。也就是说，你不处理这个异常，你就别想让程序运行起来。</li>
</ul>
<p>这两类异常的主要区别在于，一种程序可以先运行起来（遇到了再报错），一种程序上来就无法运行（不用遇到了，直接报错）。</p>
<p>再换句话说，一种可以通过编译器的检查，一种无法通过编译器的检查。</p>
<p>如果从编译器检查的角度来看这两类异常，那么运行时异常（ RuntimeException ），因为可以逃避编译器的检查，因此可以被称为非检查性异常；而其他异常（也就是非运行时异常）逃不过编译器的检查，因此可以被称为检查性异常。</p>
<p>所以异常可以换一种分类方式：<code>检查性异常</code>、<code>非检查性异常</code>。这一种分类方式是更被普遍提到的，虽然它所指的其实就是运行时和非运行时，只是看待的角度不同。（现在建议你再去看一看上面的图，再理解一下分类）</p>
<ol>
<li><p>非检查性异常/运行时异常</p>
<p>属于这一类的异常中，较为常见的有：</p>
<ul>
<li><code>NullPointerException</code> 空指针异常</li>
<li><code>ArithmeticException</code> 算术异常（比如 5 除以 0 ）</li>
<li><code>ClassCastException</code>  类型转换异常</li>
<li><code>IndexOutOfBoundsException</code> 数组越界异常</li>
<li><code>ArrayStoreException</code> 数据存储异常（数组存储时数据类型不一致）</li>
</ul>
</li>
<li><p>检查性异常/非运行时异常</p>
<p>属于这一类异常中，较为常见的有：</p>
<ul>
<li><code>IOException</code> 输入输出异常</li>
<li><code>FileNotFoundException</code> 文件不存在异常（继承自 <code>IOException</code> ）</li>
<li><code>SQLException</code> SQL 语句异常</li>
<li><code>InterruptedException</code> 中断异常</li>
</ul>
</li>
</ol>
<hr>
<p>现在来学习，如果遇到了异常（ Exception ），怎么处理异常。</p>
<p>准确的说应该是，我怀疑某个地方要出现异常，我怎么提前处理这个地方，让它在程序运行之后真的遇到了异常时，仍然能在处理之后继续运行程序。</p>
<p>要注意的是，检查性异常是一定要进行处理的，不处理程序都无法运行（因为编译器直接报错），而非检查性异常和没有异常的地方（比如合理怀疑某段代码有问题），也是可以进行异常处理的。异常处理并不是只针对于异常的，而是在一切场景之下，只要我怀疑存在异常，都可以去做异常处理（大不了没碰上呗）。</p>
<p>Java 有两种异常处理方案，分别是<code>就地解决</code>（ try / catch / finally 语句）和<code>异地正法</code>（ throws ）。</p>
<h1 id="就地解决"><a href="#就地解决" class="headerlink" title="就地解决"></a>就地解决</h1><p>现在我遇到一段可能存在异常的代码，打算当场解决掉它。</p>
<p>下面这几行代码就是就地解决异常的处理方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能存在异常</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 如果遇到了异常，那就执行这段代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不论有没有遇到异常，都执行这段代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有三个关键字：</p>
<ul>
<li><code>try</code> 大括号里放【可能存在异常的代码】，表示“这段代码可能有异常，我们来试试看”。</li>
<li><code>catch</code> 小括号里放【异常的类型】，大括号里放【处理异常的代码】，表示“我发现了XX异常，我要这么去处理它”。</li>
<li><code>finally</code> 大括号里放【不论如何都会执行的代码】，表示“我管你遇不遇得到异常，全都给我执行这段代码”。</li>
</ul>
<p>还是举一个具体的例子吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"发现了算术异常"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"不论如何，都给我执行这段代码"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会在控制台上打印两句话：</span></span><br><span class="line"><span class="comment">// 发现了算术异常</span></span><br><span class="line"><span class="comment">// 不论如何，都给我执行这段代码</span></span><br></pre></td></tr></table></figure>

<ol>
<li>程序进入 <code>try{}</code> 语句块中，执行了 <code>int number = 1/0;</code> 这行代码，因为 0 不能作为被除数，所以出现了异常。</li>
<li>通过 <code>catch(){}</code> 语句块捕捉到了 <code>ArithmeticException</code> （算术异常），你应该注意到了，小括号里放的就是这一异常的类型，如果放的是别的异常的话，那么会捕捉不到的。大括号里表示，捕捉到这一异常之后，要执行的操作，在这里是在控制台打印了一句话：“发现了算术异常”。</li>
<li><code>finally{}</code> 语句块是程序无论如何都会执行的部分，即使是没有异常也会执行。在这里发生了算数异常，打印了一句话：“不论如何，都给我执行这段代码”。其实如果没有发生异常的话，也会把这句话打印出来的。</li>
</ol>
<h1 id="异地正法"><a href="#异地正法" class="headerlink" title="异地正法"></a>异地正法</h1><p>有时我们并不想在异常出现的地方就去处理它，那么可以把异常<code>抛出去</code>。</p>
<p>抛出去（throw）又是一个翻译过来的词，在英文环境中这个词很生动，但是在汉语环境中就并不如此。我们经常听到<code>抛异常</code>这三个字，意思就是把异常给“抛”出去，不立即处理，而是在其他地方去处理。</p>
<p>比如现在有<code>方法 A</code>，<code>方法 A</code> 调用了<code>方法 B</code> ，<code>方法 B</code> 的内部出现了异常，现在就有两种解决方案：</p>
<ol>
<li><code>方法 B</code> 自己处理异常，也就是刚才说的“就地正法”。</li>
<li><code>方法 B</code> 不去解决，而是“抛”给<code>方法 A</code> 去解决。</li>
</ol>
<p>为什么不当场解决，而是抛出去让其他地方去解决，原因可能有很多，比如另一个地方拿到异常对象能做更多事情，比如程序员懒想拖到其他地方再说，等等。</p>
<p><code>抛异常</code>的动作很简单，只需要在方法名的后面（注意，不是在异常发生的原地，而是在异常发生所在的方法，那个方法的名字的位置处），加上 <code>throws XXXException</code> 就可以了。</p>
<p>举个栗子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个只有两行代码的方法（方法名叫 <code>test</code>），第一行是让 <code>number = 1/0</code> （很明显出现了算术异常），第二行返回 <code>number</code> 。我并没有在异常出现的原地去处理，而是在方法名的后面，加上了 <code>throws ArithmeticException</code> ，表示抛出去了一个算术异常。之后哪里调用了这个方法，就必须去处理这个异常（或者继续抛出去）。</p>
<p>你注意，这里说的抛异常，是我们遇到了异常之后，把遇到的这个异常抛出去，而且是在方法名旁边去抛的，意思是说“每当你调用这个方法的时候，都要注意，这个方法里面有个异常要处理”。但是还有一种抛异常的方法，就是可以在随便一个地方，手动地抛出去一个异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br></pre></td></tr></table></figure>

<p>比如这个样子，我手动地把一个新实例化出来的算术异常抛出去了。</p>
<p>在方法名旁边写的那个，是 <code>throws</code> ，而手动在随便一个地方抛出去的，是 <code>throw</code> 。</p>
<hr>
<p>剩下的部分太过零碎，我就分条写，写到哪里算哪里好了。</p>
<h1 id="1-finally-语句块"><a href="#1-finally-语句块" class="headerlink" title="1.finally 语句块"></a>1.<code>finally</code> 语句块</h1><p>在捕获异常当场解决的地方，我们使用了 try / catch / finally 语句，其中 <code>finally{}</code> 语句块是“无论如何都会执行的代码”。</p>
<p>这里的无论如何，真的就是无论如何，它保证了程序一定会执行这部分代码，不管发不发生异常都会执行，而且不管 <code>try{}</code> 语句块中写了什么，也都会执行。</p>
<p>注意：即使是 <code>try{}</code> 语句块中写了返回语句 <code>return xxx;</code> ，你感觉程序走到这里就停止了，其实并不是，这样也都会去执行 <code>finally{}</code> 语句块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"finally 语句块执行了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会在控制台上打印两行：</span></span><br><span class="line"><span class="comment">// finally 语句块执行了</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>通过反编译可以发现，Java 在处理 <code>finally{}</code> 语句块时，是把它复制成两份，分别在 <code>try{}</code> 语句块和 <code>catch{}</code> 语句块后面去执行一次的。</p>
<p>而且如果 <code>finally{}</code> 语句块中写了返回语句 <code>return xxx;</code> ，将会执行这个返回语句，程序到此结束。</p>
<h1 id="2-异常链"><a href="#2-异常链" class="headerlink" title="2.异常链"></a>2.异常链</h1><p>维基百科对于异常链的解释真是太令人舒服了，一眼看懂：</p>
<blockquote>
<p>异常链是一种面向对象编程技术，指将捕获的异常包装进一个新的异常中并重新抛出的异常处理方式。原异常被保存为新异常的一个属性（比如cause）。这个想法是指一个方法应该抛出定义在相同的抽象层次上的异常，但不会丢弃更低层次的信息。</p>
</blockquote>
<p>还是举一个例子吧：</p>
<p><code>main</code> 方法调用 <code>test1</code> 方法，<code>test1</code> 方法调用 <code>test2</code> 方法。</p>
<p>其中 <code>test2</code> 方法中抛一个异常， <code>test1</code> 方法会接到 <code>test2</code> 方法抛出的异常，包裹起来再抛一个新的异常。</p>
<p>这样 <code>main</code> 方法中就会出现一个异常，这个异常里面还有一个异常（也就是接到一个包裹着异常的异常）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 test1 方法</span></span><br><span class="line">        <span class="keyword">int</span> num = test1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 test2 方法，抛一个新的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num = test2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"这里是test1的异常"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test2 方法中抛一个异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"这里是test2的异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台的打印信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Exception: 这里是test2的异常</span><br><span class="line">	at testCode.Test.test2(Test.java:<span class="number">21</span>)</span><br><span class="line">	at testCode.Test.test1(Test.java:<span class="number">12</span>)</span><br><span class="line">	at testCode.Test.main(Test.java:<span class="number">6</span>)</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException: 这里是test1的异常</span><br><span class="line">	at testCode.Test.test1(Test.java:<span class="number">15</span>)</span><br><span class="line">	at testCode.Test.main(Test.java:<span class="number">6</span>)</span><br><span class="line">Caused by: java.lang.Exception: 这里是test2的异常</span><br><span class="line">	at testCode.Test.test2(Test.java:<span class="number">21</span>)</span><br><span class="line">	at testCode.Test.test1(Test.java:<span class="number">12</span>)</span><br><span class="line">	... <span class="number">1</span> more</span><br></pre></td></tr></table></figure>

<p>这里就看到了异常链。</p>
<h1 id="3-一个catch子句捕获多个异常"><a href="#3-一个catch子句捕获多个异常" class="headerlink" title="3.一个catch子句捕获多个异常"></a>3.一个catch子句捕获多个异常</h1><p><code>JDK1.7</code> 改进了 catch 子句的语法，允许在其中指定多种异常，每个异常类型之间使用“|”来分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//..............</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExceptionA | ExceptionB ab) &#123; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExceptionC c) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-异常抑制"><a href="#4-异常抑制" class="headerlink" title="4.异常抑制"></a>4.异常抑制</h1><p><code>JDK1.7</code> 中为 <code>Throwable类</code> 增加 <code>addSuppressed方法</code>和 <code>getSuppressed方法</code>。</p>
<p>当一个异常被抛出的时候，可能有其他异常因为该异常而被抑制住，从而无法正常抛出。这时可以通过 <code>addSuppressed方法</code> 把这些被抑制的方法记录下来，被抑制的异常会出现在抛出的异常的堆栈信息中，可以通过 <code>getSuppressed方法</code> 获取到被抑制的异常。</p>
<p>个人觉得没啥用，懒得写了。</p>
<h1 id="5-try-with-resources"><a href="#5-try-with-resources" class="headerlink" title="5. try - with - resources"></a>5. try - with - resources</h1><p>同样还是 <code>JDK1.7</code> 增加的新特性。</p>
<p>以前使用 <code>try / catch / finally</code> 语句块处理资源的时候，如果要关闭资源，需要在 <code>finally{}</code> 语句块中关闭，使用 <code>try - with - resources</code> 方式可以在 <code>try()</code> 的小括号里声明，Java 会自动关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(inputString);</span><br><span class="line"><span class="keyword">try</span> (BufferedReader br1 = br) &#123;</span><br><span class="line">    <span class="keyword">return</span> br1.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JDK1.9</code> 更进一步， <code>try()</code> 的小括号里不需要声明了，声明过程在外面也可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(inputString);</span><br><span class="line"><span class="keyword">try</span> (br) &#123;</span><br><span class="line">    <span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 后面小括号内的东西即为 resources ，resources 必须是实现 <code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 接口的类（需要手动 close() 释放资源的）。</p>
<h1 id="6-IDEA-的快捷操作"><a href="#6-IDEA-的快捷操作" class="headerlink" title="6.IDEA 的快捷操作"></a>6.IDEA 的快捷操作</h1><p>要是使用的Java开发工具是 IDEA 的话，那么如果想对某一句代码进行异常处理，可以在这句代码写完之后，敲上“ <code>.try</code> “这四个字符，再敲回车，就可以自动为这行代码加上 try / catch 语句了。</p>
<p>例如这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>/<span class="number">0</span>;.<span class="keyword">try</span></span><br></pre></td></tr></table></figure>

<p>写完之后敲击回车，自动变成如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2020/07/04/ThreadLocal/</url>
    <content><![CDATA[<br>

<p>七月的第一周，来学习 ThreadLocal。</p>
<p>半年前我完全看不懂这个类，现在已经能看懂了。这几天刚开始看源码时，觉得这是个很精巧的小设计，后来又找资料，发现里面的知识很深，没我想的那么简单。</p>
<p>我在学习 ThreadLocal 时，看到两个很好视频，安利一下。一个是《<a href="https://www.bilibili.com/video/av82079309" target="_blank" rel="noopener">【java】什么是<em>ThreadLocal</em>？</a>》（短小紧凑，科普向，但是结尾有关弱引用的结论是错的，瑕不掩瑜，记得看评论区），另一个是《<a href="https://www.bilibili.com/video/av327891068" target="_blank" rel="noopener">只有马士兵老师能把ThreadLocal底层原理、内存泄漏分析的这么测透</a>》（马士兵老师讲的，比较长，但是非常出色，看得我很 high）。</p>
<hr>
<p>ThreadLocal 类与<code>线程局部存储</code>（Thread Local Storage, TLS）的概念有关，意思是说对象是线程独有的：</p>
<blockquote>
<p>维基：对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。</p>
</blockquote>
<p>可以把 ThreadLocal 视为一个普通变量，他与普通的变量之间的区别在于，ThreadLocal 变量只属于某个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String word1;</span><br><span class="line">ThreadLocal&lt;String&gt; word2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">word1 = <span class="string">"pz"</span>;</span><br><span class="line">word2.set(<span class="string">"pz"</span>);</span><br></pre></td></tr></table></figure>

<p>例如上面的代码，声明了两个变量 word1 和 word2。这两个变量在使用时都是字符串，也都声明成是”pz”，但是前者 word1 在任何情况下都能获得，后者只有为它赋值的线程能获得，其他的线程都不能获得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于刚才赋值的线程而言，s是"pz"，对于其他线程，s是null</span></span><br><span class="line">String s = word2.get();</span><br></pre></td></tr></table></figure>

<p>线程局部存储，可以让某些信息在同一个线程中，实现上下文数据共享，比如一个线程先后执行多个方法，每个方法都需要 User 信息，那么可以定义一个 <code>ThreadLocal&lt;User&gt;</code>，每个线程都能获取到各自的 User。</p>
<p>再举一个应对面试的 Spring 应用实例，在事务管理时（@Transactional），Spring 会把数据库连接或者 hibernate session 存储在 ThreadLocal 中，这样就可以在各个方法查询各张表时实现事务控制。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>ThreadLocal 的实现原理，是让每个线程自己维护一张 map，key 是 threadLocal 对象，value 是实际想存储的内容。</p>
<p>每个线程拿着 ThreadLocal 对象，把它作为 key，去自己独有的 map 里找到 key 对应的 value，由此实现了线程局部存储。</p>
<p><img src="/assets/ThreadLocal.jpg" alt="ThreadLocal"></p>
<p>直接来看 get() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据当前线程，获取map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果map不为空，去map里面找</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据this（也就是本ThreadLocal对象），去map里面找到对应的entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果map为空，初始化map，并返回null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本逻辑很简单，获取当前线程，根据当前线程获取 map，在 map 里根据 ThreadLocal 对象找 entry，返回 entry 的 value。</p>
<p>在这个主要流程里，我们还需要去扒：</p>
<ol>
<li>怎么根据当前线程获取 map</li>
<li>怎么在 map 里根据 ThreadLocal 找到 entry</li>
</ol>
<p>第一个问题特别简单，map 就是 Thread 的一个成员变量，直接返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再去看Thread类的源码，可以看到有一条成员变量：</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>第二个问题有点难，涉及到 map 的数据结构。</p>
<p>先提一下 map 具体是什么，这里的 map 实际上就是一个数组（没有链表），这个数组里的每一个元素都是一个 Entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个table就是map背后的数组：存放entry的数组</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这就是数组中一个个的元素</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry 涉及到弱引用，这个后面再提，先看怎么从 map 中找到 entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据ThreadLocal对象（即key）计算出数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果数组下标内存的key能对上，那么就是</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="comment">// 如果key对不上，线性探测往后找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整体上讲，这个 map 采用开放定址法，而不是拉链法，来解决哈希碰撞问题。</p>
<p>这种算法的大致原理是，计算出哈希值，然后存入数组里相应的位置，如果这个位置已经存在元素了（哈希碰撞），那么查看下一个数组格子是否是空的，一直找，直到找到一个空的位置，然后存进去。取的时候也是一样，先计算出哈希值，然后找相应数组下标内的元素，如果 key 对上了就是，如果对不上，找下一个。</p>
<p>关于使用开放定址法，存在两个疑问：为什么要使用它，而不是使用像 HashMap 一样的拉链法？使用这种需要优化什么？</p>
<p>第一个问题涉及到弱引用，这个后面再提。</p>
<p>第二个问题其实是在思考开放定址法的问题：如果每次计算出来的数组下标，距离靠得很近，那如果发生哈希碰撞，这个不对，找下一个，还不对，再找下一个，岂不是要找死？所以要让计算出来的数组下标，要分布尽可能地均匀。</p>
<h1 id="特殊的-hash-算法"><a href="#特殊的-hash-算法" class="headerlink" title="特殊的 hash 算法"></a>特殊的 hash 算法</h1><p>ThreadLocal 计算数组，是通过内部的一个数字计算的，这个数字很奇特，每个 ThreadLocal 的数字都不一样，但是它们都是一个公共数字 <code>HASH_INCREMENT</code> 的整数倍（会溢出，但是无所谓）。在程序启动之后，出现的第一个 ThreadLocal 对象内部的数字是 <code>HASH_INCREMENT</code>  的一倍，第二个 ThreadLocal 对象内部的数字是 <code>HASH_INCREMENT</code>  的两倍，以此类推，第 n 个 ThreadLocal 对象内部的数字是 <code>HASH_INCREMENT</code>  的 n 倍。</p>
<p>每个 ThreadLocal 对象内部的那个数字是 <code>threadLocalHashCode</code>（见名知意，就是 hash 值），而以 <code>HASH_INCREMENT</code> 为基的这个数字，大小初看很奇怪：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure>

<p>这个数字用十进制表示是 1640531527，它是 2^32 的黄金分割数，也就是 (2^32)/0.618。使用这个数字的整数倍，能计算得出很均匀的 map 下标（前提 map 的长度是 2 的幂）。具体的计算步骤是，获取 ThreadLocal 内部的那个数字（<code>threadLocalHashCode</code>），然后对 map 的长度 -1 取模，计算出一个不超过 map 长度的数字，这个数字就是数组的下标。</p>
<p>举个例子，0 - 31 这 32 个数字分别与 <code>0x61c88647</code> 相乘，然后再对 31 （0b11111）取模，依旧能获得 32 个不同的数字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    System.out.print((i * HASH_INCREMENT &amp; <span class="number">0b11111</span>) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台打印结果：0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25</span></span><br></pre></td></tr></table></figure>

<p>当数组长度是 2 的幂时，都可以做到如此均匀，虽然我不知道为什么（试着找了一些文章，但是看不懂hhh），但是觉得好牛x啊。</p>
<p>下图来源自文章<a href="https://web.archive.org/web/20161121124236/http://brpreiss.com/books/opus4/html/page214.html" target="_blank" rel="noopener">《Fibonacci Hashing》</a>，感受一下分布均匀度。</p>
<p><img src="/assets/image-20200704140058476.png" alt="连续分布"></p>
<p>有关 ThreadLocal 的 hash 算法就写到这里，然后我们来看 map 中的每一个元素：Entry。</p>
<h1 id="Entry-与弱引用"><a href="#Entry-与弱引用" class="headerlink" title="Entry 与弱引用"></a>Entry 与弱引用</h1><p>这是 Entry 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实际上就是 key-value 键值对，跟其他任何 map 里的设计都是一样的，有 key，也有 value。</p>
<p>它的 key，是 ThreadLocal 对象（尽管看源码有点懵），它的 value，就是线程局部存储的值，例如下面这两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">threadLocal.set(<span class="string">"pz"</span>);</span><br></pre></td></tr></table></figure>

<p>执行 set 方法的那个线程，它内部的 map 里的某一个格子，就是一个 Entry，这个 Entry 的 key 就是 threadlocal 对象，它的 value 是 “pz”。</p>
<p>Entry 源码里面看到了 value，但是没有看到 key，key 是通过 WeakReference（弱引用）来实现的。</p>
<p>弱引用是 JDK 1.2 出现的，这个概念跟 Java 虚拟机有关。弱引用是引用的一种，引用总共有四种，，我简单列一下：</p>
<ul>
<li>强引用（Strong Reference）：正常引用，根据垃圾回收算法，当这个引用存在时，就无法对引用对象进行 GC（如果根可达的话）</li>
<li>软引用（Soft Reference）：能够获取到引用对象，当发生 FGC 时，会回收引用对象，应用在缓存等。</li>
<li>弱引用（Weak Reference）：能够获取到引用对象，当发生 GC 时，会回收引用对象，应用在 ThreadLocal 等。</li>
<li>虚引用（Phantom Reference）：不能获取到引用对象，作用是当引用对象被 GC 时，虚引用会获得一个系统通知，应用场景跟一般的代码无关。</li>
</ul>
<p>上面写的引用，我只是简单一写，想理解的话去看《深入理解 Java 虚拟机》讲垃圾回收的部分，或是最开始提到的马士兵老师的视频，都讲得很好。</p>
<p>话说回来，继续看弱引用，看下面这两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;String&gt; r = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="string">"pz"</span>);</span><br><span class="line">r.get();</span><br></pre></td></tr></table></figure>

<p>上面创建了一个弱引用 WeakReference 对象 r，它引用到了一个字符串 “pz”，如果没有发生垃圾回收，那么可以通过 <code>r.get()</code> 方法获取到 “pz”，但如果发生了垃圾回收，这个虚引用并不会影响到字符串 “pz” 的回收，如果它真被回收了，那么执行 <code>r.get()</code> 方法将会获得 null。</p>
<p>因此再回去看 Entry 源码，发现 Entry 继承自 WeakReference，它可以通过虚引用获取到 ThreadLocal 对象，比如创建一个 Entry 对象（当然由于 private，下面的代码是实现不了的hh）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry entry = <span class="keyword">new</span> Entry(threadLocal, <span class="string">"pz"</span>);</span><br><span class="line">entry.get(); <span class="comment">// ---&gt; 能拿到threadLocal，即key</span></span><br><span class="line">entry.value; <span class="comment">// ---&gt; 能拿到"pz"，即value</span></span><br></pre></td></tr></table></figure>

<p>如此可以看出，Entry 实际上就是 key-value 键值对，从 hash 开放定址法上来说，应该是没问题了，逻辑闭环了，但是有另一个问题：为什么要使用弱引用？</p>
<p>这主要与垃圾回收有关：如果 Entry 通过正常的引用关联 ThreadLocal 对象，那么如果线程不死，map 不清，由于强引用关系，ThreadLocal 对象就永远也不能被垃圾回收，这样即使某些 ThreadLocal 用不上了，它仍然不会被清理掉，造成内存泄漏。</p>
<p>（这里我还是有点疑惑，真的有这种内存泄漏的场景吗）</p>
<br>

<p>本来还想学点数据库事务的 ThreadLocal 原理的，但是写了这么多字懒了，告辞。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>java IO</title>
    <url>/2019/08/15/javaIO/</url>
    <content><![CDATA[<br>

<p>八月的第三周，来学习java IO系统。</p>
<p>IO是Input（输入）和Output（输出）的简称，合在一起就是<code>输入输出</code>。我们这里说的输入输出，都是相对于java程序而言的，我把硬盘中的文件读到java程序里，这是输入；我把java程序中的图片上传到博客里，这是输出。了解输入输出的第一件事，就是搞清楚<font color="#32CD32"><strong>入</strong></font>和<font color="#32CD32"><strong>出</strong></font>的方向是什么。</p>
<p>IO系统是一个超级庞大的系统，不论是方法（函数）还是设计模式，光从数量上就令人望而生畏。这周尽量多学，学到哪里算哪里吧。</p>
<hr>
<p>任何有关java IO的学习，永远是从5个基础的类开始的。</p>
<p><img src="/assets/IO%E5%9F%BA%E7%A1%80%E7%B1%BB.PNG" alt="IO基础类"></p>
<p>其中最为基础的是前三个：File类、InputStream类、OutputStream类，它们分别代表着<code>文件</code>、<code>输入</code>、<code>输出</code>。</p>
<p>举一个简单的例子：我把<code>文件</code>读取到java程序中，这里就是在<code>输入</code>，而我保存数据到<code>文件</code>中去，这里就是在<code>输出</code>。</p>
<p>下面两个类：Reader类、Writer类，同样是输入和输出，区别在于这两个传输的单位是字符，而前面那两个，传输的是字节。</p>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>File者，文件也。</p>
<p>但是File类实际上可以表示两方面：文件、文件夹（目录）。</p>
<p>File类是一个盘古开天辟地时的类，从JDK1.0就存在了。最常见的实例化方式是把<code>文件路径</code>输入进去，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src/test.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>路径就是文件在计算机中的位置，有绝对路径和相对路径之分，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绝对路径：<span class="string">"C:/JavaProgram/javaIO/src/test.txt"</span></span><br><span class="line">相对路径：                      <span class="string">"src/test.txt</span></span><br></pre></td></tr></table></figure>

<p><font color="#32CD32">相对</font>的意思就是，已经默认在某一个文件夹中了，前面那些路径就不用写了。</p>
<p>小总结一下：写清楚路径，通过路径拿到一个文件。</p>
<p>我认为对File类认识到这个地步就足够了。</p>
<h1 id="InputStream类、OutputStream类"><a href="#InputStream类、OutputStream类" class="headerlink" title="InputStream类、OutputStream类"></a>InputStream类、OutputStream类</h1><p>InputStream类、OutputStream类，这两个类是输入类和输出类，in是输入，out是输出，很明显。</p>
<p>这两个类也是盘古开天辟地时候的类，在JDK1.0就存在了。</p>
<p>（刚才忘了说，JDK是java开发的工具包，JDK1.0就是第一代开发工具包的意思，现在主流的开发包处在第7、8代，最新的已经到第12代了。）</p>
<p>我认为要了解清楚这两个类，需要搞清楚三件事情。</p>
<h2 id="1-传输的是什么东西？"><a href="#1-传输的是什么东西？" class="headerlink" title="1. 传输的是什么东西？"></a>1. 传输的是什么东西？</h2><p>上古类就该有上古类的样子，这两个类在输入输出时，传输的东西那都是最最最基本的单位：字节（就是1010……那串数字）。</p>
<p>因此InputStream的名字其实不是<code>输入</code>，而是<code>字节输入流</code>，OutputStream也不是<code>输出</code>，而是<code>字节输出流</code>。</p>
<h2 id="2-流是什么？"><a href="#2-流是什么？" class="headerlink" title="2. 流是什么？"></a>2. 流是什么？</h2><p>流（stream），这个概念基本就是java IO系统的核心了。</p>
<p>InputStream就是Input流，OutputStream就是Output流，想搞清楚这两个类是怎么工作的，最重要的就是理解“流”是什么。</p>
<p>我认为，“流”是一条中介管道，是连通java程序与外部存储的管道。它根本就没有流动，它是静态的，是装载着数据的一条中介管道。</p>
<p><img src="/assets/%E6%B5%81.png" alt="流"></p>
<p>如图，我要把数据，从<code>java程序</code>传输到<code>存储硬盘</code>中，中途就会经过一条漫长的<code>管道</code>。这条管道有一个一个的小格子，每一个格子里面都放着一字节的数据。这整条管道，就叫做流。如果是一条输出管道，那就是输出流，如果是一条输入管道，那就是输入流。</p>
<p>我觉得“流”这个名字很具有迷惑性，让人感觉好像是数据在流动一样，但是我看了几天之后觉得并没有，这就是一条静态的、被分隔为很多很多小格子的，管道，每一个格子里面装着一字节的数据。（但是底层应该不是这么实现的，我是做等效看待了）</p>
<ul>
<li>如果是输入流，那么把文件扔进管道，管道自动地将文件中的数据，按顺序一字节一字节地填充到管道的一个个小格子当中，每一格都是一字节的数据。数据并不会自动流过去，而是java程序自己顺着格子，拿走自己想要的数据。</li>
<li>如果是输出流，那么把java程序数据扔进管道，管道自动地将想要输出出去的数据，按顺序一字节一字节地填充到管道的一个个小格子当中，每一格都是一字节的数据。同样，数据也不会自动流到硬盘当中，而是有专门的函数，把这些数据顺着格子拷贝到硬盘里。</li>
</ul>
<p>说了这么多虚的，该看看具体的代码了。</p>
<h2 id="3-这两个类怎么用？"><a href="#3-这两个类怎么用？" class="headerlink" title="3.  这两个类怎么用？"></a>3.  这两个类怎么用？</h2><p>我们用InputStream类入手，看一个简单的例子。</p>
<p>我现在写入两行代码，将文件放进输入流当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src/test.txt"</span>);</span><br><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure>

<p>这两行代码，可以理解为干了这么件事：</p>
<p>现在有一个txt文件，里面就写了一句英文，“Hello,pz.”，然后把这个文件扔进输入流中，输入流作为一条管道，分出了9个格子，每个格子放进去一个字母或是标点符号，就像是下面这张图一样。</p>
<p><img src="/assets/1566051405465.png" alt="1566051405465"></p>
<p>（数据是以010101……这种二进制数来表示的，比如字母H的二进制表示是01001000，转换成十进制后就是72，也就是上图管道中的第一个格子）</p>
<p>现在流已经存在了，要开始读取数据了。</p>
<p>InputStream类有一个方法read()，专门用来读取数据。但是由于java多态的特性，这一个read方法有三种使用方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inputStream.read();</span><br><span class="line">inputStream.read(<span class="keyword">byte</span>[] b);</span><br><span class="line">inputStream.read(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>空参read()方法：</p>
<p>每次读一个格子的数据（读取一字节），并且返回这个数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">i = inputStream.read();</span><br></pre></td></tr></table></figure>

<p>以上面两行代码为例，我首先声明了<code>i</code>是一个整型数，然后去读取输入流的read()方法，第一次会读到72（字母H），然后如果你再执行一遍read()方法，就能读到下一个格子里的101（字母e），再执行一遍read()方法，就能读到108（字母l）……一直读到最后一个格子里的46（标点符号.），再读的话就没有东西了，就会返回-1。</p>
<p>通过空参read()方法，能够每次读取一字节的数据，当读完时会返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次读取一个字节，然后在控制台打印出来这个字节，直到读空为止</span></span><br><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((i = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">	System.out.print((<span class="keyword">char</span>) i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数是一个数组的read()方法：</p>
<p>每次读取数组长度的数据，返回读取的长度，同时把数据存放在数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">i = inputStream.read(b);</span><br></pre></td></tr></table></figure>

<p>请注意，这里非常有迷惑性。</p>
<p>我们刚才使用的read()方法，用<code>i</code>去读取，<code>i</code>里面直接存放数据。</p>
<p>但是，我们现在把一个数组当做参数，扔进read()方法里，还是用<code>i</code>去读取，但是现在<code>i</code>里面存放的，是读取的长度。</p>
<p>比如说上面写的这三行代码，依旧是声明了<code>i</code>是一个整型数，同时声明了<code>b</code>是一个长度为10的字节数组。现在我们去使用read()方法，<code>i</code>的值不再是72（字母H）了，而是9，因为输出流的长度是9（“Hello,pz.”一共九个字节)，我们用一个长度是10的数组去读取它，一口气把这9个字节全读完了。现在数据不装在<code>i</code>里面了，而是直接装在数组<code>b</code>里面。</p>
<p>也就是说，现在<code>i == 9</code>，<code>b == {72, 101, 108, 108, 111, 44, 112, 122, 46, 0}</code>，<code>b</code>这个数组，长度为10，前面9个全都存放着字节数据，最后一位没赋值所以是0。</p>
</li>
<li><p>参数是一个数组、两个整型数的read()方法：</p>
<p>依旧是把数据放在数组里面，但是只用数组的一部分，返回值依旧是读取的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">i = inputStream.read(b, <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>跟第二种read()方法比，现在前两行的声明过程不变，第三行读取的时候，要求从数组<code>b</code>的下标为2（因为第1个数下标是0，下标为2也就是第3个数）的地方开始存放数据，一直放5个数据。</p>
<p>对比一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = inputStream.read(b);        <span class="comment">// b : &#123;72, 101, 108, 108, 111, 44 , 112, 122, 46, 0&#125;</span></span><br><span class="line">i = inputStream.read(b, <span class="number">2</span>, <span class="number">5</span>);	<span class="comment">// b : &#123;0,  0,   72,  101, 108, 108, 111, 0,   0,  0&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>输入流，说完了。</p>
<p>(我知道我说得很烂，但是我不想重写了= =)</p>
<p>那么我们快速过一遍输出流。</p>
<p>OutputStream输出流同样输出的是字节，输出时用到的方法叫做write()，它同样有三种表现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outputStream.write(<span class="keyword">int</span> b);                       <span class="comment">// 一次写入一个字节</span></span><br><span class="line">outputStream.write(<span class="keyword">byte</span>[] b);                    <span class="comment">// 一次写入一个数组的字节</span></span><br><span class="line">outputStream.write(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);  <span class="comment">// 一次写入数组中从off位置开始的len个字节</span></span><br></pre></td></tr></table></figure>

<p>使用起来和输入流没什么区别，只不过一个是读取，一个是写入。</p>
<h1 id="Reader类、Writer类"><a href="#Reader类、Writer类" class="headerlink" title="Reader类、Writer类"></a>Reader类、Writer类</h1><p>Reader类、Writer类，这两个类也是输入和输出类，read读，是输入，write写，是输出，也很明显。</p>
<p>这两个类不是盘古开天辟地时期的类，而是女娲造人时候的类，因为它们两个是JDK1.1出现的。</p>
<p>跟InputStream类、OutputStream类相比，区别在于，前面两个是输入输出字节，这两个是输入输出字符。</p>
<br>

<p>我们来谈一下字节和字符。</p>
<p>我认为可以这么理解，字节是计算机认识的文字，字符是人类认识的文字。比如计算机一看01001000这八个二进制数字，就知道这是一个字节，而我们人类一看到H，就知道这是一个字母（也就是一个字符）。</p>
<p>字节和字符之间，是存在着对应关系的（术语叫做映射），一个字符就应该对应着一个（或几个）字节，比如字符H，对应的就是01001000这8个二进制数所组成的一个字节。这种对应关系我们叫编码和解码，其实就是“翻译翻译”，<code>字节 → 字符 ：解码</code>，<code>字符 → 字节 ：编码</code>，也就是<code>人话</code>和<code>机话</code>互相翻译，要不然人类说一个字母H，计算机怎么存下来呢？</p>
<p>一个字节有8个二进制位，你算一算，2的8次方也就256，也就是说一个字节最多也就只有256种不同的情况，字符有数十万个，对应不过来啦，所以一个字符一般是对应两三个字节。（如果是英文，那一个字节256种情况倒也是够用了）</p>
<p>有许多不同标准的字符集，比如中国字字符集、英文字符集、欧洲字符集等等，我把相关信息列在表格中：</p>
<table>
<thead>
<tr>
<th>编码类型</th>
<th>解释</th>
<th>1个字符占几个字节</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>最基础的字符集，有字母和符号等</td>
<td>1</td>
</tr>
<tr>
<td>GBK</td>
<td>中国字字符集（GB就是国标）</td>
<td>中文字符占 2 个字节，英文字符占 1 个字节</td>
</tr>
<tr>
<td>ISO-8859-1</td>
<td>大部分的欧美字符</td>
<td>1</td>
</tr>
<tr>
<td>UTF-8</td>
<td>Unicode编码的一种<br>最为常用，比如字符串转byte[]时就是</td>
<td>变长编码，1-6个字节都有<br>中文字符占 3 个字节，英文字符占 1 个字节</td>
</tr>
<tr>
<td>UTF-16</td>
<td>Unicode编码的一种<br>有UTF-16be和UTF-16le两种<br>be就是Big Endian（大端）<br>le就是Little Endian（小端）</td>
<td>变长编码（2或4），但是多数是2<br>java内存编码使用UTF-16be编码<br>因为char类型使用UTF-16be编码<br>中文字符和英文字符都占两个字节</td>
</tr>
</tbody></table>
<p>我不打算写太多关于字符与字节的东西，只是简单记录一下。</p>
<br>

<p>好了我们说回输入输出。</p>
<ul>
<li>InputStream：字节输入流</li>
<li>OutputStream：字节输出流</li>
<li>Reader：字符输入流</li>
<li>Writer：字符输出流</li>
</ul>
<p>InputStream类、OutputStream类输入输出的是<code>byte</code>。</p>
<p>Reader类、Writer类输入输出的是<code>char</code>。</p>
<p>就这点区别，没啥别的了。</p>
<p>好吧我们还是惯例看看使用的方法：</p>
<ul>
<li><p>Reader类的read()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reader.read();</span><br><span class="line">reader.read(<span class="keyword">char</span>[] cbuf);</span><br><span class="line">reader.read(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br><span class="line">reader.read(CharBuffer target);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Writer类的write()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writer.write();</span><br><span class="line">writer.write(<span class="keyword">char</span>[] cbuf);</span><br><span class="line">writer.write(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br><span class="line">writer.write(String str);</span><br><span class="line">writer.write(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>好吧，看起来多了几个方法。</p>
<p>但说实话，我觉得本质上没什么区别，无非就是又包装了一下，用起来更顺手一些。流的使用上，是没有区别的。</p>
<p>所以这两个类，我们就不再说了。</p>
<br>

<br>











<p>让我们重看一遍一开始的那张图，这五个最为基础的类，可以再分成三类，一类跟文件打交道，一类跟字节打交道，一类跟字符打交道。</p>
<p><img src="/assets/IO%E5%9F%BA%E7%A1%80%E7%B1%BB%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%89.jpg" alt="IO基础类分类"></p>
<hr>
<p>在表述逻辑无比混乱地写完java IO基础的五个类之后，我们来学习装饰者模式。（啊真的想重写，可是又没力气）</p>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者模式是这样的，我现在有一个类，但是我发现这个类的功能有限，我想给这个类增加几个功能，那么我就在这个类的外面，再套上一层，这么包装完之后呢，这个“被装饰过”的类，不单具有原先的功能，还有了一些新的功能。</p>
<p>装饰者模式的主要动作就是，有了一个类，给它套上一层装饰，变成了一个新的类，这个类增加了功能。</p>
<p>我们拿<code>字节输入流</code>举例子。</p>
<p>我们在使用InputStream类时，java程序是一字节一字节地读取数据的，这一个个读，其实是很慢的。如果java程序能加一层缓存，每一次多读一点数据，就会快一些。</p>
<p>我们现在希望实现的功能是：在原先InputStream类的基础之上，增加一个缓存的功能，因此我们是这么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">BufferedInputStream bs = <span class="keyword">new</span> BufferedInputStream(is);</span><br></pre></td></tr></table></figure>

<p>首先还是先实例化了一个InputStream对象<code>is</code>，接着我们装饰了这个<code>is</code>，让它变成一个BufferedInputStream对象<code>bs</code>（就是一个buffer过的InputStream）。那么现在，我们不再去操作<code>is</code>，而是去操作<code>bs</code>了，<code>bs</code>是一个具有缓存功能的<code>is</code>，是一个更强大的<code>is</code>。</p>
<p>（BufferedInputStream类具体强大在哪里呢？它也没多加什么新方法，它就是运行速度更快，快很多很多，读大文件的时候很明显。）</p>
<p>java IO系统中，装饰者模式比比皆是，全都是拿到一个输入/输出类，然后装饰一下变成一个新的类，去操作这个新的类，去实现更多的功能。</p>
<p>装饰者模式是一种设计模式，它的好处在于，如果我想给某些类实现一个新的功能，可以不通过继承，而是通过一个中间类去装饰一下即可。</p>
<p>比如现在有一个<code>运动类</code>，运动类下面有很多子类：<code>跑步类</code>、<code>打球类</code>、<code>跳绳类</code>……我现在希望每一个运动类的子类，这么多类，都去实现<code>运动完之后拉伸</code>的方法。按照原来的思路，我要把所有子类全部都继承一遍，每一个新继承的类都多加上这么一个<code>运动完之后拉伸</code>的方法，那不是累死了吗。通过装饰者模式，我可以创建一个<code>运动后拉伸类</code>，这个类读取一个运动类，随便哪个子类都可以，在这一装饰之下，就新增了拉伸的方法。这样做动静很小。</p>
<p>java IO系统这么青睐装饰者模式，主要是也是因为，特喵的java的IO相关类，实在是太多了……</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：回溯</title>
    <url>/2020/04/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<br>

<p>四月的第二周，开始学习算法题：回溯算法。</p>
<p>在二月底就零星地看了一些算法题，当时想着从四月份开始突击一个月的算法，但因为看 Java 并发耽误了一周。从本周开始，博文内容将全部是算法。</p>
<hr>
<p>回溯（backtracking）是暴力搜索法中的一种，它采用试错的思想，尝试分布地解决一个问题，在分步解决问题的过程中，当它通过尝试，发现现有的分步答案不能得到有效的正确解答时，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</p>
<p>回溯是基于深度优先遍历（DFS）的一种暴力搜索方法，因此使用回溯算法的前提是，问题本身的数据结构是树，在树的基础上采取 DFS 的方式遍历，在遍历的过程中，保存符合题目条件的叶子节点。</p>
<p>举一个例子，比如全排列问题（给定几个数字，返回所有可能的全排列），这个问题本身就是一棵树，以[1, 2, 3]这三个数字为例，可以画成如下的树。这一类的问题我们可以通过回溯算法解决。</p>
<p><img src="/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg" alt="树示例"></p>
<p>回溯算法的内核是遍历，如果一个问题能够转化为树，就可以通过回溯算法，遍历树的每一片叶子，暴力解决。在这一背景之下，回溯算法还有以下特征：</p>
<ol>
<li>遍历树的方式是递归，因此回溯是通过递归解决的。</li>
<li>遍历树时，收集叶子（收集结果）往往有约束，比如要求结果不能重复（[1, 2]和[2, 1]只保留其中一个），收集时要根据要求收集。</li>
<li>遍历树时，在知道某些分支下一定不可能出现结果，就可以忽略遍历这部分，这被称为“剪枝”，是回溯算法提高性能的主要方式。</li>
</ol>
<br>

<p>下面试着整理一下套路，但是就我个人经验而言，背过了套路也用处不大，多做一点题目就会慢慢熟悉起来。推荐的做题路线是（使用 LeetCode），39 题 -&gt; 46 题 -&gt; 77 题 -&gt; 78 题 -&gt; 40 题 -&gt; 47 题 -&gt; 90 题，都比较简单，是用来培养手感的。</p>
<p><strong>先铭记最重要的一条，做回溯算法题，第一步，先画树，画完了再做题。</strong></p>
<p>回溯算法的主要流程是：试探 - 子递归 - 回溯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doSub(list, ...)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    list.add(item);               <span class="comment">// 试探着加入一个元素</span></span><br><span class="line">    doSub(list, ...);             <span class="comment">// 子递归</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>); <span class="comment">// 把刚才试探加入的元素删掉</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是先加入一个元素，执行子递归操作，再删除掉刚才加的元素。这个套路我们一会在真题中使用。</p>
<p>初学时由于递归使用得少，因此对递归的结构、递归的方法参数，通常会苦恼很久。在初始阶段，可以试着这么写递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最终的结果可以记在全局变量中，不设置返回值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSub</span><span class="params">(List candidates, <span class="keyword">int</span> level, Object tem)</span> </span>&#123;</span><br><span class="line">                           成员         递归层数    本级递归的结果</span><br><span class="line">                               </span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (成功条件，准备记录结果) &#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        doSub(candidates, level + <span class="number">1</span>, tem);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常递归需要三个参数：操作的所有元素、递归的层数（通常用于判断什么时候要终止递归）、本级递归的结果（成功后，将参数记录下来）。这么写可能会有冗余代码（ if 的判断条件），但是按照这种思路来写，通常能写出来递归的骨架，然后再慢慢调整。</p>
<p>除了这三个参数之外，通常递归还需要其他参数，这个需要具体分析。就我做题而言，一般是需要增加两种参数，一会做题时详述。</p>
<br>

<h1 id="LeetCode39-组合总和"><a href="#LeetCode39-组合总和" class="headerlink" title="LeetCode39 组合总和"></a>LeetCode39 组合总和</h1><blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p>
<table>
<thead>
<tr>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td>candidates = [2,3,6,7], target = 7</td>
<td>[<br>&nbsp;&nbsp;[7],<br>&nbsp;&nbsp;[2,2,3]<br>]</td>
</tr>
<tr>
<td>candidates = [2,3,5], target = 8</td>
<td>[<br>&nbsp;&nbsp;[2,2,2,2],<br>&nbsp;&nbsp;[2,3,3],<br>&nbsp;&nbsp;[3,5]<br>]</td>
</tr>
</tbody></table>
</blockquote>
<p>先画树（其实只需要画出终止条件和满足条件就足够分析了）：</p>
<p><img src="/assets/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.jpg" alt="组合总和"></p>
<p>主要的逻辑是递归树</p>
<ul>
<li>如果求和不足，那么继续递归</li>
<li>如果求和正好，那么记录结果，返回（返回后删除，进行下一次循环）</li>
<li>如果求和超了，那么返回（返回后删除，进行下一次循环）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode39</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combinationSum方法返回的是什么，就直接在此定义一个该类型的变量，作为全局变量，最后直接返回该变量就可以了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 很多算法题的测试数据都会搞些数据恶心人，比如输入参数为空字符串，要预过滤</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == candidates || candidates.length == <span class="number">0</span> || target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 核心逻辑，本方法是一个无返回值的方法，因为结果记录在一个全局变量result里，省去了处理返回</span></span><br><span class="line">        process(candidates, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释一下核心逻辑，每进入下一层树，在list中增加一个数字，再进入下一层递归</span></span><br><span class="line">    <span class="comment">// 直到求和相同时，记录求和内容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步：先处理递归终止条件，此题是判断</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 第二步：当递归抵达成功时，记录结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意深拷贝</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="comment">// 第三步：当递归没终止、没成功，准备进入下一层递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 先加</span></span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                process(candidates, target - candidates[i], list);</span><br><span class="line">                <span class="comment">// 再删，删完出循环，准备再进循环加下一个</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是基础套路：</p>
<ol>
<li><p>定义一个全局变量记录结果</p>
</li>
<li><p>递归处理</p>
<ol>
<li><p>先处理递归终止，直接返回</p>
</li>
<li><p>再处理递归成功，记录结果后返回</p>
</li>
<li><p>没终止、没成功，就意味着还需要继续递归</p>
<p>在循环中执行回溯算法的核心</p>
<ol>
<li>先加</li>
<li>递归</li>
<li>再删</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>执行上述方法，得到这样的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LeetCode39.combinationSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 结果 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]</span></span><br></pre></td></tr></table></figure>

<p>会发现结果没有去重，出现了[2, 2, 3]和[2, 3, 2]这样内容一样但是排序不一样的情况，我们来分析一下如何去重。</p>
<p>重复的主要原因在于，当我们记录完[2, 2, ?]之后，进入[2, 3, ?]，选择第三个数时，我们不应当再考虑 2 了，因为在[2, 2, ?]的情况下，我们已经全部处理完有 2 的情况了，再之后我们不应该处理 2 了。细琢磨一下这句话：遍历时我们要设置一个起始点，处理过的要素，之后就跳过不参与考虑了。</p>
<p>这是递归新增参数的第一种情况，增加一个 <code>int start</code> 的参数，目的是为了在遍历时，从 start 位置开始，跳过某些元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">    <span class="comment">// 每次遍历从start开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="LeetCode46-全排列"><a href="#LeetCode46-全排列" class="headerlink" title="LeetCode46 全排列"></a>LeetCode46 全排列</h1><blockquote>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<table>
<thead>
<tr>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td>[1,2,3]</td>
<td>[<br>&nbsp;&nbsp;[1,2,3],<br>&nbsp;&nbsp;[1,3,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[2,3,1],<br>&nbsp;&nbsp;[3,1,2],<br>&nbsp;&nbsp;[3,2,1]<br>]</td>
</tr>
</tbody></table>
</blockquote>
<p>同样，还是先画递归树：</p>
<p><img src="/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg" alt="树示例"></p>
<p>直接写代码了噢，是完全一样的套路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode46</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == nums || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] select = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        doPermute(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), select);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> level, List&lt;Integer&gt; list, <span class="keyword">boolean</span>[] select)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &gt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (select[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    select[i] = <span class="keyword">true</span>;</span><br><span class="line">                    doPermute(nums, level + <span class="number">1</span>, list, select);</span><br><span class="line">                    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    select[i] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里递归在原先的三个参数基础上，又增加了一个新的参数，<code>boolean[] select</code>，一个布尔值的数组。</p>
<p>对于某些题目，就比如这道题，每个元素并不是可以无限使用的，而是只能只用一次，如果使用完一次，怎么标记下来呢，就是使用一个布尔值的数组，记录下标为x的元素，已经被使用过了，不能再使用。</p>
<p>回溯套路，就从原来的三行，变成了五行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(nums[i]);                   -&gt;   list.add(nums[i]);</span><br><span class="line">                                     -&gt;   select[i] = <span class="keyword">true</span>;</span><br><span class="line">doPermute(nums, level + <span class="number">1</span>, list);    -&gt;   doPermute(nums, level + <span class="number">1</span>, list, select);</span><br><span class="line">                                     -&gt;   select[i] = <span class="keyword">false</span>;</span><br><span class="line">list.remove(list.size() - <span class="number">1</span>);        -&gt;   list.remove(list.size() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>（上一道题每个元素可以无限制地使用，因此不需要一个布尔值数组记录是否能使用）</p>
<br>

<p>上面的套路，只是初期不熟悉时的套路，并不能解决所有回溯问题，但是可以在初接触回溯问题时尝试做出来。最好的学习方式仍然是做题，做十几道题，就自然明白了。再发一遍学习路线（LeetCode）：39 题 -&gt; 46 题 -&gt; 77 题 -&gt; 78 题 -&gt; 40 题 -&gt; 47 题 -&gt; 90 题。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/12/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<br>

<p>十二月的第四周，来学习正则表达式。</p>
<p>工作时经常需要用到正则表达式来校验字符串，每次遇到都怵怵的，这周来扫除一下盲区。</p>
<hr>
<p>正则表达式（regular expression），根据英文也可简写为 regex。“正则”这个中文翻译颇有民国风度，所谓公正而乎法则，今已查不到何处还在用此词，似乎只有编程领域在用。</p>
<p>正则表达式只用于字符串，用来检查字符串是否符合某种规定（例如只有字母、又例如没有数字等），或者是取出符合规定的字符串子串（用于后续替换等）。</p>
<p>例如下图，为匹配以 Hello 开头的字符串的正则表达式，成功匹配到了两条。</p>
<p><img src="/assets/1576558383714.png" alt="1576558383714"></p>
<p>（上图截图自 <a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a> 网站，是一个很好用的正则表达式在线测试网站）</p>
<p>此外再安利一组入门正则表达式的视频：<a href="https://www.bilibili.com/video/av18182693?from=search&seid=9361031783812248620" target="_blank" rel="noopener">《表严肃讲正则表达式》</a>，供入门使用。这组视频讲得很用心，不像大部分编程公开课跟倒泔水一样地倾泻几十个小时垃圾，我能感受到它是精心准备过的，很是喜欢。</p>
<br>

<hr>
<p>正则表达式的概念不难理解，若不清晰用过一两次便懂。使用正则表达式若有困难，都是因为语法繁多，需要记忆的内容量大。下面整理了三张正则表达式的常用语法字符表，主要来源为<a href="https://www.runoob.com/regexp/regexp-metachar.html" target="_blank" rel="noopener">菜鸟教程的正则表达式教程</a>。分三张表，分别是：</p>
<ul>
<li>非打印字符：转义后的字符，代表某一类字符</li>
<li>特殊字符：含特殊含义的字符</li>
<li>限定字符：字符次数限制</li>
</ul>
<h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
<th>正确示例</th>
<th>错误示例</th>
</tr>
</thead>
<tbody><tr>
<td>\w</td>
<td>数字、字母、下划线</td>
<td>1/a/A/_</td>
<td>./&amp;/の/【/<strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font></td>
</tr>
<tr>
<td>\W</td>
<td>除数字、字母、下划线以外</td>
<td>./&amp;/の/【/<strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font></td>
<td>1/a/A/_</td>
</tr>
<tr>
<td>\s</td>
<td>空白字符</td>
<td><strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>→|</strong><font color="#E0E0E0">(制表符)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font>/<strong>☇</strong><font color="#E0E0E0">(换页)</font></td>
<td>1/a/A/_/./&amp;/♂</td>
</tr>
<tr>
<td>\S</td>
<td>除空白字符以外</td>
<td>1/a/A/_/./&amp;/♂/张</td>
<td><strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>→|</strong><font color="#E0E0E0">(制表符)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font>/<strong>☇</strong><font color="#E0E0E0">(换页)</font></td>
</tr>
<tr>
<td>\d</td>
<td>数字（单个）</td>
<td>1/2/3/4/5/6/7/8/9/0</td>
<td>a/?/&amp;/1234<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>\D</td>
<td>除数字以外</td>
<td>a/B/,/%/张/<strong>︹</strong><font color="#E0E0E0">(空格)</font></td>
<td>1/2/3/1234<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
<td><strong>ㄱ</strong><font color="#E0E0E0">(换行)</font></td>
<td>1/a/A/_/?</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
<td><strong>→|</strong><font color="#E0E0E0">(制表符)</font></td>
<td>1/a/A/_/?</td>
</tr>
</tbody></table>
<br>

<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
<th>正确示例</th>
<th>错误示例</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>除换行以外任意字符</td>
<td>1/a/A/%/_</td>
<td><strong>ㄱ</strong><font color="#E0E0E0">(换行)</font>/123<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>^</td>
<td>从字符串开始的位置处匹配</td>
<td>^12 -&gt; 12/12<font color="#E0E0E0">3</font>/12<font color="#E0E0E0">a</font></td>
<td>^12 -×-&gt; a12/abc12/</td>
</tr>
<tr>
<td>$</td>
<td>从字符串结束的位置处匹配（倒着）</td>
<td>12$ -&gt; 12/<font color="#E0E0E0">abc</font>12/<font color="#E0E0E0">0</font>12</td>
<td>12$ -×-&gt; 123/12aaa</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
<td>[1|2|3] -&gt; 1/2/3</td>
<td>[1|2|3] -×-&gt; a/4/&amp;</td>
</tr>
<tr>
<td>[]</td>
<td>方框运算符，字符集合/范围/反向</td>
<td></td>
<td></td>
</tr>
<tr>
<td>()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>{}</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<br>

<h2 id="限定字符"><a href="#限定字符" class="headerlink" title="限定字符"></a>限定字符</h2><table>
<thead>
<tr>
<th>限定字符</th>
<th>描述</th>
<th>正确示例</th>
<th>错误示例</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配零个、一个或多个字符</td>
<td>12*3 -&gt; 13/123/1223</td>
<td>12*3 -×-&gt; 1</td>
</tr>
<tr>
<td>+</td>
<td>匹配一个或多个字符</td>
<td>12+3 -&gt; 123/12223</td>
<td>12+3 -×-&gt; 13</td>
</tr>
<tr>
<td>?</td>
<td>匹配零个或一个字符</td>
<td>12?3 -&gt; 13/123</td>
<td>12?3 -×-&gt; 12223</td>
</tr>
<tr>
<td>{n}</td>
<td>字符限定n次</td>
<td>2{4} -&gt; 2222</td>
<td>2{4} -×-&gt; 222/22222<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>{n,}</td>
<td>字符限定最少n次</td>
<td>2{2,} -&gt; 22/222/22222</td>
<td>2{2,} -×-&gt; 2</td>
</tr>
<tr>
<td>{n,m}</td>
<td>字符限定n-m次</td>
<td>2{2,3} -&gt; 22/222</td>
<td>2{2,3} -×-&gt; 2/2222<font color="#E0E0E0">(整体)</font></td>
</tr>
</tbody></table>
<br>

<hr>
<p>除以上常用的语法字符之外，还有以下规则，需要单独注意：</p>
<h2 id><a href="#" class="headerlink" title="[ ]"></a>[ ]</h2><p>方括号表示字符集合，可配合 ^ 符合表示反向的字符集合，常见用法有：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[12a]</td>
<td>可匹配 ‘1’ 或 ‘2’ 或 ‘a’</td>
</tr>
<tr>
<td>[1|2|a|,]</td>
<td>可匹配 ‘1’ 或 ‘2’ 或 ‘a’ 或 ‘,’</td>
</tr>
<tr>
<td>[1-9]</td>
<td>可匹配 ‘1’ 或 ‘2’ 或 …… 或 ‘9’</td>
</tr>
<tr>
<td>[a-z]</td>
<td>可匹配 ‘a’ 或 ‘b’ 或 …… 或 ‘z’</td>
</tr>
<tr>
<td>[^12a]</td>
<td>可匹配除了 ‘1’ 或 ‘2’ 或 ‘a’ 以外的字符</td>
</tr>
<tr>
<td>[^1-9]</td>
<td>可匹配除了 ‘1’ 或 ‘2’ 或 …… 或 ‘9’ 以外的字符</td>
</tr>
</tbody></table>
<br>

<h2 id="-1"><a href="#-1" class="headerlink" title="()"></a>()</h2><p>圆括号代表同时匹配多个字符，如匹配 <code>hello</code> 这五个字符，可以使用 <code>(hello)</code> 来匹配。</p>
<p>但是除此之外，() 匹配到的字符串还会被缓存起来，缓存起来的子表达式可以在之后使用。</p>
<p>例如使用<code>([nN]o)</code>匹配 <code>No, get out!</code>，不光能匹配到 <code>No</code>，还能通过 <code>$1oooooooo</code> 将原文替换成 <code>Nooooooooo, get out!</code>。</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(hello)</td>
<td>可以匹配 “hello”，并缓存起来</td>
</tr>
<tr>
<td>(?:hello)</td>
<td>可以匹配 “hello”，但不缓存结果<br>（用于匹配多字符但并不需要结果，有时能让正则表达式更简洁）</td>
</tr>
<tr>
<td>hello(?=AA)</td>
<td>可以匹配 “helloAA……” 中的 “hello”，但是不能匹配 “helloBB……” 中的 “hello”，且不缓存结果</td>
</tr>
<tr>
<td>hello(?!AA)</td>
<td>不能匹配 “helloAA……” 中的 “hello”，但是可以匹配 “helloBB……” 中的 “hello”，且不缓存结果</td>
</tr>
<tr>
<td>(?&lt;=AA)hello</td>
<td>可以匹配 “AAhello……” 中的 “hello”，但是不能匹配 “BBhello……” 中的 “hello”，且不缓存结果</td>
</tr>
<tr>
<td>(?&lt;!AA)hello</td>
<td>不能匹配 “AAhello……” 中的 “hello”，但是可以匹配 “BBhello……” 中的 “hello”，且不缓存结果</td>
</tr>
</tbody></table>
<br>

<h2 id="贪婪"><a href="#贪婪" class="headerlink" title="贪婪"></a>贪婪</h2><p>贪婪是编程和算法中常见的概念，意思是越多越好。</p>
<p>* 和 + 这两个限定符都是贪婪的，如果用 <code>hello*</code> 或者 <code>hello+</code> 来匹配 <code>hellooooooo</code>，它们的匹配结果都是 <code>hellooooooo</code>，而不是 <code>hell</code>、 <code>hello</code> 或 <code>hellooo</code> 或是其他的。</p>
<p>在 * 和 + 后面加上 ? 就可以使匹配结果是非贪婪的（最小匹配）。按照上面的例子，<code>hello*?</code> 匹配的结果是 <code>hell</code>，<code>hello+?</code> 匹配的结果是 <code>hello</code>。</p>
<br>

<hr>
<p>写几个看到过的正则表达式，举几个例子</p>
<ul>
<li><p>身份证校验（简易版）</p>
<p><code>^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$</code></p>
</li>
<li><p>不能包含数字</p>
<p><code>^[^\d]+$</code></p>
</li>
<li><p>浮点数</p>
<p><code>^(-?\d+)(\.\d+)?$</code></p>
</li>
<li><p>域名</p>
<p><code>^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</code></p>
</li>
<li><p>数字（包含负数、小数）</p>
<p><code>^-?[0-9]+(\.[0-9]+)?$</code></p>
</li>
</ul>
<br>

<hr>
<p>学习过正则表达式的基本语法之后，感觉在工作中还是不够用，还要学习 Java 中正则表达式的使用。</p>
<p>正则表达式从 JDK 1.4 之后出现，涉及到两个新类：Pattern 和 Matcher。Pattern 类代表一个正则表达式，而 Matcher 类代表一个正则表达式对一个字符串进行校验后的结果，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式，规则：不能包含数字</span></span><br><span class="line">String regex = <span class="string">"^[^\\d]+$"</span>;</span><br><span class="line">Pattern compile = Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配abcABC?&amp;</span></span><br><span class="line">String str = <span class="string">"abcABC?&amp;"</span>;</span><br><span class="line">Matcher matcher = compile1.matcher(str);</span><br></pre></td></tr></table></figure>

<p>Pattern 类没有（对外的）构造方法，因此生成一个 pattern 对象只能通过 Pattern 类的静态方法。</p>
<p>如果只是想检验字符串是否符合要求（即只需要一个boolean值），那么使用 Pattern 类的静态方法就可以，pattern 对象是为了更多操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String regex = <span class="string">"^[^\\d]+$"</span>;</span><br><span class="line">String str = <span class="string">"abcABC?&amp;"</span>;</span><br><span class="line"><span class="keyword">boolean</span> pass = Pattern.matches(regex, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------结果：pass:true</span></span><br></pre></td></tr></table></figure>

<p>Pattern 类多实现一些，用代码实现正则表达式的功能，而不是完全只用字符串来实现。例如它能指定正则表达式可以同时匹配大小写字母（指定后，正则表达式字符串即使只有 ‘a’，匹配时也可以同时匹配 ‘a’ 和 ‘A’），又或者可以用指定正则表达式分隔字符串，例如将一串带有数字的字符串，以数字为分隔拆分成多个子字符串。</p>
<p>Matcher 类多实现一些对匹配结果的处理，这一部分具体没怎么看，需要时再补吧。</p>
<p>最后提一句，Java 中使用正则表达式时，基本上要出现 <code>\</code> 的地方，都要转义成 <code>\\</code>，例如 <code>\d</code> -&gt; <code>\\d</code>。</p>
<p>本周就学习到这里了。</p>
<br>

<hr>
<blockquote>
<p>2020-03-08 补</p>
<p>发现平常在 Java 中使用 Pattern 类和 Matcher 类还是很频繁的，之前学习得不细致，得回来补一下。</p>
</blockquote>
<h1 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h1><p>Pattern 类可以理解成是正则表达式，可以使用 Pattern 对象来对字符串进行正则校验。</p>
<p>不能通过 new 来创建 Pattern 对象，只能通过 Pattern 类的静态方法创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">"\\w"</span>); <span class="comment">// 正则表达式：单个数字、字母或下划线</span></span><br></pre></td></tr></table></figure>

<p>日常使用 Pattern 类有两个用途：</p>
<ol>
<li><p>直接校验字符串，返回 true/false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验是否是qq邮箱</span></span><br><span class="line">String regex = <span class="string">"^\\w*@qq.com$"</span>;</span><br><span class="line"><span class="keyword">boolean</span> matches = Pattern.matches(regex, <span class="string">"hellopz@qq.com"</span>);</span><br></pre></td></tr></table></figure>

<p>这里有一处暗坑，校验成功要求<code>全部匹配</code>，如果是部分匹配，那么返回值将是 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> matches1 = Pattern.matches(<span class="string">"[0-9]"</span>, <span class="string">"123"</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> matches2 = Pattern.matches(<span class="string">"[0-9]*"</span>, <span class="string">"123"</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成一个校验过的结果，返回 Matcher 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式：是否是数字</span></span><br><span class="line">String regex = <span class="string">"[0-9]*"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成对"123"校验的结果（结果是一个Matcher对象）</span></span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure>

<p>Matcher 对象能做更多的事情，比如部分校验、取出校验结果等。</p>
</li>
</ol>
<p>Pattern 类的其他使用，例如指定正则模式 flag、分割字符串的 split() 方法（我好像觉得跟 String 对象的 split() 方法 没有任何区别？），感觉都不实用，不写了。</p>
<h1 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h1><p>Matcher 类可以理解成经过校验的字符串的校验结果，可以通过该对象处理校验结果。</p>
<p>Matcher 对象由 Pattern 对象的 matcher() 方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pattern表示正则表达式，方法内传入待校验的字符串</span></span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"wait to check"</span>);</span><br></pre></td></tr></table></figure>

<p>日常使用 Matcher 类也是两个用途：</p>
<ol>
<li><p>检查字符串中是否含正则校验内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验是否包含数字</span></span><br><span class="line">Matcher matcher1 = Pattern.compile(<span class="string">"[0-9]"</span>).matcher(<span class="string">"12345"</span>);</span><br><span class="line"><span class="keyword">boolean</span> contains = matcher.find();  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>请注意理解 find() 方法的语义，find 的意思是找到了，并不代表完全匹配，换言之只需要字符串中有正则内容就可以。因此使用 matcher.find() 和 Pattern.matches() 是不等价的。</p>
</li>
<li><p>取出正则校验结果</p>
<p>这里有一个需要先指出的暗坑：在取结果之前，必须先执行 Matcher 对象的 find() 方法，如果不执行，将抛出 <code>IllegalStateException</code> 异常：<code>No match found</code> （没找到匹配结果）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式：数字(字母)数字(字母)数字(字母)</span></span><br><span class="line">Matcher matcher = Pattern.compile(<span class="string">"\\d+([a-z])\\d+([a-z])\\d+([a-z])"</span>).matcher(<span class="string">"111a111b111c"</span>);</span><br><span class="line"><span class="keyword">boolean</span> find = matcher.find();      <span class="comment">// true</span></span><br><span class="line">String result = matcher.group();    <span class="comment">// 111a111b111c</span></span><br><span class="line">String result0 = matcher.group(<span class="number">0</span>);  <span class="comment">// 111a111b111c</span></span><br><span class="line">String result1 = matcher.group(<span class="number">1</span>);  <span class="comment">// a</span></span><br><span class="line">String result2 = matcher.group(<span class="number">2</span>);  <span class="comment">// b</span></span><br><span class="line">String result3 = matcher.group(<span class="number">3</span>);  <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>使用 group() 方法可以捕获到正则结果，如果正则表达式中有<code>( )</code>括起来的内容，这部分内容可以取出来。</p>
<p>有两种常用的 group() 方法，一种是传入 int 值的 group(int group) 方法，另一种是无参的 group() 方法。</p>
<ul>
<li><p>带 int 参数的 group() 方法，参数为 0 时代表整个表达式，为 1 时代表匹配到的第 1 个<code>( )</code>内容，为 2 时代表匹配到的第 2 个<code>( )</code>内容……以此类推，正如上面的代码示例。</p>
<p>如果参数是 n，但是实际上并没有 n 个匹配内容，会抛出 <code>IndexOutOfBoundsException</code> 异常。</p>
</li>
<li><p>无参的 group() 方法实际上就是 group(0)，代表整个表达式。</p>
</li>
</ul>
<p>此外还可以通过 groupCount() 方法获取匹配到<code>( )</code>的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...延续上面的代码</span></span><br><span class="line"><span class="keyword">int</span> count = matcher.groupCount();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>

<p>Java 的正则表达式写到这里应该就可以了，足够日常用了。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap 与 TreeMap</title>
    <url>/2019/12/15/HashMap-%E4%B8%8E-TreeMap/</url>
    <content><![CDATA[<br>

<p>十二月的第三周，来补习 Java 基础，学习 HashMap 与 TreeMap 的原理。</p>
<p>上周看 HashMap 的迭代器源码看上头了，觉得真巧妙哈哈，顺便还看了一点 TreeMap 的源码（但是没写），也觉得挺精妙的。那么这周来学习这两种 map 的实现。</p>
<p>本次所看的 Java 源码均来自于 JDK 1.8，无视之前版本的实现。</p>
<hr>
<p>由于 HashMap 的实现需要红黑树的基础支持，因此我们先看 TreeMap，一个基于红黑树实现的 map。</p>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>TreeMap：形式为 tree 的 map，确切地讲，这里的 tree 是 red black tree（红黑树）。</p>
<p>TreeMap 实现了 SortedMap 接口，因此是一个有排序的 map，表内每个元素在存储时都是按照规则排序的。</p>
<p>我们在使用 TreeMap 时，不论使用哪个方法，在内部基本都会使用到 TreeMap 的基本元素 Entry 类。Entry 本身的含义指键值对（key-value），这里是一个 TreeMap 自己定义和实现的类。从结构上看，TreeMap 对象就是由一个个的 Entry 对象所组成的。因此 TreeMap 在使用方法 get()、put()、remove()……时，实际上都是在操作它自己的一个个元素 Entry。</p>
<p>这里以 TreeMap 的 get() 方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是在调用 getEntry() 方法，根据 key 值获取一个基本存储元素：Entry。</p>
<p>TreeMap 的各个方法都在使用内部类 Entry，TreeMap 本身也就是由一个个的 Entry 对象组成的，因此我们先看看这个类的内部是什么样子。</p>
<br>

<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get、set方法等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap 内部自定义了 Entry 类，这个类实现了 Map.Entry 接口，也就是说，它是一个键值对（key-value）。</p>
<p>我们这里只需关注它的内部变量，其他的没必要关心（其他的是构造方法，get、set 方法，以及重写的 equals()、hashCode()、toString() 方法）。</p>
<p>Entry 类一共有六个成员变量：</p>
<ul>
<li>key  键</li>
<li>value  值</li>
<li>left  左节点</li>
<li>right  右节点</li>
<li>parent  父节点</li>
<li>color 颜色</li>
</ul>
<p>Entry 类除了 key 和 value 这两个所有 map 都必需的变量之外，还有四个成员变量，分别是左、右、父节点，以及一个布尔值变量：颜色。</p>
<p>成员变量里面有三个节点变量，以此能够猜出，这个类是一个节点类，比如链表里面的节点、树里面的节点等等，它能够从本节点找到其他的节点。而且变量里有左、右、父三个节点，看着就很像是二叉树的结构。</p>
<p>此外它还有一个布尔值变量：颜色。这个变量初见不是很理解，它有两种值，分别是红色（RED false）和黑色（BLACK true），默认是黑色的。这个布尔值变量，使得 Entry 类不光是二叉树的节点类，还是二叉树中红黑树的节点类，它在树节点之外还保留了另一种信息：类型。</p>
<br>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>写到这里必须要开始学习红黑树了。</p>
<p>我把基础设定为二叉树，二叉树及之前的内容不写了。我认为二叉树作为一种数据结构，它本身是没有功能的，只能算是有实现某些功能的潜质，比如有查找速度快的潜质。为了让二叉树能够真的查找速度变快，能快速地找到存储节点，需要给二叉树增加一些规则，比如存储时要按照某种顺序，分支的深度要有限制等等。</p>
<p>红黑树就是一种具有一些规则的二叉树，由于这些规则的限制，使得这种数据结构在查找存储内容时会快速很多。与红黑树作用类似的还有两种（我觉得看这两种也就够了叭），一种是二叉查找树（BST, Binary Search Tree），一种是平衡二叉树/ AVL 树（G. M. <font color="#32CD32"><strong>A</strong></font>delson-<font color="#32CD32"><strong>V</strong></font>elsky 和 E. M. <font color="#32CD32"><strong>L</strong></font>andis 发明的平衡二叉树）。当面试问到红黑树时，经常会被问到，既然有另外两种能够提高查询速度的二叉树了，为什么还需要红黑树（言下之意是问红黑树对比另外两种二叉树有什么不同），尤其是问红黑树相比于二叉查找树的优势。那么我从二叉查找树和 AVL 树开始写起，然后引到红黑树。</p>
<p>（这一部分基本上参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/72505589" target="_blank" rel="noopener">《记一次腾讯面试：有了二叉查找树、平衡树（AVL）为啥还需要红黑树？》</a>）</p>
<p>（以及所有的图片都来源于维基百科， 本周懒得画图hhh）</p>
<br>

<p><font color="#32CD32"><strong>二叉查找树</strong></font>给二叉树增加的规则是，左边比中间小，中间比右边小（左子树的节点值 &lt; 父节点值 &lt; 右子树的节点值），在存储的时候按照顺序存，找的时候就能很快地找到（因为有顺序了，不是漫无目的地找了）。</p>
<p>正常情况下，它是按照类似于二分查找法的思路去查询的。但是二叉查找树的规则约束性很有限，实际上即使按照规则，值依据链表的形式去存储也是合规的，但这样查询速度就又会慢了下来。</p>
<p><img src="/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" alt="二叉搜索树"></p>
<br>

<p><font color="#32CD32"><strong>平衡二叉树</strong></font>在定义上有些模糊，我暂时认为，在通常情况下，平衡二叉树是二叉查找树的一种，即平衡二叉树的全称是【平衡二叉查找树】。在这种定义之下，平衡二叉树在二叉搜索树的基础之上，为二叉树增加了新的规则，它不光要求二叉树按照顺序存储，还要求二叉树要存储地更均衡一些，不能出现左子树一堆节点而右子树为空的情况（也就是刚才所说的类链表情况）。在维基百科里，平衡二叉树的英文名是 self-balancing binary search tree，自动平衡的二叉查找树。</p>
<p>平衡二叉树有好多种，最常被 cue 的是 AVL 树，因为它是所有平衡二叉树中最平衡的那种。AVL 树在二叉查找树的基础之上，为二叉树增加的规则是，二叉树的左右子树，最大深度的差不能超过 1。下图就是 AVL 树最不平衡的状态，存在左右子树高度差达到 1 的情况，但是你应该也会觉得：这又怎么样呢，差一点点就完美平衡了。</p>
<p><img src="/assets/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="1576491211135"></p>
<p>AVL 树是最为平衡的，排列有序的二叉树，因此它在查找节点时，查询速度是相当之快的，理论上应该是平衡二叉树中查询速度最快的。但是平衡是有代价的，存储得那么有序，找起来快，存起来、删起来也慢啊。AVL 树每次插入新的节点时，如果不平衡，是通过旋转来调整平衡的。我没兴趣去探索它具体的旋转过程，但是我大概知道结论：当插入/删除节点是，AVL 树会很频繁地旋转来调整，消耗很大。</p>
<br>

<p><font color="#32CD32"><strong>红黑树</strong></font>出现的意义就在于，它是平衡二叉树，但它不需要那么平衡，差不多就行，这样查询也快，插入也快。</p>
<p>红黑树为二叉树制定了五条规则（在数量上令小白发指）：</p>
<ol>
<li>每个节点有颜色，不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶子节点也是黑色的（NIL 节点）</li>
<li>中间的节点可以是红色的，但是红色节点不能连在一起（红色节点只能跟黑色节点相连）</li>
<li>（平衡的核心）从任意节点出发，到每个叶子节点，应途径数量一样的黑色节点。</li>
</ol>
<p><img src="/assets/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<p>边看图边思考上面的规则，主要是第四、五两条规则，会发现红黑树它的平衡之处就在于，受到这些规则约束的二叉树，深度就是差得再多，在最坏的情况下，也只会差一倍（从根到叶子的最长的可能路径不多于最短的可能路径的两倍长），这种二叉树大致上是平衡的。</p>
<p>红黑树插入节点时同样要通过旋转来调整，但是调整的次数比 AVL 树小了很多，它虽然比 AVL 树查得慢，但是它增改节点快，是一种不错的折中选择。</p>
<p>终于讲完了红黑树的引入部分。</p>
<br>

<h2 id="TreeMap-的-put-方法"><a href="#TreeMap-的-put-方法" class="headerlink" title="TreeMap 的 put() 方法"></a>TreeMap 的 put() 方法</h2><p>我这几个周看迭代器，看容器设计，感觉认识一个容器最直接、最迅速的方法，就是去看这个容器是怎么添加元素的，list 去看 add() 方法，map 去看 put() 方法。按照这种思路，去了解 TreeMap 的容器设计，应该首先去看 TreeMap 的 put() 方法，去看 TreeMap 怎么添加新的键值对。</p>
<p>从整体上看，TreeMap 的 put() 方法分三部分：</p>
<ol>
<li>如果是首次添加，初始化容器，并直接返回。</li>
<li>按照顺序<strong>直接</strong>插入新节点。</li>
<li>调整结构，以符合红黑树的规则。</li>
</ol>
<p>先把全部的代码展示出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;                                       |</span><br><span class="line">    Entry&lt;K,V&gt; t = root;                                             |</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;                                                 ■  若首次添加，初始化根节点</span><br><span class="line">        compare(key, key);                                           |</span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);                        |</span><br><span class="line">        size = <span class="number">1</span>;                                                    |</span><br><span class="line">        modCount++;                                                  |</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;                                                 |</span><br><span class="line">    &#125;                                                                |</span><br><span class="line">    <span class="keyword">int</span> cmp;                                                         |</span><br><span class="line">    Entry&lt;K,V&gt; parent;                                               |</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;                          |</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;                                               ■    如果有特定的Comparator比较器</span><br><span class="line">        <span class="keyword">do</span> &#123;                                                         | \  按照该Comparator的排序逻辑插入节点</span><br><span class="line">            parent = t;                                              |  \</span><br><span class="line">            cmp = cpr.compare(key, t.key);                           |   \</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                             |    \</span><br><span class="line">                t = t.left;                                          |    |</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)                                        |    |</span><br><span class="line">                t = t.right;                                         |    |</span><br><span class="line">            <span class="keyword">else</span>                                                     |    |</span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);                            |    |</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);                                         |    |</span><br><span class="line">    &#125;                                                                |    |</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                           |    ■  如果没有Comparator比较器</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)                                             |    |  按照默认逻辑排序（根据key的类型）</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                        |    |</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)                               |    |</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;   |    |</span><br><span class="line">        <span class="keyword">do</span> &#123;                                                         |    |</span><br><span class="line">            parent = t;                                              |    |</span><br><span class="line">            cmp = k.compareTo(t.key);                                |    |</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                             |    |</span><br><span class="line">                t = t.left;                                          |    |</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)                                        |    |</span><br><span class="line">                t = t.right;                                         |    |</span><br><span class="line">            <span class="keyword">else</span>                                                     |   /</span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);                            |  /</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);                                         | /</span><br><span class="line">    &#125;                                                                ■</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);                  |</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                                     |</span><br><span class="line">        parent.left = e;                                             |</span><br><span class="line">    <span class="keyword">else</span>                                                             |</span><br><span class="line">        parent.right = e;                                            |</span><br><span class="line">    fixAfterInsertion(e);                                            ■  调整结构，以符合红黑树规则</span><br><span class="line">    size++;                                                          |</span><br><span class="line">    modCount++;                                                      |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;                                                     |</span><br><span class="line">&#125;                                                                    |</span><br></pre></td></tr></table></figure>

<p>代码属于清晰简单的范畴，按代码的顺序简单阅读一下这段 put() 方法。</p>
<br>

<ol>
<li><p>初始化</p>
<p>put() 方法首先获取 TreeMap 对象的根节点，这个根节点的类型就是我们最开始时说的 Entry 类，是一个存储着键值对信息的红黑树节点。</p>
<p>如果发现没有根节点，就说明这个 TreeMap 对象从来没有执行过 put() 方法，没有存储任意一个键值对，那么在这种情况下，把本次 put() 方法带进来的键值对作为根节点保存起来，直接返回，不执行后续内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// TreeMap的key和value均不能为null，这里是在检查key是否是null</span></span><br><span class="line">        compare(key, key);</span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后续代码...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入节点</p>
<p>在拿到根节点之后，put() 方法就准备插入节点了。插入节点的这部分，并不关心红黑树的约束条件，也就是说如果插入之后不满足红黑树的条件了，也是没关系的。调整树的结构以符合红黑树的约束条件，这段逻辑在 put() 方法的最后一部分。</p>
<p>因此，插入节点时关注的，不在于插入前后是否都符合红黑树的要求，而在于找到插入点的位置。对于 TreeMap 而言，一切节点都是按照顺序存储的，找插入点，实际上就是在找新节点应该排在什么位置上，它应该插入到<code>左边的节点比它小，而右边的节点比它大</code>的位置处，当然了，前提是有一套计算顺序的规则。</p>
<p>根据有没有计算顺序的规则，put() 方法做了一层 if-else 的判断，如果有比较器，按比较器的来，如果没有比较器，按默认排序方式来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...找到根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;                       <span class="comment">// 有比较器，按比较器排序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                   <span class="comment">// 没有比较器，按默认规则排序</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">    parent.left = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    parent.right = e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续代码...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="#32CD32"><strong>if</strong></font>-else：有 Comparator</p>
<p>说来又是我的知识盲区，我从来没有用过 Comparator 比较器，也是因为自己函数式编程写得少。</p>
<p>这里的 Comparator 对象，是 TreeMap 实例化时使用构造方法带进来的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有比较器，那么在插入节点时，按照二分查找法的思路执行。取父节点，计算大小关系（比较器的 compare() 方法），判断往左子树走还是往右子树走，直到再无子树。</p>
<p>这里的 Comparator 是自己实现的，意义就在于：自己指定了一套排序规则，让 TreeMap 中的元素按照这种规则存储。</p>
</li>
<li><p>if-<font color="#32CD32"><strong>else</strong></font>：无 Comparator</p>
<p>如果没有自己指定排序规则，那么 TreeMap 就会按照默认的方式进行排序。默认的排序方式是，让存储的 key-value 中的 key 提供排序规则，依照 key 的类型自带的排序规则进行排序。</p>
<p>具体来讲，就是 【treeMap.put(<font color="#CD32"><strong>key</strong></font>, value)】中的 key 需要实现 Comparable 接口。再换种说法解释，TreeMap 要求必须排序，如果你不主动提供排序规则，那就让 key 提供默认的排序规则（如果 key 没有排序规则，那只好报错）。</p>
<p>以最常见的情况举例：key 是 String 字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">treeMap.put(<span class="string">"str1"</span>, <span class="number">1</span>);</span><br><span class="line">treeMap.put(<span class="string">"str2"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这里有一处潜在的事情，那就是 String 类是实现了 Comparable 接口的，它有默认的排序规则。去看 String 类的结构体就能够发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 Comparable 接口，就必须重写 compareTo() 方法，也就是比较大小。String 类重写的 compareTo() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑大意就是，字符逐个比较先后顺序，比到最后比字符串的长度。按照这种逻辑，”str1” &lt; “str2”（结果为 -1 小于 0）。</p>
<p>回看刚才向 treeMap 里 put 进两个键值对（”str1” -&gt; 1 和 “str2” -&gt; 2)，不管怎么插入，最终 treeMap 存储这两个键值对，都会是 key 为 “str1” 的键值对在前，因为在字符串的排序当中，它居前位。此时打印出 treeMap，总是会按照如下顺序输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;str1=1, str2=2&#125;</span><br></pre></td></tr></table></figure>

<p>如果 key 的类型并没有实现 Comparable 接口，没有重写 compareTo() 方法，在存入 TreeMap 时就会报错，抛出类型转换异常（ClassCastException）。</p>
</li>
</ul>
</li>
<li><p>调整树结构</p>
<p>这部分 TreeMap 抽出了一个单独的方法，用以调整插入新节点之后的树，调整成红黑树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// ...已插入新节点</span></span><br><span class="line"></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分是红黑树调整树结构的具体算法，枯燥、易忘、烧脑，正常人遇到这里都会绕开走……我只简单地看一遍，混个面熟就好。</p>
<p>插入的新节点默认是红色的，然后根据父节点和 uncle 节点判断左旋右旋之类的。</p>
<p>哎，找了个视频看，觉得麻烦得要命，算了算了，等自己强一点再回来看叭……下面是该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<br>

<p>TreeMap 的其他方法暂且就不看了，转 HashMap 去了。</p>
<br>

<hr>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap 就是跟 hash 走得特别近的 map。</p>
<p>TreeMap 是通过 key 按顺序找到存储位置的，HashMap 是通过 key 的 hashCode 计算算出来存储位置的。</p>
<br>

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>HashMap 通过【数组+链表+红黑树】的数据结构存储键值对，很精巧的一种设计。</p>
<p>// 图</p>
<p>大体的存储逻辑是这样的：</p>
<ol>
<li>先在数组里存：计算哈希值，并根据哈希值取余，得知存在数组的第几个格子中，存入。</li>
<li>有则转链表：存数组时，如果格子里面已经有数据了，则按链表的结构存（尾插法）。</li>
<li>过长则转红黑树：存链表时，如果链表过长（超过 8 个），将链表转成红黑树，之后再插入新元素，按红黑树存储。</li>
</ol>
<br>

<h2 id="HashMap-的-put-方法"><a href="#HashMap-的-put-方法" class="headerlink" title="HashMap 的 put() 方法"></a>HashMap 的 put() 方法</h2><p>跟 TreeMap 一样，我们了解 HashMap 也是通过 put() 方法。</p>
<p>put() 方法的源码只有三行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>HashMap 的 put() 方法调用了一个私有方法，所有的代码逻辑都装在私有方法里。</p>
<p>这么看肯定是看不出 HashMap 的存储逻辑，但是通过 putVal() 方法的结构体，还是能够看出些东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="#32CD32"><strong>hash</strong></font>：key 的类哈希值</p>
<p>调用 hash() 方法获得，将 key 的哈希值前后 16 位进行与运算，以扩大 key 的哈希值差异。这样做能够使 hashMap 在存储数据时，存储地更平均。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="#32CD32"><strong>key</strong></font>：键</p>
</li>
<li><p><font color="#32CD32"><strong>value</strong></font>：值</p>
</li>
<li><p><font color="#32CD32"><strong>onlyIfAbsent</strong></font>：key 重复时是否保留原数据。</p>
<p>true：保留原 value</p>
<p>false：使用新 value</p>
</li>
<li><p><font color="#32CD32"><strong>evict</strong></font>：留给子类 LinkedHashMap 使用的，但无论是 true 还是 false 在 LinkedHashMap 里结果都是一样的，哎懒得看了，之后有机会再看吧。</p>
</li>
</ul>
<br>

<p>看完结构体，来看 putVal() 的具体实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  |</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;                                       |</span><br><span class="line">   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)                           ■  初始化（第一次的话）</span><br><span class="line">       n = (tab = resize()).length;                                              |</span><br><span class="line">   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)                                    ■  如果没有hash碰撞，直接插入</span><br><span class="line">       tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);                                 | \</span><br><span class="line">   <span class="keyword">else</span> &#123;                                                                        |   ■ 如果发生hash碰撞...</span><br><span class="line">       Node&lt;K,V&gt; e; K k;                                                         |   |</span><br><span class="line">                                                                                 |   |</span><br><span class="line">       <span class="keyword">if</span> (p.hash == hash &amp;&amp;                                                     |   ■  处理key已存在的情况</span><br><span class="line">           ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))               |   | \</span><br><span class="line">           e = p;                                                                |   |  \</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)                                           |   |   ■  以红黑树的结构存储</span><br><span class="line">           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);       |   |   | \</span><br><span class="line">       <span class="keyword">else</span> &#123;                                                                    |   |   |   ■  以链表的结构存储</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;                                |   |   |   |</span><br><span class="line">               <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                                       |   |   |   |</span><br><span class="line">                   p.next = newNode(hash, key, value, <span class="keyword">null</span>);                     |   |   |   |</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)                        |   |   |   |</span><br><span class="line">                       treeifyBin(tab, hash);                                    |   |   |   |</span><br><span class="line">                   <span class="keyword">break</span>;                                                        |   |   |   |</span><br><span class="line">               &#125;                                                                 |   |   |   |</span><br><span class="line">               <span class="keyword">if</span> (e.hash == hash &amp;&amp;                                             |   |   |   |</span><br><span class="line">                   ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))       |   |   |  /</span><br><span class="line">                   <span class="keyword">break</span>;                                                        |   |   | /</span><br><span class="line">               p = e;                                                            |   |   |/</span><br><span class="line">           &#125;                                                                     |   |  /</span><br><span class="line">       &#125;                                                                         |   | /</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;                                                          |   ■  替换key已存在时的value</span><br><span class="line">           V oldValue = e.value;                                                 |   |</span><br><span class="line">           <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)                                |   |</span><br><span class="line">               e.value = value;                                                  |   |</span><br><span class="line">           afterNodeAccess(e);                                                   |   |</span><br><span class="line">           <span class="keyword">return</span> oldValue;                                                      |  /</span><br><span class="line">       &#125;                                                                         | /</span><br><span class="line">   &#125;                                                                             ■</span><br><span class="line">   ++modCount;                                                                   |</span><br><span class="line">   <span class="keyword">if</span> (++size &gt; threshold)                                                       ■  扩容内部数组（若有需要）</span><br><span class="line">       resize();                                                                 |</span><br><span class="line">   afterNodeInsertion(evict);                                                    ■  为子类LinkedHashMap提供</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;                                                                  |  HashMap这里只是空实现</span><br><span class="line">&#125;                                                                                |</span><br></pre></td></tr></table></figure>

<p>HashMap 的 putVal() 方法逻辑，跟 HashMap 的存储结构是完全契合的：</p>
<ol>
<li>初始化 hashMap（即第一次使用 put() 方法）</li>
<li>算出数组位置后，能插入数据就插进去</li>
<li>如果不能插进去，分三种情况分析<ol>
<li>key 已存在，将新的 value 替换掉旧的 value</li>
<li>数组位置内已经存了链表：链表长度超过 8 则转红黑树，没超过则尾插链表</li>
<li>数组位置内已经存了红黑树：红黑树插入数据</li>
</ol>
</li>
<li>hashMap 内部数据过多则扩容数组（默认下，过多的标志：size &gt; 数组长度 × 0.75）</li>
</ol>
<br>

<p>HashMap 里的 put() 方法里有很多可以看的地方，包括【链表转红黑树】、【数组扩容】、【hash 值和负载值等的位运算】等，大概看了几眼，时间赶就不详叙述了。</p>
<p>这周就看到这里吧。</p>
<br>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jpa 实体关联注解</title>
    <url>/2019/09/08/jpa%E5%AE%9E%E4%BD%93%E5%85%B3%E8%81%94%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<br>

<p>九月的第二周，来看 Jpa 注解开发实体关联，Spring Cloud 下周再说。</p>
<p>被 Jpa 实体关联搞得有点烦，两个月了也没完全清晰，特来写一篇文章把常见关联情况都试一遍。</p>
<hr>
<p>从 ORM 框架说起。</p>
<p>ORM（ Object-Relational Mapping ），对象关系映射。我们平常操纵的数据库都是关系型数据库（关系：表与表之间存在关系，例如从【部门表】可以查到【员工表】）。 Java 是一门面向对象的语言，它希望与对象打交道，而不是与数据库、与表打交道，通过 <code>ORM （对象关系映射）</code> 实现对象之间建立起关系。</p>
<p>术语一些： ORM，把关系数据库的表结构映射到对象上。</p>
<br>

<p>我们首先厘清一下概念。</p>
<p>从大类上分，有两类：数据库、实体。</p>
<ul>
<li><p>数据库：表 + 字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── 部门表</span><br><span class="line">│   ├── 部门ID （字段）</span><br><span class="line">│   └── 部门名（字段）</span><br><span class="line">└── 员工表</span><br><span class="line">    ├── 员工ID （字段）</span><br><span class="line">    └── 员工名（字段）</span><br></pre></td></tr></table></figure>
</li>
<li><p>实体：类 + 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── 部门类</span><br><span class="line">│   ├── 部门ID （属性）</span><br><span class="line">│   └── 部门名（属性）</span><br><span class="line">└── 员工类</span><br><span class="line">    ├── 员工ID （属性）</span><br><span class="line">    └── 员工名（属性）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>

<p>数据库中，表之间的关联，是通过外键做到的，具体内容我们不讨论，这个去看数据库和 SQL 相关。</p>
<p>实体中，类之间的关联，可以通过注解来实现，这是我们这篇要详细讨论的。</p>
<br>

<p>顺便一提命名规则。</p>
<p>数据库的命名规则，基本使用下划线命名法，例如：department_id（部门ID）。</p>
<p>实体的命名规则，基本使用驼峰命名法，例如：departmentId（部门ID）。</p>
<hr>
<p>注解是 JDK 1.5 引入的内容，原理基于反射，使用起来非常方便，Spring 中大量使用，具体不细叙。</p>
<p>使用注解开发实体关联，有两种途径：</p>
<ul>
<li><p><code>@OneToOne</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@ManyToMany</code> 这四个注解是一类。</p>
<p>除了 <code>@ManyToOne</code> 这个注解之外，其他三个注解都有 <code>mappedBy</code> 属性，用于关联实体。</p>
</li>
<li><p><code>@JoinColumn</code> 注解，用于关联实体。（但是还是要加上 <code>@OneToOne</code> 等关联注解的，两个注解一起使用）</p>
</li>
</ul>
<p>要注意的是，这两种注解关联的方法，不能一起使用，只能选择一种使用。</p>
<br>

<h2 id="注解填写属性"><a href="#注解填写属性" class="headerlink" title="注解填写属性"></a>注解填写属性</h2><p>这两种注解，填写的属性是不同的。</p>
<p> <code>mappedBy</code> ：类层面，关联的全都是【实体类】中的【属性名】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// departmentId ：类中的属性名</span></span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy = <span class="string">"departmentId"</span>)</span><br></pre></td></tr></table></figure>

<p> <code>@JoinColumn</code>：字段层面，关联的全都是【表】中的【字段名】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// department_id ：表中的字段名</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"department_id"</span>)</span><br></pre></td></tr></table></figure>

<p>多说一句， <code>@Table</code>、 <code>@Column</code>、 <code>@JoinTable</code>、 <code>@JoinColumn</code>、<code>@JoinColumns</code>，这些都是一类的，填写的全都是数据库中的字段名（下划线命名法的那些）。</p>
<hr>
<p>正式开始。</p>
<p>建两个实体类，<code>Department</code> 和 <code>Employee</code> ，各有 id 和 name 两个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_department"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"department_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> String departmentId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"department_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"employee_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> String employeeId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"employee_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续代码会略写。</p>
<hr>
<h1 id="OneToOne-一对一映射"><a href="#OneToOne-一对一映射" class="headerlink" title="@OneToOne 一对一映射"></a>@OneToOne 一对一映射</h1><p>场景：一个部门里只有一个员工，同样的，一个员工只属于一个部门。</p>
<h2 id="JoinColumn"><a href="#JoinColumn" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"own_employee_name"</span>, referencedColumnName = <span class="string">"employee_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> Employee ownEmployee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【己方】实体的【数据库字段】</li>
<li><code>referencedColumnName</code> ：【对方】实体的【数据库字段】（如果是主键，可以省略）</li>
</ul>
<p><img src="/assets/%E5%8D%95%E5%90%91%E4%B8%80%E5%AF%B9%E4%B8%80.jpg" alt="一对一 @JoinColumn"></p>
<br>

<h2 id="OneToOne-mappedBy-“…”"><a href="#OneToOne-mappedBy-“…”" class="headerlink" title="@OneToOne(mappedBy = “…”)"></a>@OneToOne(mappedBy = “…”)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"own_employee_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Employee ownEmployee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToOne</span>(mappedBy = <span class="string">"ownEmployee"</span>)</span><br><span class="line">    <span class="keyword">private</span> Department belongDepartment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>@OneToOne</code> 注解，<code>mappedBy</code> 只有一种使用方法，那就是对方先关联自己，自己反关联回去。（因此无法通过 <code>mappedBy</code> 来实现一对一的单向关联，如若一对一关系使用 <code>mappedBy</code> ，必定是双向关联）</p>
<p>上面的代码实现了这样的功能：【部门类】首先关联了【员工类】（通过 <code>@JoinColumn</code> 注解），把员工作为自己的一个属性。【员工类】通过 <code>mappedBy</code> 反关联回去【部门类】，其中 <code>mappedBy</code> 所指向的值，就是部门类已经关联好的员工类属性。</p>
<p>换句话说，一对一的关联关系是由【部门类】所创建和维护的，<code>mappedBy</code> 自身不关联，它只是顺着这层已经存在的单层关联，顺藤摸瓜地反关联回去。</p>
<p><img src="/assets/%E4%B8%80%E5%AF%B9%E4%B8%80mappedBy.jpg" alt="一对一 mappedBy"></p>
<hr>
<h1 id="OneToMany-一对多映射"><a href="#OneToMany-一对多映射" class="headerlink" title="@OneToMany 一对多映射"></a>@OneToMany 一对多映射</h1><p>场景：一个部门里有多个员工。</p>
<h2 id="JoinColumn-1"><a href="#JoinColumn-1" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"employee_name"</span>, referencedColumnName = <span class="string">"own_employee_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; ownEmployeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【对方】实体的【数据库字段】</li>
<li><code>referencedColumnName</code> ：【己方】实体的【数据库字段】（如果是主键，可以省略）</li>
</ul>
<p>（发现了吗，刚好是跟一对一关系是反过来的）</p>
<p><img src="/assets/%E4%B8%80%E5%AF%B9%E5%A4%9A@JoinColumn.png" alt="一对多@JoinColumn"></p>
<p>这是个很有意思的事情，为什么这里反过来了呢？这个我们在后文的分析中再讨论。</p>
<h2 id="OneToMany-mappedBy-“…”"><a href="#OneToMany-mappedBy-“…”" class="headerlink" title="@OneToMany(mappedBy = “…”)"></a>@OneToMany(mappedBy = “…”)</h2><p>一对多的情况下，<code>mappedBy</code> 有两种使用方式。</p>
<ol>
<li><p>跟一对一关联一样，首先对面已经关联好自己，自己只需要反向关联回去即可，<code>mappedBy</code> 的值是自己在对方类中的属性名。（在这种情况下，必须双向关联）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"employeeName"</span>) <span class="comment">// 匹配自己在对方的实体属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; ownEmployeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无需对方关联，直接去关联对方的外键属性。（在这种情况下，虽然使用了 <code>mappedBy</code> ，但是依旧是单向关联）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"departmentId"</span>) <span class="comment">// 匹配对方的外键</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; ownEmployeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样单向关联有一个前提：对方的外键关联自己时，必须关联自己的主键。</p>
<p>比较简单，就不画图了。</p>
</li>
</ol>
<hr>
<h1 id="ManyToOne-多对一映射"><a href="#ManyToOne-多对一映射" class="headerlink" title="@ManyToOne 多对一映射"></a>@ManyToOne 多对一映射</h1><p>场景：多个员工归属于同一个部门。</p>
<h2 id="JoinColumn-2"><a href="#JoinColumn-2" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"belong_department_name"</span>, referencedColumnName = <span class="string">"department_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> Department belongDepartment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【己方】实体的【数据库字段】</li>
<li><code>referencedColumnName</code> ：【对方】实体的【数据库字段】（如果是主键，可以省略）</li>
</ul>
<p>多对一关联（ ManyToOne ），和一对一关联（ OneToOne ），在使用 <code>@JoinColumn</code> 时，是一模一样的。</p>
<p>也就是说，一对一、多对一的关联，和一对多的关联，在 <code>name</code> 和 <code>referencedColumnName</code> 上，是刚好相反的，这个我们一会分析。</p>
<h2 id="❌-mappedBy"><a href="#❌-mappedBy" class="headerlink" title="❌ mappedBy"></a>❌ mappedBy</h2><p><code>@ManyToOne</code> 不存在 <code>mappedBy</code> 属性。</p>
<p>因为 <code>mappedBy</code> 的原理是把关联的任务交给对面去做，员工有N个，部门只有1个，员工让部门去维护关联，一个部门是无法同时关联N个员工的，因此不存在 <code>mappedBy</code> 属性。</p>
<hr>
<h1 id="ManyToMany-多对多映射"><a href="#ManyToMany-多对多映射" class="headerlink" title="@ManyToMany 多对多映射"></a>@ManyToMany 多对多映射</h1><p>场景：一个部门内有多个员工，但是同时，一个员工也可以属于多个部门。</p>
<h2 id="JoinTable"><a href="#JoinTable" class="headerlink" title="@JoinTable"></a>@JoinTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable</span>(name = <span class="string">"pz_ref"</span>,</span><br><span class="line">            joinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"ref_department_id"</span>)&#125;,</span><br><span class="line">            inverseJoinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"ref_employee_id"</span>)&#125;)</span><br><span class="line">    <span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多对多关联，是需要自己建一张中间表的。粗略一想就会发现，多对多，双方都是多，无法实现一方用外键关联另一方，所以必须有中间表。（但是不需要为这张中间表创建实体类）</p>
<p>除了新增一张表之外，连注解也发生了改变。原先是 <code>@JoinColumn</code> ，<code>join</code> 到字段中，现在是 <code>@JoinTable</code> ，<code>join</code> 到表中。</p>
<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【中间表】的【表名】</li>
<li><code>joinColumns</code> ：【己方表】与【中间表】关联（按 @OneToMany 的方式来）</li>
<li><code>inverseJoinColumns</code>：【对方表】与【中间表】关联（按 @OneToMany 的方式来）</li>
</ul>
<p><img src="/assets/@JoinTable.png" alt="@JoinTable"></p>
<h2 id="ManyToMany-mappedBy-“…”"><a href="#ManyToMany-mappedBy-“…”" class="headerlink" title="@ManyToMany(mappedBy = “…”)"></a>@ManyToMany(mappedBy = “…”)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(mappedBy = <span class="string">"employeeList"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; departmentList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一种使用方法，跟一对一关联（ OneToOne ）、一对多关联（ OneToMany )都具有的使用方法一致：<code>mappedBy</code> 属性值是自己在对面实体类中的属性名，即必须双向映射。</p>
<hr>
<p>四类关联：一对一、一对多、多对一、多对多，已经都走过一遍了。现在分析一下两种注解方式（ <code>@JoinTable</code> 就懒得提了）。</p>
<h1 id="JoinColumn-3"><a href="#JoinColumn-3" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h1><p>我所理解的 <code>@JoinColumn</code> ，它的本质是 <code>@Column</code> ，从本质上来说，它并不是在做关联，它是在做映射，它把【数据库】和【实体】映射起来，使用这类注解能够实现：数据库中的一个字段，对应着，实体类中的一个字段。所以，它在做的事情，并不是把【部门】和【实体】关联起来，而是把【表】和【实体类】映射起来（但是与此同时，也就关联起来了两个实体)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"自己"</span>, referencedColumnName = <span class="string">"对方"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"对方"</span>, referencedColumnName = <span class="string">"自己"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"自己"</span>, referencedColumnName = <span class="string">"对方"</span>)</span><br></pre></td></tr></table></figure>

<p>刚才我们发现，【1 - 1】、【N - 1】的使用方法是相同的，但是【1 - N】刚好反了过来，这是为什么。</p>
<p>是因为，<code>@JoinColumn</code> 根本就不关心它所在的实体类是谁，它的 <code>name</code> 属性指向的，永远都是外键。因为外键始终在【多】的一方（一对一的话就默认自己是多），因此 <code>name</code> 属性值为【多的一方的外键】。</p>
<p>有关 <code>@JoinColumn</code> 自动建表的事情，我还没有弄清楚。</p>
<h1 id="mappedBy-“…”"><a href="#mappedBy-“…”" class="headerlink" title="mappedBy = “…”"></a>mappedBy = “…”</h1><p><code>mappedBy</code> 通常出现，都是为了做双向关联，而且对于 <code>@OneToOne</code> 和 <code>@ManyToOne</code> 而言，<code>mappedBy</code> 只能做双向关联。</p>
<p>我们在文章开头就指出，<code>mappedBy</code> 是针对【实体类】而做操作的，它的值是本类在对方类的属性名。我们再理一遍，它要等对方关联自己之后，自己顺着这层【已经建立起来的联系】，反关联回去。</p>
<p>这么做的道理是，A 关联 B，B 不应该再去建立新的关联关系，去重新关联 A（当然你硬要这么做也可以），而应该根据 A 关联 B 的这层关系，自动地找回去。这叫做：</p>
<blockquote>
<p>本类放弃控制关联关系，关联由对方去控制。</p>
</blockquote>
<br>

<p>很奇怪的一件事是，对于三种能使用 <code>mappedBy</code> 属性的注解： <code>@OneToOne</code> 、<code>@OneToMany</code> 、 <code>@ManyToOne</code> ，它们有一种统一的使用方法（即本类在对方类的属性名）。但是对于 <code>@OneToMany</code> ，它有第二种使用方法，它仿佛可以不需要对面先建立联系，直接使用 <code>mappedBy</code> 指向对方类的外键属性。</p>
<p>这样做的原理是，依旧让对方维护关联关系，但是必须由对方的【外键】关联己方的【主键】（如果使用 <code>@JoinColumn</code> 可以由对方的【外键】关联己方的【任意键】）。</p>
<p>也就是说，在一对多的关系中，【一方】想去关联【多方】，但是又不想自己去维护关联关系（因为一对多时，维护关联关系的话，代码会自动地创建出来一张新表），因此【一方】使用 <code>mappedBy</code> 让对面来处理关联关系。对面是怎么做关联的呢，是通过外键关联主键的方式关联的。</p>
<hr>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>最后说一说 Jpa 和注解关联的各种坑。</p>
<br>

<ol>
<li><p>驼峰命名法和下划线命名法的自动转换</p>
<p>我还没查清具体的原因，是 Spring 框架还是 hibernate ，总之现在框架能自动把数据库中的【下划线命名法】映射到实体类中的【驼峰命名法】。</p>
<p>例如，正常来讲，实体类中的属性应该要通过 <code>@Column</code> 配置映射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_department"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里通过 @Column 注解</span></span><br><span class="line">    <span class="comment">// 将部门表中的【department_name】字段映射到部门类中的【departmentName】</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"department_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是实际上，就是不加 <code>@Column</code> 注解，框架也能自动映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_department"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部门表中的【department_name】字段，自动映射到部门类中的【departmentName】</span></span><br><span class="line">    <span class="comment">// 框架能够自动将下划线命名，转换为驼峰命名</span></span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是！一定不要这么做！</p>
<p>因为在做关联时，有可能会生成新表，如果之前没有加 <code>@Column</code> 注解映射到数据库的话，新表的字段，将不会是原表中的字段名（下划线命名），而将是实体类中的属性名（驼峰命名），这时再去做关联，会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: org.hibernate.MappingException: Unable to find column with logical name: employee_name in org.hibernate.mapping.Table(pz_employee) and its related supertables and secondary tables</span><br></pre></td></tr></table></figure>

<p>报错信息：【employee_name】字段，在【pz_employee】表以及其他相关表中找不到。</p>
<p>报错原因：因为在其他相关表（自动创建）中，字段名是【employeeName】。</p>
<br>
</li>
<li><p>进行双向关联时，循环打印</p>
<p>部门关联员工，员工关联回部门，部门再关联回员工……程序运行本身不会出现问题，但是如果打印出来，就会造成关联上的死循环，直至溢出。</p>
<p>想要解决的话，就在其中一个类的该属性上加上 JSON 相关的注解，让这个属性不进行序列化。</p>
<p>例如通过 <code>fastjson</code> 中的 <code>@JSONField(serialize = false)</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Department department;</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><code>@JoinColumn(name = &quot;...&quot;)</code> 属性映射不能重复</p>
<p>上文中分析过，<code>@JoinColumn</code> 注解本质上是对数据库和实体类进行映射。如果某一数据库中的字段，已经映射到某属性上了，在 <code>@JoinColumn</code> 中的 <code>name</code> 属性里再次映射，就会出现问题：到底映射的是哪一个呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Column</span>(name = <span class="string">"belong_department_id"</span>)</span><br><span class="line"><span class="keyword">private</span> String belongDepartmentId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"belong_department_id"</span>, referencedColumnName = <span class="string">"department_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Department belongDepartment;</span><br></pre></td></tr></table></figure>

<p>例如上面这段代码，就会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.hibernate.MappingException: Repeated column in mapping <span class="keyword">for</span> entity: com.app.ykym.modules.test.entityAndRepository.Employee column: belong_department_id (should be mapped with insert=<span class="string">"false"</span> update=<span class="string">"false"</span>)</span><br></pre></td></tr></table></figure>

<p>解决方法在报错信息里也说明了：重复映射的两个属性，选一个，让它 <code>insert=&quot;false&quot; update=&quot;false&quot;</code> （写在注解里），意思是让其中一个属性放弃更新和插入数据库的权限。</p>
<p>（但是 <code>@OneToMany</code> 时，<code>@JoinColumn(name = &quot;...&quot;)</code> 是可以重复的）</p>
</li>
</ol>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 工具</title>
    <url>/2019/11/03/maven-%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<br>

<p>十一月的第一周，来学习和整理 Maven。</p>
<p>用维基的话讲，Maven 是一个项目管理以及自动构建的工具（初听还是有些一头雾水的）。我开始工作之后，几乎天天和 Maven 打交道，但是仿佛又对它很生疏，特用一周的时间来学习与整理相关知识。</p>
<hr>
<p>Maven 是 Apache 公司所创造的项目管理工具。项目管理这个词，在计算机编程方面没那么容易解释，你可以理解为编程中除了写代码那部分之外的工作，例如编译、打包、引入依赖资源等等这类打杂的事情。</p>
<br>

<p>在 Maven 出现之前，Ant 是 Java 世界的主流项目管理工具，所有人在介绍 Maven 的时候，总是会先讲几句 Ant 如何拧巴、如何不优雅，然后才话归正题说起 Maven。我并没有用过 Ant，我猜测很多像我一样的萌新也是直接上手 Maven，而从没使用过 Ant 的，我们这类人每次看 Maven 的教程都会一脸懵逼：“Ant 是什么？我们这说 Maven 呢你提它干嘛？”</p>
<p>看了许久，大概能猜到 Maven 和经常被鞭尸的 Ant 的区别：Ant 是一个很传统的项目管理工具，想实现什么，自己写去，麻烦也得自己写；Maven 是一个【约定大于配置】的项目管理工具，帮你写好了大部分东西、配好了大部分操作，你稍微一改就能用了（前提是你要遵守约定）。</p>
<br>

<p>在 Maven 的官网中，有一篇名为《Maven 的哲学》的文章，里面粗略介绍了 Maven 的设计哲学。其中有这么一句话：</p>
<blockquote>
<p>Maven is about the application of patterns in order to achieve an infrastructure which displays the characteristics of visibility, reusability, maintainability, and comprehensibility. </p>
</blockquote>
<p>我认为这句话里最重要的词是“patterns”，这个词直译是模式、范例。我觉得呢，pattern 是一个很有哲学思辨性的词，印象中它最早出现应该是在柏拉图的理念论里面，柏拉图认为有两个世界，一个是理想世界，一个是现实世界，现实世界中的一切都以理想世界中的“范型”（pattern）为模板创造出来。</p>
<p>不要有抵制心理，这是个很简单的概念，举个例子：世界上有那么多人，每个人都各有不同，但大家都属于同一类事物：人。按照柏拉图的理解，一定有另一个世界，那里有人这个模板，我们这个世界上的所有人，都是从另一个世界上的那个模板拷贝而来的。如果用编程术语来描述的话，这就是对象与类之间的关系，一个是抽象化的，一个是实例化的。</p>
<p>Maven 自述哲学思想的这段话，我理解的意思是，Maven 设置了一个公用模板，如果你使用 Maven 来管理项目，你就可以使用那个默认的模板，稍微改一点东西就可以了。这是一种和 Spring Boot 一样的配置思路，即约定大于配置，我们约定好了，你就别自己配置了。这样做有两种好处，一种是减少开发时间，一种是标准化、规范化，以方便大家交流。</p>
<br>

<p>但我是觉得吧，Maven 所指的“patterns”，说的不光是约定大于配置这件事，它当然包括这个，但是不只是。因为 Maven 本身不光是一个解决项目配置问题的工具，它做的事情是项目管理，管理这个概念就广泛了很多，包括依赖、编译、部署等等，当然，其中也包括配置。我理解的 Maven，它在配置方面采用约定大于配置的思路，但是在其他地方，也是本着【模块化】、【范型化】、【标准化】这一类的思路来处理的。</p>
<p>这个慢慢体会。</p>
<hr>
<p>对我而言，学习 Maven 首先遇到的问题是，我分不清楚那一堆项目管理的功能，究竟是 Maven 的，还是 IDE 的（此处应该配一个扶额焦虑的表情）。在我写这篇博文之前，很多 Maven 的设计与功能，我都以为是 IDEA 帮我做的，毕竟我每一次构建项目，都是打开 IDEA 软件，使用 Maven 来构建工程的，而且一切过程都是全程默认下一步做的，搞得我现在都分不清这两个工具的功能边界了……</p>
<br>

<p>用 Maven 构建项目，首先注意到的，是文件的目录结构。多建几次就会发现，每次新建出来的项目（project），或者是模块（module），文件的目录索引都是一样的，基本都长下面这个样子：</p>
<p><img src="/assets/maven%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="maven目录结构"></p>
<p>这种目录结构是 Maven 构建出来的，统一化的文件索引方式，好处之一在于，各开发者在开发时，存放文件的位置几乎没有差别（而且符合直觉），能够维持团队高效运作；好处之二在于，固定的文件存放路径，能够让第三方工具 Maven 帮助我们管理项目，而不是我们自己做繁复的操作。</p>
<p>这种目录结构，最重要的是三部分：<code>src</code>、<code>target</code>、<code>pom.xml</code>。他们分别对应着：源代码、编译文件、配置文件。稍详细一点的信息看下面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── src                src即source，代表源文件目录</span><br><span class="line">│   ├── main             主程序</span><br><span class="line">│   │   ├── java           存放java源代码，几乎所有代码文件都在这里</span><br><span class="line">│   │   └── resources      存放资源文件，例如application.xml</span><br><span class="line">│   └── test             测试程序</span><br><span class="line">│       └── java           内存放测试代码</span><br><span class="line">│</span><br><span class="line">├── target             输出目录</span><br><span class="line">│   ├── classes          编译输出目录</span><br><span class="line">│   └── test-classes     测试编译输出目录</span><br><span class="line">│</span><br><span class="line">└── pom.xml            配置文件</span><br></pre></td></tr></table></figure>

<p>我觉得这部分没什么好关注的，看几次就记得很牢固了，这种目录结构还是很符合直觉的。</p>
<p>上文说到，重要的有三部分：<code>src</code>、<code>target</code>、<code>pom.xml</code>，这前两个着实没什么可介绍的，一个放源码，一个放编译文件，但第三个 <code>pom.xml</code> （Maven 的配置文件），还是要单独学习的。</p>
<hr>
<p>POM 的全程是 Project Object Model，项目对象模型。Maven 是一个项目管理工具，它要面对的是项目，它面对项目的管理方式是 POM，把项目当做对象一样管理。这种面向对象的处理方式，跟 Java 是一个路数的，只不过 Java 的编码语言是 Java，Maven 的编码语言是 xml。</p>
<p>初看 Maven 的配置文件（pom.xml），xml 这种语言在字符数量上实在是令人畏惧，这一大堆的代码让人一头雾水，感觉要配置的东西很繁琐，很混乱。</p>
<p>以下是一段配置得较为简单，但还是能够运行的 pom.xml 文件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.pz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我在四处找 Maven 教程和总结贴的时候，看到了一篇博文（但是我后来找不到了，抱歉不能链接来源了），他提供了一种新的认知思路：既然 POM 就是将项目视作对象，以面向对象的方式进行管理，那么我们可以把 xml 的代码转换成 Java 代码来理解。上面的那段 xml 代码，如果是用 java 代码来看待的话，应该是这样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelVersion;</span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line">    <span class="keyword">private</span> String artifactId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependencies;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class Dependency &#123;</span><br><span class="line">        <span class="keyword">private</span> String groupId;</span><br><span class="line">        <span class="keyword">private</span> String artifactId;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">        <span class="keyword">private</span> String scope = compile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就清晰很多，便于初次看到 xml 代码来理解了。</p>
<br>

<p>下面分类型，挑选一部分经常要使用的配置项来总结一下。</p>
<p>pom.xml 文件能够配置的地方特别多，在此全部总结出来不现实，以后遇到了现查就可以了。参考这篇<a href="https://www.runoob.com/maven/maven-pom.html" target="_blank" rel="noopener">《POM 标签大全详解》</a>去查阅更多配置解释（在网页内容的下半部分）。</p>
<h1 id="项目基本信息"><a href="#项目基本信息" class="headerlink" title="项目基本信息"></a>项目基本信息</h1><p>以这段代码为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.pz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从头文件说起，这部分不是 Maven 的 pom.xml 文件所专有的，而是一切 xml 文件都要配置的。</p>
<ul>
<li><p><strong>xmlns</strong></p>
<p>全称是 xml name space，即 xml 命名空间。</p>
<p>命名空间的意思是，有两个 xml 文件都使用了同一个名字，比如 A.xml 文件是一个人员文件，里面用 name 这个名字表示人名，与此同时 B.xml 文件是一个公司文件，里面用 name 这个名字表示公司名。当两个文件同时执行时，如果不指定 xml 文件的命名空间，那么就会造成混乱。</p>
<p>通常情况下，如果要指定命名空间，应该是 <code>xmlns:a</code>、<code>xmlns:b</code> 之类的写法，表示 a 的命名空间、b 的命名空间是什么，这里什么都不写，是表示默认的命名空间。</p>
<p><code>xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</code> 这一行的右边是一个字符串（更准确的讲，是一个 url 地址字符串），这个字符串表示该命名空间的唯一标识符。通常情况下，这个字符串会是一个 url 地址，点开之后能够看到详细的对于该命名空间的说明。但是在这里，如果你尝试的话，这个 url 并打不开，这个后面再说。</p>
</li>
<li><p><strong>xmlns:xsi</strong></p>
<p>根据上面对于 xmlns 的解释，这里应该就是声明 xsi 命名空间了。</p>
<p>xsi 的全称是 xml schema instance，这个命名空间并不是偶然出现的，它已经成为了一种业界规范，是表示 xml 文档结构（ XSD，xml scheme definition）的命名空间。xml 文档结构，就是整个 xml 文件需要有哪些内容，这些内容的格式、默认值等等是什么，我们所写的 pom.xml 文件，都是基于它的 xml 文档结构来写的。由于文档结构是非常重要的东西，因此为它单独指定一个命名空间。</p>
<p>这次你点开后面的网址，就能看见对于 xsi 这个命名空间的简单说明了。</p>
</li>
<li><p><strong>xsi:schemaLocation</strong></p>
<p>这个的意思是：xsi 的 schemaLocation 是什么，翻译之后的意思是：xml 文档结构的具体内容应该会存放在某个文件里，那么这个文件在哪里？</p>
<p>你去观察这行代码，发现在 <code>xsi:schemaLocation</code> 之后有两个 url 地址，而且第一个 url 地址，居然就是 xmlns 默认命名空间的指定地址。实际上，这两个 url 地址是以 key-value 的形式出现的，key 是该 xml 默认命名空间的值（那当然也就是 xmlns 所指定的那个 url 地址），value 是该 xml 文档结构文档的位置。</p>
<p>如果你打开后面那个 url 地址，你会真的看到一个文件，而且你单纯从格式上就能判断出来，这就是该 xml 文件的文档结构的具体内容。</p>
</li>
</ul>
<br>

<p>示例代码中，中间一共有六个配置项，逐一介绍：</p>
<ul>
<li><p><strong>modelVersion</strong></p>
<p>Maven 工程的模型版本，就目前而言只有一种参数可能：<code>4.0.0</code>。</p>
<p>但是即使如此，这一项也必须显式地配置出来，因为未来 Maven 可能会有更多的版本，例如 <code>4.0.1</code>、<code>5.0.0</code> 等等。到那时，如果遇到了没有配置模型版本的 xml 文件，将无法向前兼容。</p>
<br>
</li>
<li><p><strong>groupId</strong></p>
<p>公司或组织名称，是指本项目的归属人是谁。</p>
</li>
<li><p><strong>artifactId</strong></p>
<p>项目名称，例如一个公司有10个项目，各个项目相互区别就是通过这个 ID。</p>
<p>groupId 和 artifactId 两个 ID 一起构成了唯一索引，也就是说，一个 groupId 加上一个 artifactId，在这个世界上只能出现一次（除非是同一个项目的不同版本）。</p>
</li>
<li><p><strong>version</strong></p>
<p> 项目当前版本，格式为：主版本.次版本.增量版本-限定版本号。</p>
<p>限定版本号有两种：SNAPSHOT（快照）和  RELEASE（发布）。前者表示不稳定版本，可能会经常发生变化，后者是相对稳定的版本，版本不会频繁变动。</p>
<p>与 groupId 和 artifactId 联合构成 GAV，这三个值加在一起，可以精准地指向【一个特定版本的项目】。当别的项目要引入依赖，把别的项目加载进来时，必须指定这三个值。</p>
<br>
</li>
<li><p><strong>packaging</strong></p>
<p>项目打包之后的类型，有很多种，例如 jar、war、pom 等等，默认使用 jar（也就是说如果你不写这一行也可以，默认是 <code>&lt;packaging&gt;jar&lt;/packaging&gt;</code>）。</p>
<p>pom 类型是父 pom.xml 文件所使用的，比如有一个公共的 pom.xml 文件，其中配置了很多共性的配置，有四个子模块的 pom.xml 文件都可以直接引用该 pom.xml 文件，少配置一些内容。这个公共的 pom.xml 文件，就是父 pom 文件，它的构建类型就是 pom（即 <code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>）。</p>
</li>
<li><p><strong>name</strong></p>
<p>项目的名称，Maven 生成文档时用的。</p>
</li>
</ul>
<p>还有很多很多很多可以配置的地方，这里只介绍了一点点（但是足够日常使用了）。</p>
<h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><p>以这段代码为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 省略了一些必要配置，只保留了依赖配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段示例 xml 代码共引入了两个外部依赖，分别是 junit（测试单元）和 joda-time（一个很好用的第三方时间类）。</p>
<ul>
<li><p><strong>dependencies</strong></p>
<p>在 dependencies 内可以存放多个 dependency，表示项目所引入的所有依赖。Maven 将自动地去仓库里寻找依赖包，从本地开始找，没有就去仓库找，再没有就去远程仓库找，每次在仓库里找到了都会下载到本地。如果依赖之间有版本上的冲突，先根据依赖深度判决，深度相同再根据先来后到的原则判决。</p>
</li>
<li><p><strong>dependency</strong></p>
<p>一个依赖包，其中包括 groupId、artifactId、version 等标签。</p>
</li>
<li><p><strong>groupId</strong>、<strong>artifactId</strong>、<strong>version</strong></p>
<p>GAV 三参数，依赖包所必需的标签，通过这三个标签才能找到一个特定版本的依赖包。</p>
</li>
<li><p><strong>scope</strong></p>
<p>依赖作用的范围，例如值为 test 时表示，只会在测试时引用该依赖，正式的版本不会依赖。</p>
<p>共有种，分别是：compile（全程，默认配置）、provided（类似于全程，但打包期可以被替代）、test（测试）、runtime（除了编译的全程阶段）、system（类似于全程，但依赖从本地文件抓取）。</p>
</li>
<li><p>其他</p>
<p>在父 pom 文件中，还可以配置 dependencyManagement，用法上和 dependencies 类似，可以作为集中化的依赖配置中心，可以配置依赖的版本号、作用域等等，子 pom 文件如果声明了一个 dependency，并且只配置了 groupId、artifactId 这两个参数，其他参数就会从父 pom 文件的 dependencyManagement 里找。（当然，如果自己填了其他参数，会以子配置为准）</p>
</li>
</ul>
<h1 id="继承、聚合"><a href="#继承、聚合" class="headerlink" title="继承、聚合"></a>继承、聚合</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.app.pz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pz-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app-server<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>继承和聚合通常是对应存在的，父 pom 文件会标明聚合（modules）内容表示它的作用模块有哪些，子 pom 文件会标明继承（parent）内容，表示它继承自哪个 pom 文件。</p>
<ul>
<li><p><strong>parent</strong></p>
<p>parent 表示继承， 子 pom 可以使用 <code>parent</code> 指定父 pom。</p>
<p>parent 内需要明确写明的标签，依然是 GAV 三标签。</p>
</li>
<li><p><strong>modules</strong></p>
<p>modules 表示聚合，Java 的文件结构中，一个项目可以有多个模块，modules 内即是模块。</p>
<p>聚合内只需要放模块的名字即可。</p>
</li>
</ul>
<br>

<p>其他配置内容，例如 build、profile、plugin 等，用到再说吧。</p>
<hr>
<p>接下来看 Maven 的生命周期。</p>
<p>看了好多篇教程和博文，它们对 Maven 的生命周期的解释与描述，总让我觉得是相互冲突的，甚至在同一篇文章中都是冲突的。之后渐渐发现，原来 Maven 的生命周期并不只有一个，而是有三个，分别是 clean、default（or build）、site。也就是说“Maven 的生命周期”这种说法是不正确的，Maven 本身并没有生命周期，而应该是 Maven 的 <code>clean 生命周期</code>、<code>default 生命周期</code>、<code>site 生命周期</code>。再换句话说，“生命周期”这四个字，描述的不是 Maven，而是那三个词。</p>
<p>生命周期这个说法，在编程中是一个非常常见的概念。我觉得 Maven 在这里也使用生命周期这个词，是为了表达【阶段性】的概念。我以人为例，人的生命周期是 幼年 -&gt; 青年 -&gt; 中年 -&gt; 老年，那么当人值中年时，必定已经经历了幼年和青年。Maven 的三个生命周期，各自都有一些阶段，你可以不执行完全部的生命周期，可以只执行到中间的某个阶段，但是当你执行到这个阶段时，你一定已经执行完，在这之前的所有阶段了。</p>
<p>以下的内容主要参考来源为：<a href="https://www.runoob.com/maven/maven-build-life-cycle.html" target="_blank" rel="noopener">《Maven 构建生命周期》</a>。</p>
<h1 id="clean-生命周期"><a href="#clean-生命周期" class="headerlink" title="clean 生命周期"></a>clean 生命周期</h1><p>clean 生命周期包含三个阶段：</p>
<ul>
<li>pre-clean：执行一些需要在 clean 之前完成的工作</li>
<li>clean： 移除所有上一次构建生成的文件</li>
<li>post-clean：执行一些需要在 clean 之后立刻完成的工作</li>
</ul>
<p>这三个阶段，如果使用命令行执行的话，那么是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn pre-clean</span><br><span class="line"></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line">mvn post-clean</span><br></pre></td></tr></table></figure>

<p>再提一遍，下文不再提了。当执行 <code>mvn clean</code> 语句时，表示执行 pre-clean 阶段和 clean 阶段。当执行 <code>mvn post-clean</code> 语句时，表示执行 pre-clean 阶段、clean 阶段和 post-clean 阶段。总之，之前的阶段，全部执行。</p>
<p>具体的执行过程、原理，不叙。</p>
<h1 id="default-生命周期"><a href="#default-生命周期" class="headerlink" title="default 生命周期"></a>default 生命周期</h1><p>你光看 default 这个词就能看出来，这是 Maven 最重要的那个生命周期。这是 Maven 的构建生命周期，项目的编译、测试、打包、部署等等，都属于这个生命周期的范围。</p>
<p>default 生命周期共有 23 个阶段，其中重要的阶段是：</p>
<ul>
<li>validate：验证项目是否正确且所有必须信息是可用的</li>
<li>compile：编译代码</li>
<li>test：运行测试（例如 JUnit 单元）</li>
<li>package：打包，创建 jar 包、war 包等等</li>
<li>verify：对测试结果进行检查</li>
<li>install：把打包的内容安装到本地仓库中</li>
<li>deploy：把打包的内容部署到远程仓库中</li>
</ul>
<h1 id="site-生命周期"><a href="#site-生命周期" class="headerlink" title="site 生命周期"></a>site 生命周期</h1><p>site 生命周期用于创建报告文档、部署站点等等，包括以下四个阶段：</p>
<ul>
<li>pre-site：执行一些需要在生成站点文档之前完成的工作</li>
<li>site：生成项目的站点文档</li>
<li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>
<li>site-deploy：将生成的站点文档部署到特定的服务器上</li>
</ul>
<hr>
<p>本来还想写写 Maven 的插件，哎懒了，反正大概就是在执行生命周期的某个阶段，打开 IDE 一般都会默认集成一些 Maven 的插件，可以不用自己写指令了。</p>
<p>这篇就写到这里叭。</p>
<br>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/04/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<br>

<p>从本周开始，新增一个博文模块 <code>Random Post</code>，用于不定期的学习与整理，原本的每周博文 <code>Weekly Post</code> 仍是主要更新计划（名为每周实则随缘hhh），当每周时间有余，或者不屑于将学习内容作为周计划时，在此更新。</p>
<p>本篇是该模块的第一篇文章，学习单例模式。我在随缘学习单例模式时，发现这种设计模式的水很深，不是 Java 初学人员能够完全理解的，涉及到并发基础、类加载过程、枚举设计等内容，因此来写篇文章整理一下。</p>
<p>本文主要参考自博文<a href="https://www.javadoop.com/post/design-pattern#toc_4" target="_blank" rel="noopener">《设计模式也可以这么简单》</a>的单例模式部分。</p>
<hr>
<p>单例模式，GOF 分类下（最常见的那种分类）的 23 种设计模式之一，创建型模式中的一种，面试常备题目之一。</p>
<p>单例模式的意思是，类必须保证只有一个实例存在，整个系统，所有线程，可以有并且最多只能有一个该类的对象，这是一个针对于整个程序而言的全局对象。通常的实现思路是，该类提供一个静态的获取实例对象的方法（方法名通常为 getInstance），并且将构造函数定义为私有方法（这样就不能 new 对象出来了）。</p>
<p>单例模式有多种实现方式，常见的有四种，分别是饿汉模式、懒汉模式、嵌套类、枚举。</p>
<h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>饿汉模式（Eager Initialization）和懒汉模式（Lazy Initialization），这两个名字的翻译，让我觉得早期的程序员都是上海电影译制厂的配音演员退休转业来的，硬是拉大了本就已经存在的文化代沟，垃圾翻译。</p>
<ul>
<li><p>饿汉模式的意思是，不管是否使用都抢着在第一时间加载。</p>
</li>
<li><p>懒汉模式的意思是，什么时候要用了，什么时候再加载。</p>
</li>
</ul>
<p>厘清两汉区别之后，我们先来看饿汉模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先，将构造函数定义为私有方法，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（以下内容基本来源于《深入理解 Java 虚拟机》第七章，但可能因为我自身理解不足导致有错误）</p>
<p>饿汉模式创建对象的时机，是在类加载过程中，当类加载完成之后，无论是否需要，此时单例对象都已经被创建了。饿汉模式实现单例模式要靠 static 关键字，而理解 static 关键字需要了解类加载机制。</p>
<p><img src="/assets/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="类的生命周期"></p>
<p>一个类的生命周期有七个阶段，如上图，其中前五个阶段是类加载的过程，分别是：</p>
<ul>
<li>加载（Loading）</li>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化（Initialization）</li>
</ul>
<p>中间三个阶段又可以统称为连接（Linking）阶段。</p>
<p>以上五个类加载阶段基本上交由 Java 虚拟机主导控制，而不是由业务程序去控制。</p>
<p>对于小白而言，一个很反直觉的地方在于，类加载过程（即上面的五个阶段），并不是在编译期执行完成的，而是在程序的运行期间完成的，如果类没有被用到，那么类就不会被加载，如果用到了就在程序运行过程中现场加载。这种设计为 Java 提供了极高的扩展性和动态连接性，当程序运行之后，仍然可以在不停机的情况下输入新的类，比如从网络上加载一段二进制流作为程序的一部分。</p>
<p>Java 虚拟机规范中，对于类加载过程的约束是相当宽容的，这使得不同的 Java 虚拟机可以按照编写人员自己的想法来设计。比如对于不同的 Java 虚拟机而言，最开始的加载阶段需要在什么时候完成，随便你，各个阶段能否交叉混合执行，随便你，各个阶段具体要做什么事情，（在保证一定前提下）随便你。当然还是有一些限制，在这里需要指出的有两点：</p>
<ol>
<li><p>加载、验证、准备、初始化这四个阶段（即除了解析之外的类加载阶段），开始执行的顺序必须如图依次开始（但是允许上一个阶段没执行完，下一个阶段就已经开始）。</p>
</li>
<li><p>明确地说明了，初始化阶段的执行时机，并且是有且仅有这些场景下，Java 虚拟机需要立即执行初始化过程。场景还是挺多的，就不一一列举了，其中包括：</p>
<ul>
<li>使用 new 关键字实例化对象的时候</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
<p>这也隐性地规定了，在这些场景之下，加载、验证、准备这三个阶段也已经开始执行（因为要按顺序开始）。</p>
</li>
</ol>
<p>因此，当 new 一个对象，或者调用一个对象的静态方法时（正如饿汉模式示例代码中的 <code>getInstance()</code> 方法），类加载过程一定会被执行，且执行完毕。</p>
<br>

<p>简单地描述一下，各个阶段分别在做什么事情：</p>
<ul>
<li>加载：获取类的二进制字节流，并存储在方法区中（存储格式由 JVM 自行决定）</li>
<li>验证：确保二进制字节流格式等合规</li>
<li>准备：为静态变量（被 static 修饰的变量）分配空间并设置初始值（请注意是初始值，比如 int 类型设为 0）</li>
<li>解析：（没懂）将常量池内的符号引用替换为直接引用</li>
<li>初始化：执行类构造器 <code>&lt;clinit&gt;()</code> 方法，该方法执行类变量的赋值动作、并执行 static 块中的内容。该方法在多线程环境下会被加锁同步执行，确保多线程环境下类只会被加载一次。</li>
</ul>
<p>总结一下，饿汉模式创建对象实例，会在准备阶段分配出空间，并在初始化阶段进行真正的赋值，这一切都发生在类加载过程中，当类加载阶段结束之后，饿汉模式的单例就已经被创建出来了。</p>
<br>

<p>如果要给饿汉模式一个缺点，那么如果该类里面有一个静态方法，执行该类的静态方法，就会触发初始化阶段，从而导致该类的单例对象也会被一同创建，浪费了性能和空间。（但是我觉得，生产中似乎没有这种可能吧，通过饿汉模式写了一个类，不要该类的实例对象，反而只调用该类的一个静态方法，这么任性吗？）</p>
<hr>
<h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><p>懒汉模式（也有叫饱汉模式的，都是垃圾翻译）有多种实现代码，这主要是因为懒汉模式的创建逻辑是懒加载，当程序需要单例对象时才创建，而创建的过程中有并发风险，为了处理并发风险，就出现了多种处理方式。</p>
<p>我在这里不循序渐进地写多套代码，直接把最好的一种复制如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉模式需要对并发、Java 的内存模型有一定认识，主要是要理解 volatile 关键字，这里只解释 volatile 的作用。</p>
<p>volatile 关键字主要实现两方面的作用：内存可见性、禁止重排序，懒汉模式使用 volatile 修饰单例对象，是用到了第二个特性，禁止指令重排序。但我们还是按顺序说，先讲内存可见性。</p>
<ol>
<li><p>内存可见性</p>
<p>内存可见性的问题，指的是如果多条线程同时操作资源，这边改变了数据，另一边能否及时知道数据发生了改变。</p>
<p>共享变量的可见性问题，不是由于多核导致的，而是由于多缓存导致的，所有的共享变量都存储在主内存中，每个线程也有自己独自的本地内存，这种设计能够加快运算速度，但导致了内存可见性的问题。</p>
<p>学习内存可见性应当去学习 Java 内存模型，这里分享一篇博文<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e5%8d%81%e3%80%81java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">《Java 并发 - Java 内存模型》</a>。</p>
</li>
<li><p>禁止重排序</p>
<p>为了运行更快，编译器、CPU、内存系统都进行了重排序，下列三行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;      <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;      <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> sum = i + j; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>从代码上看，执行顺序应该是 1 2 3，但是实际的执行顺序有可能是 2 1 3。</p>
<p>我原来一直不理解重排序有什么影响，后来我才明白：对于单线程而言确实是没有影响，即使重排序了，实际的执行逻辑也不会有变化，但是多线程情况下就不一定了，当存在数据竞争的情况时，重排序可能会导致违反直觉的现象发生。</p>
<p>这里就以懒汉模式为例，说明如果发生重排序，可能会发生什么问题：</p>
<p>在 synchronized 代码块中，<code>instance = new Singleton();</code> 这行实例化对象的代码，可以拆分成三个指令（可参考《Java 并发编程的艺术》）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1. 分配内存 相当于c的malloc</span></span><br><span class="line">ctorInstanc(memory);  <span class="comment">// 2. 初始化对象</span></span><br><span class="line">s = memory;           <span class="comment">// 3. 设置s指向刚分配的地址</span></span><br></pre></td></tr></table></figure>

<p>new 对象的过程可以拆解为：</p>
<ul>
<li>首先 JVM 将申请一块空间（1）</li>
<li>然后执行构造方法为属性赋值（2）</li>
<li>最后让对象指向刚刚分配好的地址（3）。</li>
</ul>
<p>如果发生指令重排序，那么 new 对象的过程就有可能变成：</p>
<ul>
<li>首先 JVM 将申请一块空间（1）</li>
<li>让对象指向刚刚分配好的地址（3）</li>
<li>执行构造方法为属性赋值（2）</li>
</ul>
<p>如果只有一条线程则没问题，但出现了另一条线程，执行 getInstance() 方法时，先检查单例对象 instance 是否为空（<code>if (instance == null)</code>），完全有可能检查到 instance 不为空（因为已经指向了刚刚分配好的地址），但是 instance 还没有执行完构造方法，最终拿到了一个没真正创建完毕的对象。</p>
<br>

<p>volatile 关键字实现的第二个作用，就是禁止指令重排序。（顺便一提，不光是禁止两个被 volatile 修饰的属性，在操作上不能重排序，而且被 volatile 修饰的属性，和它周围的普通属性的相关操作都不能重排序）。</p>
<p>被 volatile 修饰的单例对象，将严格按照指令顺序被创建，因此不存在问题。</p>
</li>
</ol>
<br>

<hr>
<h1 id="嵌套类方式"><a href="#嵌套类方式" class="headerlink" title="嵌套类方式"></a>嵌套类方式</h1><p>先看代码吧，然后再解释一下嵌套类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，还是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先解释一下嵌套类是什么。</p>
<p>Java 中，类的内部也可以有类，这种情况被称为嵌套类（nested class），嵌套类分为两种，分别是静态嵌套类（static nested class）和内部类（inner class）。</p>
<p>我认为，这里要从文法的角度上琢磨一下语义，请注意，Java 中把类中有类的现象称为嵌套类，嵌套是一种位置性的描述词语，只是在描述两个类的位置关系，并没有从属关系。也就是说，两个类是嵌套关系，并不能认为其中一个类归属于另一个类，而只是从位置上来讲，一个类出现在了另一个类的里面，但是是否有从属关系，这个不好说。嵌套类中有一种情况是内部类，内部（inner）就有一定的归属关系了，如果一个类是另一个类的内部类，就说明这个类是归属于另一个类，是任另一个类操纵的。</p>
<p>我认为这种文法上的理解是很有必要的，对于访问权限、类加载时机等等的理解都是有帮助的。</p>
<p>Java 从语言语法上对嵌套类的区分，是判断有没有 static 关键字：</p>
<ul>
<li><p>静态嵌套类（static nested class），有 static 修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有static -&gt; 静态嵌套类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类（inner classer），没有 static 修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有static -&gt; 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类还可以再细分为三种，主要是在访问权限上的区别，这里为了主干清晰，就不介绍了。</p>
</li>
</ul>
<p>在民间叫法上，往往把这两种情况都称为“内部类”，因为从直观的角度上看，这两种好像都是“类中类”，感觉都是内部的，因此民间往往把带有 static 关键字的称为静态内部类（也就是官方说的静态嵌套类），而把没有 static 关键字的称为内部类。这种叫法非常广泛，也有一定的道理，但我觉得这种叫法会模糊意义，具有迷惑性，最好不要这么称呼。</p>
<p>还有一种民间声音，把静态嵌套类直接称为嵌套类，也就是说”类中类“分为两种，分别是嵌套类和内部类，这种叫法很坚决地表明了区别，我觉得还有点道理。</p>
<p>下图是几种称呼的示意图：</p>
<p><img src="/assets/%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E7%A7%B0%E5%91%BC.jpg" alt="嵌套类的称呼"></p>
<p>这里的单例模式，是通过静态嵌套类来实现的，接下来讨论一下原理。</p>
<p>从语法层面，静态嵌套类和内部类的区别，在于类是否被 static 修饰，然后根据 static 访问权限划分出了不同的用法，例如“static 语句块中不能使用 non- static 语句”、“内部类不能有 static 变量”、“static 的类加载时机不同”等等的问题。</p>
<p>通过语法进行解释这两种类型的区别，当然是可以的，但如果揣摩为什么这么设计的原因，应该会更易理解和记忆很多。静态嵌套类和内部类的区别，从 Java 设计的角度上讲，是跟外部类的关系是不一样的：静态嵌套类跟外部类可以说是没什么关系（除了位置特殊了些），但是内部类要依赖于外部类，它可以视为外部类的一个成员。</p>
<ul>
<li><p>静态嵌套类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以认为，A 类（外部类）和 B 类（静态嵌套类）是没有关系的，这里的没有关系体现在：</p>
<ul>
<li>不需要实例化 A 类出来，就可以实例化 B 类</li>
<li>B 类不能直接访问 A 类的非静态变量（只能直接访问 A 类的静态变量，即类变量，访问类变量是不需要先获取对象的）</li>
<li>A 类和 B 类的类加载时间没有关系，如果完全可以 A 类加载了，但是 B 类还没有加载（这是实现单例模式的核心）</li>
</ul>
<p>值得一提的是，静态嵌套类是可以用 private、protected、public 修饰的，指的是访问它的权限，比如如果是 public 的话，那么所有地方都可以访问该静态嵌套类，但是如果是 private 修饰的话，只有外部类可以访问静态嵌套类。</p>
</li>
<li><p>内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 A 类（外部类）和 C 类（内部类）之间是有关系的，这种关系大概像是“A 有一个成员变量 C”，具体体现在：</p>
<ul>
<li>A 类没有实例化出来之前，C 类不能创建，就像是一个对象成员变量一样</li>
<li>C 类可以访问 A 类的所有变量，无论是否是静态变量</li>
<li>C 类可以自定义变量，但是不能有自己的静态变量（因为没有必要，这里可以自己多想一下）</li>
</ul>
</li>
</ul>
<br>

<p>我们来回头看一下这里单例模式的实现。</p>
<p>外部类中套一个静态嵌套类，外部类进行类加载时，静态嵌套类并没有加载，而当调用了外部类的 <code>getInstance()</code> 方法之后，该方法会触发静态嵌套类进行类加载（这里跟饿汉模式是一样的原理），然后实例化出来想要的单例。</p>
<p>因此通过嵌套类实现单例模式，实际上就是饿汉模式的一种特殊使用方法，通过类套类的方式，延时加载了饿汉模式。这是最方便实用的一种单例模式。</p>
<br>

<hr>
<h1 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，还是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举创建单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">        SingletonEnum() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外暴露的获取单例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式怎么说呢，人人都夸，人人都不用hhh</p>
<p>简单的讲，枚举类会在类加载时，初始化所有实例，由 JVM 保证它们不会再被实例化，天生就实现了单例模式。</p>
<p>（以下内容来源自知乎文章<a href="https://zhuanlan.zhihu.com/p/55327937" target="_blank" rel="noopener">《枚举的本质》</a>，建议直接阅读）</p>
<p>在类加载过程中，枚举中定义的枚举值，实际上是一个个的 <code>static final</code> 的变量，并且会被直接赋值，不存在再次被实例化的可能。</p>
<p>下面写一段很简单的枚举代码，定义了一个水果的枚举类，并且规定有一个金额的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Fruit &#123;</span><br><span class="line">    </span><br><span class="line">    APPLE(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    Noodle(<span class="keyword">int</span> money)&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码经过反编译之后，可以等效为如下代码（经过了删减）：</p>
<p>可以看出，枚举值实际上是一个静态的 final 变量，并且会在类加载的过程中就被赋值（static 代码块中的内容会在类加载过程中被执行），因此保证了单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit APPLE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Fruit</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        code = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        APPLE = <span class="keyword">new</span> Fruit(<span class="string">"APPLE"</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多说一点有关枚举的知识点：</p>
<ul>
<li>枚举类实际上继承自 Enum 类（参照上面的反编译代码），因此枚举类均不能继承（因为 Java 单继承）</li>
<li>枚举类默认有两个成员变量（可以自行增加更多的），分别是 <code>name</code> 和 <code>ordinal</code>，代表枚举值的名字和顺序，<code>toString()</code> 方法重写为返回 <code>name</code>。</li>
<li>枚举值使用 <code>==</code> 和 <code>equals()</code> 进行比较，作用是相同的，枚举类的 <code>equals()</code> 经过重写，实际上就是 <code>==</code>，其含义是比较内存地址（由于天生单例，所以通过地址就可以判断是否是同一个）</li>
<li>枚举不允许克隆和反序列化，永远保证单例（因此很安全）</li>
<li>枚举类有两个方法：<code>values()</code> 返回所有枚举值、<code>valueOf()</code> 根据 <code>name</code> 返回枚举值。</li>
</ul>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的大小</title>
    <url>/2020/03/08/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<br>

<p>一晃都三月了，过了一个很古早的冬天呐。</p>
<p>冬眠回来，三月的第二周，来看 Java 对象的内存设计，这部分的学习是为之后学习 synchronized 关键字铺路的。本来想在学习锁时顺便提一嘴写完它，结果发现这坑有点大，还是要单独学。</p>
<br>

<p>我们这周学习的目的，是搞清楚存储在内存中的对象，它具体是如何存储的，存储时都需要存哪些信息，以及存这些信息的意义是什么。</p>
<p>比如看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList;</span><br><span class="line">list.add(<span class="string">"hello, world!"</span>);</span><br></pre></td></tr></table></figure>

<p>上面这两行代码当中的 <code>list</code> 对象是如何存储起来的。</p>
<hr>
<p>要学习对象是怎么存储在内存当中的，就要从很原始的地方说起，先学习 JVM 的内存结构。</p>
<p>这一块我是真的很欠缺，只知道一点基础的概念，我只把本次要用到的知识写在这里，其他的知识我还要慢慢学。有关 JVM 的内存结构，我学习的起点是<a href="https://www.bilibili.com/video/av62009886" target="_blank" rel="noopener">《【java】jvm内存模型全面解析》</a>视频，很推荐一看。</p>
<p>JVM 在运行 Java 程序时，会管理一块内存区域，这一片区域被称为<code>运行时数据区域</code>，从结构上可以分为五个部分，分别是：</p>
<ul>
<li><code>Java 虚拟机栈</code>：线程私有，存储局部变量等</li>
<li><code>本地方法栈</code>：线程私有，存储本地方法的变量等</li>
<li><code>程序计数器</code>：线程私有，存储字节码的地址（程序执行到第几行了）</li>
<li><code>堆</code>：线程共享，存储几乎所有对象</li>
<li><code>方法区</code>：线程共享，存储类的结构信息（字段、构造方法等等）</li>
</ul>
<p>（下图来源自<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">《CYC - Java 虚拟机 - 运行时数据区域》</a>，其内容整理非常值得反复阅读)</p>
<p><img src="/assets/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM内存结构"></p>
<p>我们今天要说的，只是<code>栈</code>和<code>堆</code>（栈指的是 Java 虚拟机栈）。非常浅薄地讲，<code>栈</code>存放的是局部变量以及对象的地址，<code>堆</code>存放的是对象的实体。（看书发现，栈中存放的并不一定是对象地址，但这是最常见的寻找堆对象的方式）</p>
<p>简单制作了一张图，描述了代码、栈、堆之间的关系。</p>
<p><img src="/assets/JVM%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1.jpg" alt="JVM内存存储对象"></p>
<br>

<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>内存结构和内存模型并不是一个概念：</p>
<p>当我们说内存结构时，通常是指<code>JVM 内存结构</code>，这是真实存在的，指的是上文介绍的 Java 虚拟机栈、堆、本地方法栈等等那五部分构成的 JVM 运行时数据区域，这是在<code>结构</code>上把 JVM 的内存分成了多个部分。</p>
<p>当我们说内存模型时，通常是指<code>Java 内存模型</code>，这是虚拟存在的，指的是面对并发时 Java 是如何实现内存访问一致的，牵扯到了主内存和工作内存等知识，这是在<code>模型</code>和概念上，屏蔽各种硬件和操作系统的内存访问差异，来实现并发内存一致性。</p>
<br>

<hr>
<p>简单说完了对象存放的位置，那么接下来就要进入这周学习的重点了：如何计算对象的大小。这个问题实际上可以拆成两个问题：</p>
<ol>
<li>对象由哪些部分组成？</li>
<li>每部分各占多少字节？</li>
</ol>
<p>在这两个问题的基础上，自然会问出第三个问题：</p>
<ol start="3">
<li>组成对象的这些基础部分，各自是做什么的？</li>
</ol>
<p>PS：在看书的时候，发现自己所学习对象大小的这部分知识，实际上是 HotSpot 虚拟机的实现，而并非所有 Java 虚拟机的实现，但是目前基本上所有的 Java 程序都跑在 HostSpot 虚拟机上面。</p>
<br>

<p>所有对象都可以笼统地切分成两部分：<code>对象头</code>（Header）和<code>对象内容</code>（Instance Data）。</p>
<p>举一个实际的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这个 Person 类，它实例化出来的对象同样具有对象头和对象内容两部分，<code>name</code> 和 <code>age</code> 都是对象的内部变量，属于对象内容，而对象头是其余一些辅助信息。</p>
<br>

<p>我绘制了一张图，画出了在最常见情况下（64 位虚拟机开启指针压缩），对象在内存中的结构，后文都是在解释这个结构的具体信息。</p>
<p><img src="/assets/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg" alt="对象头"></p>
<h1 id="对象内容"><a href="#对象内容" class="headerlink" title="对象内容"></a>对象内容</h1><p>对象内容准确地讲应该叫做实例数据（Instance Data），比较简单，因此我们先讲完。</p>
<p>正如之前提到的 Person 对象的例子，对象内的属性（包括基本数据类型 <code>int age</code> 和引用的另一个对象 <code>String name</code>），这些属性所占的内容大小，就是对象内容的大小。在该例子中，int 类型的 <code>age</code> 占 4 个字节（即 32 位），引用另一个对象时，存储的是对象的地址，地址是一个 int 类型的指针，因此 String 类型的 <code>name</code> 存储在 Person 对象中也占 4 个字节（即 32 位），两个属性加起来一共占 8 个字节。</p>
<p>因此计算对象内容的大小，实际上就是分两部分，基本数据类型一类，占内容大小加起来，引用别的对象占一类，引用一个就是 4 字节（int 的大小），引用 N 个对象就占 N*4 个字节。</p>
<p>下面列举了 8 种基本数据类型的大小。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>2（表示一个 UTF-16be 编码单元，<a href="https://colobu.com/2019/01/04/how-many-charactors-in-a-java-string/" target="_blank" rel="noopener">生僻字用两个char</a>）</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>flote</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>boolean</td>
<td>通常是1</td>
</tr>
</tbody></table>
<p>此外还要注意的一点是，如果 A 类继承自 B 类，那么计算 A 类的对象内容大小时，继承来的 B 类的属性也是要算在内的。比如计算 ArrayList 对象大小的时候，它的父类 AbstractList 中的属性，也是要计算在内的。</p>
<br>

<h1 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h1><p>对象头（Header）比较复杂，它包含着对象的“冗余信息”，这些信息或实现并发锁，或帮助垃圾分类，或包含类的信息。</p>
<p>从整体上看，对象头包含三部分的信息，分别是</p>
<ul>
<li>标记字段</li>
<li>地址</li>
<li>数组长度</li>
</ul>
<h2 id="标记字段"><a href="#标记字段" class="headerlink" title="标记字段"></a>标记字段</h2><p>标记字段（Mark Word）是对象头中最复杂的内容，需要对照上面绘制的图来看。</p>
<p>由于内存空间寸土寸金，在希望对象能够记录更多信息的同时，还要尽可能地压缩空间，在这种背景之下，32 位虚拟机的对象标记字段长 4 字节，64 位虚拟机的对象标记字段长 8 字节（现在基本都是 64 位了吧），并且都有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据。32 位和 64 位的存储长度不同，仅仅是因为地址指针长度引起的变化，在存储的内容类型方面没有区别。</p>
<p>（具体的标记字段信息可见文末的备注）</p>
<p>以我当下的理解，标记字段主要实现了三个事情：</p>
<ol>
<li>对并发情况下的 synchronized 支持</li>
<li>GC 垃圾回收</li>
<li>保存 hashcode</li>
</ol>
<p>标记字段共有五种状态，分别是对应于 synchronized 的四种状态（无锁、偏向锁、轻量级锁和重量级锁），以及一种 GC 状态，这五种状态通过 2 位标志位实现（无锁和偏向锁的标志位相同）。</p>
<p>因此，了解标记字段的具体信息，实际上就是在了解 synchronized 锁和垃圾回收的原理。这两部分都有点难，本文暂时不讨论了，有关 synchronized 的信息可以参考这篇文章<a href="https://www.itqiankun.com/article/bias-lightweight-synchronized-lock" target="_blank" rel="noopener">《彻底搞懂 Java 中的偏向锁，轻量级锁，重量级锁》</a>。</p>
<h2 id="地址信息"><a href="#地址信息" class="headerlink" title="地址信息"></a>地址信息</h2><p>对象头中有一部分是地址信息，它实际上是一个类型指针，指向了该对象类型的地址。</p>
<p>例如 person 对象的对象头中的地址信息，指向了 Person 类的地址（类在方法区）。</p>
<p>在这种设计下，可以通过对象找到类，比如在 main() 方法中实例化一个 Person 对象 person，在内存中寻址的过程为：</p>
<ol>
<li>main() 方法的 Java 栈中记录着 person 对象的地址，</li>
<li>根据这个地址在堆中找到了 person 对象，</li>
<li>person 对象的头部又记录着 Person 类的地址，根据这个地址在方法区中找到了 Person 类。</li>
</ol>
<p>（实际上，在对象的头部中保留类的地址信息，通过对象找到类的位置，这种设计是 HotSpot 虚拟机的设计，也有别的虚拟机不这么设计，对象头中并不包含类的地址，不通过对象找类。）</p>
<p>地址信息的大小并不是固定的，这跟系统位数有关，32 位的虚拟机，指针是 32 位长，地址信息只需要 32 （即 4 字节），但是对于 64 位的虚拟机，指针是 64 位长，因此地址信息也需要扩增到 64 位（即 8 字节）。</p>
<p>32 位的虚拟机，理论上只能寻址到 4 GB 的内存空间（2^32 byte = 4 GB），而 64 位的虚拟机能寻址到更多地址。这样的提升是有代价的，一方面内存占用量变大了，原来只需要 4 个字节存储一个地址，现在需要 8 个字节了（如果不需要比 4GB 更多的内存，用这么大的空间是没有意义的），另一方面寻址时操作位数更长的指针，主内存和各级缓存移动数据时，占用的带宽也会增加。</p>
<p>Java 虚拟机为了处理这个问题，提出了<strong>指针压缩</strong>。</p>
<p>指针压缩的简易原理是这样的：32 位的指针，当然只能找到 4 GB 个内存位置，如果我有一块更大的内存区域，比如 10 GB，32 位的指针就不能指向这 10 GB 中的所有位置，但实际上并不需要找到这块内存中的所有位置，它只需要找到要操作的开始位置就可以了。<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html" target="_blank" rel="noopener">这意味着 32 位的指针可以引用 40 亿个对象，而不是 40 亿个字节。</a>Java 对象的大小如果一定是 8 字节的整数倍（这个后文有讲），那么就可以使原来只能寻址 4 GB 的内存扩大 8 倍，到 32 GB 的内存。</p>
<p>因此对于分配内存低于 4 GB 的虚拟机，默认开启指针压缩，指针大小就是 32 位长，对于分配内存在 4 - 32 GB 之间的虚拟机，可以开启指针压缩算法，使指针大小依旧维持在 32 位长，但是对于更大的内存，无法开启指针压缩，指针大小必须是 64 位长。（因此分配内存并不是越大越好，32 GB 处会有一个门槛）</p>
<p>指针压缩并非毫无缺陷，这毕竟是多出来的算法，会增加 JVM 的计算量。</p>
<p>总结：对象头中的地址信息大小，跟系统位数以及是否开启指针压缩有关，<code>32 位系统</code>、<code>开启了指针压缩的 64 位系统</code>的地址信息长 4 字节，<code>普通 64 位系统</code>的地址信息长 8 字节。</p>
<h2 id="数组大小"><a href="#数组大小" class="headerlink" title="数组大小"></a>数组大小</h2><p>数组大小并不是必须的，数组才有，非数组没有。</p>
<p>因为数组是 new 出来的，需要在堆上分配内存，在这个意义上讲，数组就是对象的一种。数组的长度是需要记录下来的，长度为 4 字节。</p>
<p>int 也是 4 字节，这就很容易让人联想在一起。Java 中 int 是有符号整型数，是有负值的，int 的最大值是 2^31 - 1，用二进制表示为 01111111111111111111111111111111。数组的理论最大长度，也应该是 int 的最大值。</p>
<p>实际的使用中可能会小一点。例如 ArrayList 内部维护的数组，它的最大长度是 <code>Integer.MAX_VALUE - 8</code>，注释称这是因为虚拟机的限制。又例如 HashMap 内部维护的数组，它的最大程度是 <code>1 &lt;&lt; 30</code>，这是 1 位运算之后能获得到的最大值（二进制为 01000000000000000000000000000000）。</p>
<br>

<h1 id="（还有一点需要提及）"><a href="#（还有一点需要提及）" class="headerlink" title="（还有一点需要提及）"></a>（还有一点需要提及）</h1><p>在计算完对象头和对象内容的大小之后，二者加起来并不一定是最终占内存的大小，还要考虑内存对齐的问题。</p>
<p>所有对象的字节大小，必须是 8 的整数倍，如果对象头+对象内容算出来是 15 字节，那么最终对象大小为 16 字节，如果是 20 字节，那么最终对象大小是 24 字节，总之如果不满 8 的整数倍，都填充到 8 的整数倍，填充的部分叫做<code>对齐填充</code>（Padding），实际上就是占位符。</p>
<p>对齐填充的原因在于，HotSpot 虚拟机的自动内存管理系统，要求对象的起始地址必须是 8 字节的整数倍（这样寻址更高效，而且实现了指针压缩），因此对象的大小也就必须是 8 字节的整数倍。</p>
<br>

<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>在博文<a href="http://blog.kail.xyz/post/2018-08-01/java/java-object-header_and_lock.html" target="_blank" rel="noopener">《Java Object Header 和 锁》</a>中找到了三种情况（32 位虚拟机、64 位虚拟机、64 位虚拟机开启指针压缩）下，对象头的具体存储内容，这部分内容比较难找到，备注如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位</span><br><span class="line">|----------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                    Object Header (64 bits)                             |        State       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|                  Mark Word (32 bits)                  |      Klass Word (32 bits)      |                    |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       Normal       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       Biased       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|               ptr_to_lock_record:30          | lock:2 |      OOP to metadata object    | Lightweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|               ptr_to_heavyweight_monitor:30  | lock:2 |      OOP to metadata object    | Heavyweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|                                              | lock:2 |      OOP to metadata object    |    Marked for GC   |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">64位</span><br><span class="line">|------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (128 bits)                                        |        State       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                         |    Klass Word (64 bits)     |                    |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                       ptr_to_lock_record:62                         | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor:62                   | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                     | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">64位（开启指针压缩）</span><br><span class="line">|--------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (96 bits)                                           |        State       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                           |    Klass Word (32 bits)     |                    |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                         ptr_to_lock_record                            | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor                        | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                       | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<br>

<hr>
<p>最后用一个例子检验上文中的内容，计算一个 HashMap 对象的大小。</p>
<p>HashMap 类不是数组，在 64 位开启指针压缩的情况下，对象头只包括 8 字节的标记字段和 4 字节的地址指针，总共 12 字节。</p>
<p>HashMap 类中分别有下列属性：</p>
<ul>
<li>entrySet （对象）</li>
<li>hashSeed （int）</li>
<li>loadFactor （float）</li>
<li>modCount （int）</li>
<li>size （int）</li>
<li>table （数组，当对象处理）</li>
<li>threshold （int）</li>
</ul>
<p>检查 HashMap 的所有父类，在 AbstractMap 中发现了两个新的属性：</p>
<ul>
<li>keySet （对象）</li>
<li>values （对象）</li>
</ul>
<p>算下来一共是 9 个属性，每个属性很巧都是 4 字节，一共是 9×4 = 36 字节，因此 HashMap 的对象内容为 36 字节。</p>
<p>HashMap 对象的对象头 12 字节 + 对象内容 36 字节总共是 48 字节，是 8 字节的倍数，无需对齐填充。</p>
<p>因此一个 HashMap 对象的大小是 48 字节。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>各容器迭代器的实现</title>
    <url>/2019/12/08/%E5%90%84%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<br>

<p>十二月的第二周，来学习迭代器在各个容器中的具体实现。</p>
<p>不知道自己能看多少，ArrayList 和 HashSet 的实现是应该必须看完的，如果时间有余也要看看 TreeSet 的实现（哈哈哈……不相信自己的苍白的微笑）。</p>
<p>这周的目标应该不是在迭代器上，而是在容器设计和怎么看源码这两件事上。迭代器是因和果，但从因走到果的那条路是更有价值的。</p>
<hr>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList 是可调整大小的 List，实现了两种迭代器：迭代器、列表迭代器。</p>
<p>列表迭代器是在原本迭代器的基础上增加了顺序，例如增加了<code>是否有前一个元素</code>、<code>下一个元素的坐标</code>等方法。</p>
<p>我在这里只关注 ArrayList 实现的普通迭代器。</p>
<br>

<p>获取 ArrayList 的迭代器，与其他容器的方式一样，都是调用 <code>Iterator()</code> 方法，获得一个迭代器。（这里迭代器支持泛型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; iterator = arrayList.iterator();</span><br></pre></td></tr></table></figure>

<p>公共方法 <code>Iterator()</code>，返回了一个 ArrayList 类内部实现的迭代器 <code>Itr</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Itr类的内部实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们要关注的就是 <code>Itr</code> 类内部是怎么实现的。</p>
<br>

<p>ArrayList 的迭代器，<code>Itr</code> 类的基本骨架是这样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还有其他两个方法</span></span><br><span class="line">    <span class="comment">// 包括jdk 1.8版本新增的方法forEachRemaining，以及一个私有的辅助方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 在实现迭代器时，自己又定义了三个 int 类型的局部变量：<code>cursor</code>、<code>lastRet</code>、<code>expectedModCount</code>。我们先不看迭代器重写的方法是怎么实现，先关注这三个局部变量是做什么的。</p>
<ul>
<li><p><strong>cursor</strong> 坐标</p>
<p>表示迭代器移动到了 ArrayList 的第几个元素，它会伴随着迭代器的移动而移动。</p>
<p>用于判断迭代器的位置，也用于错误判断（比如越界）</p>
</li>
<li><p><strong>lastRet</strong> 上个坐标</p>
<p>最开始是 -1，随着 cursor 一同增加，但始终比 cursor 小 1。</p>
<p>用于判断迭代器刚刚经过的位置，来删除元素，或是错误判断。</p>
</li>
<li><p><strong>expectedModCount</strong> 列表结构变化次数</p>
<p>这是一个很有趣的设计，它不光出现在 ArrayList 的迭代器里，而是出现在 ArrayList 的各个方法中。</p>
<p>这个变量，记录的是列表改变了多少次结构（即列表内元素的数量，发生了多少次变化）。比如初始化一个 ArrayList 之后，add 了一个元素，那么 modCount 就是 1，又 add 了一个元素，那么 modCount 就是 2，之后 remove 了一个元素，列表的结构又发生了改变，modCount 变成了 3。modCount 记录的，就是列表的结构发生了多少次的变化（mod：modification)。</p>
<p>记录列表结构发生变化的次数，这有什么意义呢。ArrayList 是一个非线程安全的类，当有多个线程共用时，很有可能一边新增或删除了列表的某个元素，另一边对此毫不知情而发生错误。对此，ArrayList 为迭代器专门设计了一个 transient 的变量 modCount，不论任何位置，只要改变了列表的结构，都把这一次记录下来。那么，当迭代器初始化时，记录下来 modCount，之后迭代器工作前简单比较一下，当初记录的次数和现在的次数是否相同，就能知道列表有没有发生结构性变化。虽然这不是一个很保险的方式（即使 modCount 相同也有可能出现问题），但是这种方式很轻便，也基本能覆盖大部分问题。</p>
<p>实际上 modCount 并不是 ArrayList 独有的设计，在很多容器（ArrayList、LinkedList、HashMap……）都能看到这种设计：记录容器结构变化的次数，迭代器工作时能快速纠错。这被称为 Java 的 fail-fast 机制，一种用于容器的错误检错机制。</p>
</li>
</ul>
<p>好了，那么开始看源码吧。</p>
<br>

<h2 id="hasNext"><a href="#hasNext" class="headerlink" title="hasNext"></a>hasNext</h2><p>极为简单，当前坐标是否达到容器的长度，达到则返回 false，没达到则返回 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么是容器的长度，而不是长度 - 1，这个要根据其他两个方法来看，cursor 坐标究竟指向哪个元素。</p>
<br>

<h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><p>next 方法的目的，是返回容器的下一个元素。对于列表而言，元素之间是有顺序的，按顺序返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="comment">// E 代表泛型</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致上分两个步骤：</p>
<ol>
<li><p>检查</p>
<p>ArrayList 实现的 next 方法首先检查 modCount，如果列表发生结构性变化，快速失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器的内部方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查非常简单，比较迭代器初始化时的 modCount（expectedModCount），和当前列表的 modCount 是否相同，不同就是结构变了。</p>
<p>然后还会检查 cursor 坐标是否指向了越界的位置。</p>
</li>
</ol>
<ol start="2">
<li><p>移动</p>
<p>在检查完结构后，next 方法正式工作。</p>
<p>它利用 cursor 来判断位置，返回列表的第 cursor 个元素，由于 ArrayList 的背后是由数组实现的，next 方法实际上返回的是数组的第 cursor 个元素，即 <code>return elementData[cursor];</code>。</p>
<p>在迭代器执行 next 方法返回下一个元素的同时，它的两个类变量 cursor、lastRet 也自增 1。</p>
</li>
</ol>
<p>观察发现，cursor 始终指向迭代器的下一个元素的位置，当 next 方法还没执行时，cursor 指向的是要返回的那个“下一个元素”，但当 next 方法要返回下个元素的时候，cursor 就又自增 1，指向了更下一个的元素。还有一种说法是，迭代器是以 cursor 为当前坐标的，next 方法是越过当前元素，到下一个元素的位置上，并返回刚刚越过去的那个元素。</p>
<p>lastRet 是 cursor 的跟班，紧跟在 cursor 一步远的距离，做迭代器的校验工具人。</p>
<br>

<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove 方法的目的，就是把迭代器的当前元素，在整个列表里剔除掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>照例还是分两步走，第一步校验。next 方法校验的是结构是否变化、下个位置是否越界。与之对称的，remove 方法校验的是结构是否变化，当前元素是否不存在。</p>
<p>第二步移除。这里迭代器的 remove 方法，实际上就是列表自己的 remove 方法。列表的 remove 方法实际上是在调用 <code>System.arraycopy</code> 方法，将数组需要移除那个元素，之后的所有元素逐个往前挪位置，以达到数组复制的效果，是个开销不小的实现方法。不过仔细看，迭代器的 remove 方式是只能执行一次的，执行之后 lastRet 就归为初始的 -1 值，不能再 remove 了。</p>
<hr>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>看了源码才知道，原来 HashSet 基本就是 HashMap，它的迭代器实现也是 HashMap 里面的。</p>
<p>HashSet 内部维护一张 HashMap 表，HashMap 有 <code>key</code> 和 <code>value</code>，<code>key</code> 就是 HashSet 的值，而 <code>value</code> 统一都是一个空对象。当创建一个 HashSet 时，实际上就是在创建一张 HashMap，修改 set 的值实际上就是在修改 map 的键值对。可以从 HashSet 的 add 方法来粗略一窥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashSet内部用map存储</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E, Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet存储时，key是集合的值，value是这个空对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet的add方法，增加元素实际上就是在往map里存键值对</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向 HashSet 里增加一个元素，实际上就是在内部维护的 HashMap 里，存入一个 key 为想要增加的元素、value 为空对象的键值对。</p>
<br>

<p>HashMap 自己是没有迭代器的，因为 map 里的每个元素都是有两部分的键和值，迭代器无法同时迭代两个部分。但是迭代其中的一部分是可行的，例如迭代 key，或是迭代 value。实际上，HashSet 的迭代器，就是在迭代 key。</p>
<p>在 HashMap 的源码中，与迭代器相关的内部类有四个，它们被码在同一个区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实还有四个与 Spliterator 相关的迭代器类 （Spliterator：splitable iterator）</span></span><br><span class="line"><span class="comment">// 它们是可分隔迭代器，用于并行迭代，但我们目前忽视它们</span></span><br></pre></td></tr></table></figure>

<p>这四个迭代器，第一个是抽象类，后面三个是我们能使用的类：</p>
<ul>
<li><font color="#32CD32"><strong>KeyIterator</strong></font>  key 迭代器</li>
<li><font color="#32CD32"><strong>ValueIterator</strong></font>  value 迭代器</li>
<li><font color="#32CD32"><strong>EntryIterator</strong></font>  key-value （键值对）迭代器</li>
</ul>
<p>第一个迭代器 <font color="#32CD32"><strong>HashIterator</strong></font> 是上面这三个迭代器的父类，它算是实现了迭代器的 hasNext、next、remove 三个方法，后面三个迭代器直接继承了它的 hasNext 和 remove 方法，简单写了 next 方法。</p>
<p>是怎么简单实现 next 方法的呢，以 <font color="#32CD32"><strong>KeyIterator</strong></font> 类为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// K 是泛型类，与迭代器的泛型类相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br></pre></td></tr></table></figure>

<p>就是返回了父类定义的键值对的 key 值，一行代码。</p>
<p>其他两个类也是如此，返回 value 和返回 key-value，因此我们就不提 HashMap 的后面三个迭代器了，重点看第一个迭代器的实现。</p>
<br>

<p>从整体上看，HashIterator 类的骨架是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Node 类是 HashMap 里定义的键值对类，它继承了 Map.Entry 类</span></span><br><span class="line">    Node&lt;K,V&gt; next;        </span><br><span class="line">    Node&lt;K,V&gt; current;     </span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  </span><br><span class="line">    <span class="keyword">int</span> index;             </span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共四个内部变量，</p>
<ul>
<li><font color="#32CD32"><strong>next</strong></font>  下一个键值对</li>
<li><font color="#32CD32"><strong>current</strong></font>  当前键值对</li>
<li><font color="#32CD32"><strong>expectedModCount</strong></font>  预期 hashMap 的结构变化次数</li>
<li><font color="#32CD32"><strong>index</strong></font> 当前键值对的坐标（HashMap 存放键值对，是以数组的方式来存储的）</li>
</ul>
<p>以及四个方法。</p>
<ul>
<li><font color="#32CD32"><strong>HashIterator</strong></font>  构造方法，初始化迭代器</li>
<li><font color="#32CD32"><strong>hasNext</strong></font>  是否有下一个元素 </li>
<li><font color="#32CD32"><strong>nextNode</strong></font>  下一个键值对</li>
<li><font color="#32CD32"><strong>remove</strong></font>  删除当前元素</li>
</ul>
<p>四个内部变量，跟 ArrayList 实现迭代器的逻辑是相同的，就不写两遍了，看后面的四个方法是怎么实现的。</p>
<br>

<h2 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h2><p>HashMap 的迭代器的构造器，初始化了四个内部变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = <span class="keyword">null</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 modCount 和 current 没什么好讲的，简单赋值。</p>
<p><code>table</code> 是 HashMap 内部存储键值对的数组，具体内容这周不看，但是我们需要知道的是，这个数组内部并不是连续排列，一个键值对紧跟着一个键值对的，中间可能会有 null。</p>
<p>为了考虑内部存储的结构，当前元素存储的下一个数组格子，可能没有存储任何东西，只是 null，因此需要跳过这些空格。为 next 变量赋值时，以及为 index 变量赋值时，是需要跳过空白格子的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;&#125; </span><br><span class="line"><span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>（这行代码还真是紧凑……）</p>
<br>

<h2 id="hasNext-1"><a href="#hasNext-1" class="headerlink" title="hasNext"></a>hasNext</h2><p>迭代器是否有下个元素，去掉方法的结构体只有一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="nextNode"><a href="#nextNode" class="headerlink" title="nextNode"></a>nextNode</h2><p>HashMap 的抽象迭代器并没有 next 方法，next 方法交由子类实现，但是它实现了 next 方法所必需的，搜索下一个键值对的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查 HashMap 的结构是否发生变化（fail-fast 机制），然后检查存储键值对的数组是否为 null（即没有初始化过）。再之后是两行密度很高的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两行代码的含义是：</p>
<ol>
<li>为迭代器的当前元素赋值（也就是上一轮迭代器的 next 元素）。</li>
<li>如果没遍历完存储的内容，那么让 index 移动，让 next 键值对往后挪。</li>
<li>存储键值对的数组，可能存在 null 值，要跳过这些 null 值，让 next 变量指向真正的下一个元素，让 index 坐标指向真正的下一个元素的再下一个位置。</li>
</ol>
<p>从 HashMap 的迭代器，能够大概看出，HashMap 似乎用链表和数组两种方式来存储键值对，数组中放着一个个的链表节点，而链表节点又能指向下一个元素。在数组中的每个元素都连续排列的情况下，用链表检索下一个；当数组中出现“缝隙”，元素之间断开时，又用数组来检索下一个。</p>
<p>没看 HashMap 的其他源码，不知道这种处理方式有什么好处。</p>
<p>（次日改：我智障了，我原来以为链表和数组是互补的，同时使用提高效率，其实链表的作用是让同一个数组格子能够存放多个元素，因为 HashMap 存储元素时，存储的位置是计算出来的，如果计算出来结果相同，那就要存在相同的地方。）</p>
<br>

<h2 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h2><p>感觉 remove 方法没什么太多可说的，检查完然后调用 HashMap 的删除方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; p = current;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    current = <span class="keyword">null</span>;</span><br><span class="line">    K key = p.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>写这篇迭代器的原因，是因为写业务代码时犯了错误，在 for-each 循环里调用了容器的 remove 方法，结果让生产代码回滚了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    <span class="comment">// 执行逻辑...</span></span><br><span class="line">    list.remove(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-each 实际上是用迭代器实现的（这个找不到源码，但可以从反编译代码中推断出来），容器使用了 remove 方法改变了结构，modCount 改变了，和迭代器中的 expectModCount 不相同，会直接抛异常（ConcurrentModificationException）。</p>
<p>当时测试没有看出来，因为只测试了列表的倒数第二个元素。很有趣的是，列表迭代器中的每个元素都会报错，唯独倒数第二个不会报错，就这样侥幸通过了代码自测……至于为什么倒数第二个不会报错，这个跟坐标有关，就不写下去了。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：动态规划</title>
    <url>/2020/04/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<br>

<p>四月的第三周，来学习动态规划。</p>
<p>本来上篇博文的题目叫做《回溯与动态规划》，结果我高估了自己的算法能力，根本学不透hhh，这周来学习动态规划，努力把都所有变种都学会并熟练使用。</p>
<hr>
<p>动态规划（Dynamic programming，简称DP），是一种拆分问题变成相对简单的子问题的算法。我一直觉得这种算法跟高中的数学归纳法有相似之处：在思考问题时，都是思考怎么从第 N 步推出第 N+1 步，在写答案时，都是先写出第 1 步，然后写第 N 步到第 N +1 步的过程，最终输出结论。这种从第 N 步推到第 N+1 步的过程，在算法中称为“重叠子问题”，就是怎么把问题转换成子问题，通常重叠子问题就是解答的核心问题。</p>
<p>动态规划的核心在于写出递推公式，也就是怎么从第 n 步推到第 n+1 步（这个公式的术语叫做<code>状态转移方程</code>），只要能写出这个递推公式，一般问题就不大了。而写出这个公式的通常做法在于画格子，自己画一个表格，每一行新增一个物品/一天/一个数字，自行观察总结新增了一个之后，怎么从上一行信息得出本行信息。</p>
<p>我觉得自己上篇整理算法的方式是错误的，熟练运用算法最重要的不是理解模板，而是大量的练习。本文不再讲解具体内容了，只简单整理 10 道动态规划的题目（题目描述也不抄了，点击题目能跳转过去），画出表格，写出递推公式。</p>
<hr>
<h1 id="LeetCode53-最大子序和"><a href="#LeetCode53-最大子序和" class="headerlink" title="LeetCode53  最大子序和"></a>LeetCode53 <a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener"> 最大子序和</a></h1><table>
<thead>
<tr>
<th>物品[-2, 1, -3, 4, -1, 2, 1, -5,  4] 背包容量1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>-2</td>
<td>-2</td>
</tr>
<tr>
<td>-2, 1</td>
<td>1</td>
</tr>
<tr>
<td>-2, 1, -3</td>
<td>-2</td>
</tr>
<tr>
<td>-2, 1, -3, 4</td>
<td>4</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1</td>
<td>3</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2</td>
<td>5</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2, 1</td>
<td>6</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2, 1, -5</td>
<td>1</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2, 1, -5, 4</td>
<td>5</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,<span class="number">1</span>) = max( dp(i<span class="number">-1</span>,<span class="number">1</span>) + nums[i], nums[i] )</span><br><span class="line">               在原本基础上新增数字    新增数字本身</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 物品个数：nums.length</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建dp数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，dp[i] = (dp[i-1] + num) || (num)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode416-分割等和子集"><a href="#LeetCode416-分割等和子集" class="headerlink" title="LeetCode416  分割等和子集"></a>LeetCode416 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener"> 分割等和子集</a></h1><table>
<thead>
<tr>
<th>物品[1, 2, 3, 4]  背包容量5</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1, 2</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1, 2, 3</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>1, 2, 3, 4</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = (j == nums[i]) || (dp(i<span class="number">-1</span>,j)) || (dp[i - <span class="number">1</span>][j - nums[i]])</span><br><span class="line">          刚好是新加的数字     原本就可以       新加数字之后可以</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验数据</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物品个数：nums.length</span></span><br><span class="line">    <span class="comment">// 背包容量：总和/2</span></span><br><span class="line">    <span class="keyword">int</span> itemCount = len;</span><br><span class="line">    <span class="keyword">int</span> capacity = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[itemCount][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; capacity + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 自己本身</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == j) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拷贝上一行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自己本身组合上一行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; nums[i] &amp;&amp; dp[i - <span class="number">1</span>][j - nums[i]]) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[itemCount - <span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mi27-石头收藏家"><a href="#Mi27-石头收藏家" class="headerlink" title="Mi27 石头收藏家"></a>Mi27 <a href="https://code.mi.com/problem/list/view?id=27" target="_blank" rel="noopener">石头收藏家</a></h1><table>
<thead>
<tr>
<th>物品[2, 3, 5, 7]  物品价值[1, 5, 2, 4] 背包容量10</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2,3</td>
<td></td>
<td></td>
<td>1</td>
<td>5</td>
<td></td>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2,3,5</td>
<td></td>
<td></td>
<td>1</td>
<td>5</td>
<td></td>
<td>6</td>
<td></td>
<td>3</td>
<td>7</td>
<td></td>
<td>8</td>
</tr>
<tr>
<td>2,3,5,7</td>
<td></td>
<td></td>
<td>1</td>
<td>5</td>
<td></td>
<td>6</td>
<td></td>
<td>4</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = max( value[i],       dp(i<span class="number">-1</span>,j-nums[j])+value[i], dp(i<span class="number">-1</span>,j))</span><br><span class="line">               新增物品价值本身   新增物品价值加已有价值         继承上一轮的结果</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String line, line1 = <span class="keyword">null</span>, line2 = <span class="keyword">null</span>, line3;</span><br><span class="line">    <span class="keyword">while</span> (scan.hasNextLine()) &#123;</span><br><span class="line">        line = scan.nextLine().trim();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (line1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            line1 = line;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            line2 = line;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            line3 = line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            String[] s1 = line2.split(<span class="string">" "</span>);</span><br><span class="line">            String[] s2 = line3.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> capacity = Integer.parseInt(line1);</span><br><span class="line">            <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length];</span><br><span class="line">            <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[s2.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length; i++) &#123;</span><br><span class="line">                weights[i] = Integer.parseInt(s1[i]);</span><br><span class="line">                values[i] = Integer.parseInt(s2[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 动态规划数组 行：物品数量 列：背包容量</span></span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[weights.length][capacity + <span class="number">1</span>];</span><br><span class="line">            List&lt;Integer&gt; history = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">if</span> (weights[<span class="number">0</span>] &lt;= capacity) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][weights[<span class="number">0</span>]] = values[<span class="number">0</span>];</span><br><span class="line">                history.add(weights[<span class="number">0</span>]);</span><br><span class="line">                max = values[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 先拷贝上一行数据</span></span><br><span class="line">                System.arraycopy(dp[i - <span class="number">1</span>], <span class="number">0</span>, dp[i], <span class="number">0</span>, dp[<span class="number">0</span>].length);</span><br><span class="line">                <span class="comment">// 结合之前的数据</span></span><br><span class="line">                <span class="keyword">int</span> newWeight = weights[i];</span><br><span class="line">                <span class="keyword">int</span> newValue = values[i];</span><br><span class="line">                <span class="keyword">int</span> historyNum = history.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; historyNum; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> hWeight = history.get(j);</span><br><span class="line">                    <span class="keyword">int</span> hValue = dp[i - <span class="number">1</span>][hWeight];</span><br><span class="line">                    <span class="keyword">int</span> nowHeight = hWeight + newWeight;</span><br><span class="line">                    <span class="keyword">if</span> (nowHeight &lt;= capacity) &#123;</span><br><span class="line">                        dp[i][nowHeight] = Math.max(dp[i - <span class="number">1</span>][nowHeight], hValue + newValue);</span><br><span class="line">                        max = Math.max(max, dp[i][nowHeight]);</span><br><span class="line">                        <span class="keyword">if</span> (!history.contains(nowHeight)) &#123;</span><br><span class="line">                            history.add(nowHeight);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把本身的数据赋值</span></span><br><span class="line">                <span class="keyword">if</span> (newWeight &lt;= capacity) &#123;</span><br><span class="line">                    dp[i][newWeight] = Math.max(dp[i][newWeight], newValue);</span><br><span class="line">                    max = Math.max(max, dp[i][newWeight]);</span><br><span class="line">                    history.add(newWeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printArray(dp);</span><br><span class="line"></span><br><span class="line">            line1 = <span class="keyword">null</span>;</span><br><span class="line">            line2 = <span class="keyword">null</span>;</span><br><span class="line">            line3 = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode188-买卖股票的最佳时机-IV"><a href="#LeetCode188-买卖股票的最佳时机-IV" class="headerlink" title="LeetCode188  买卖股票的最佳时机 IV"></a>LeetCode188 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener"> 买卖股票的最佳时机 IV</a></h1><p>（这个解法效率比较差，但是能做出来）</p>
<table>
<thead>
<tr>
<th>物品[3, 2, 6, 5, 0, 3] 背包容量6</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3, 2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3, 2, 6</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3, 2, 6, 5</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3, 2, 6, 5, 0</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3, 2, 6, 5, 0, 3</td>
<td></td>
<td>4</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = max( (遍历取最大)&#123;dp(i-1,j-1)+nums[i]-nums[k]&#125;,       dp(i<span class="number">-1</span>,j) )</span><br><span class="line">               第k<span class="number">-1</span>天进行j<span class="number">-1</span>次交易 + （第i天的股票 - 第k天的股票）  不交易，沿用上一天</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> days = prices.length;</span><br><span class="line">    <span class="keyword">int</span> saleTimes = Math.min(prices.length, k);</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[days + <span class="number">1</span>][saleTimes + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第i天进行j次交易 = （遍历取最大）&#123;第k-1天进行j-1次交易 + （第i天的股票 - 第k天的股票）&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= days; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= saleTimes; j++) &#123;</span><br><span class="line">            <span class="comment">// 第1天交易，肯定赚不到钱</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交易次数是0，肯定赚不到钱</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> max = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; i; m++) &#123;</span><br><span class="line">                    max = Math.max(max, dp[m - <span class="number">1</span>][j - <span class="number">1</span>] + (Math.max(prices[i - <span class="number">1</span>] - prices[m - <span class="number">1</span>], <span class="number">0</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[days][saleTimes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode32-最长有效括号"><a href="#LeetCode32-最长有效括号" class="headerlink" title="LeetCode32 最长有效括号"></a>LeetCode32 <a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">最长有效括号</a></h1><table>
<thead>
<tr>
<th>物品[(, (, ), (, ),  ), (, )] 背包容量1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>(</td>
<td>0</td>
</tr>
<tr>
<td>((</td>
<td>0</td>
</tr>
<tr>
<td>(()</td>
<td>1</td>
</tr>
<tr>
<td>(()(</td>
<td>1</td>
</tr>
<tr>
<td>(()()</td>
<td>2</td>
</tr>
<tr>
<td>(()())</td>
<td>3</td>
</tr>
<tr>
<td>(()())(</td>
<td>3</td>
</tr>
<tr>
<td>(()())()</td>
<td>4</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i)  =  dp(i<span class="number">-2</span>) + <span class="number">2</span>   ||   dp(i<span class="number">-1</span>) + <span class="number">2</span> + dp(i-dp(i<span class="number">-1</span>)<span class="number">-2</span>)</span><br><span class="line">          <span class="string">"()"</span>结尾            <span class="string">"))"</span>结尾 （dp(i-dp(i<span class="number">-1</span>)<span class="number">-2</span>)代表对应的<span class="string">"("</span>之前有多少个有效括号</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] brackets = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[brackets.length];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历符号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; brackets.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (brackets[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> already = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ()结尾，则是dp[i-2]+2</span></span><br><span class="line">            <span class="keyword">if</span> (brackets[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    already = dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = already + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// ))结尾，则先判断是否成立，如果成立，在上个成立点的基础上+2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; brackets[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        already = dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + already;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode44-通配符匹配"><a href="#LeetCode44-通配符匹配" class="headerlink" title="LeetCode44  通配符匹配"></a>LeetCode44 <a href="https://leetcode-cn.com/problems/wildcard-matching" target="_blank" rel="noopener"> 通配符匹配</a></h1><table>
<thead>
<tr>
<th>物品[*, a, *,  b] 背包容量 5</th>
<th>a</th>
<th>d</th>
<th>c</th>
<th>e</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>*, a</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>*, a, *</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>*, a, *, b</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = dp(i<span class="number">-1</span>,j<span class="number">-1</span>) || dp(i<span class="number">-1</span>,j<span class="number">-1</span>) || &#123; dp(i-1,j) || dp(i,j-1) &#125;</span><br><span class="line">          字母相同        通配符是“?”      通配符是“*”</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先过滤一遍"*"，多个连续的*缩减成一个</span></span><br><span class="line">    String t = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> pChar : p.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pChar != <span class="string">'*'</span>) &#123;</span><br><span class="line">            t += pChar;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            t += pChar;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.charAt(t.length() - <span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">            t += pChar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = s.length();</span><br><span class="line">    <span class="keyword">int</span> n = t.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态 dp[i][j] : 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; t.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>) || t.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode62-不同路径"><a href="#LeetCode62-不同路径" class="headerlink" title="LeetCode62  不同路径"></a>LeetCode62 <a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener"> 不同路径</a></h1><table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>10</td>
<td>15</td>
<td>21</td>
<td>28</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = dp(i<span class="number">-1</span>,j) + dp(i,j<span class="number">-1</span>)</span><br><span class="line">             上           左</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 主要是处理0的特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 核心逻辑就一行代码，上+左</span></span><br><span class="line">            dp[i][j] = up + left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode72-编辑距离"><a href="#LeetCode72-编辑距离" class="headerlink" title="LeetCode72  编辑距离"></a>LeetCode72 <a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener"> 编辑距离</a></h1><table>
<thead>
<tr>
<th></th>
<th>null</th>
<th>r</th>
<th>r, o</th>
<th>r, o, s</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>h</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>h, o</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>h, o, r</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>h, o, r, s</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>h, o, r, s, e</td>
<td>5</td>
<td>4</td>
<td>4</td>
<td>3</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = n 其中一方是null，采用另一方单词的长度</span><br><span class="line">          || dp(i<span class="number">-1</span>,j<span class="number">-1</span>) 尾字母相同，采用去掉尾字母的dp</span><br><span class="line">          || <span class="number">1</span> + min&#123; dp(i,j-1), dp(i-1,j), dp(i-1,j-1) &#125; 从三种临界状态过来，再+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="comment">// 当其中一个单词为null时，dp为另一个单词的长度</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当两个单词尾字母相同时，dp(i,j)=dp(i-1,j-1)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// dp(i,j) = 1 + min&#123; dp(i,j-1), dp(i-1,j), dp(i-1,j-1) &#125; 代表从任意临近状态过来</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode85-最大矩形"><a href="#LeetCode85-最大矩形" class="headerlink" title="LeetCode85 最大矩形"></a>LeetCode85 <a href="https://leetcode-cn.com/problems/maximal-rectangle" target="_blank" rel="noopener">最大矩形</a></h1><p>（不好画表格，经过了两次dp，第一次是行，第二次是列）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行dp一次</span></span><br><span class="line">    <span class="keyword">int</span>[][] lineDp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                lineDp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                lineDp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lineDp[i][j] = lineDp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = lineDp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> columnMin = lineDp[i][j];</span><br><span class="line">                <span class="keyword">int</span> max = lineDp[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    columnMin = Math.min(columnMin, lineDp[k][j]);</span><br><span class="line">                    <span class="keyword">if</span> (columnMin == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 宽：遍历之后的最小值  高：i和k之间的距离</span></span><br><span class="line">                    <span class="keyword">int</span> width = columnMin;</span><br><span class="line">                    <span class="keyword">int</span> high = i - k + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, high * width);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = max;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode279-完全平方数"><a href="#LeetCode279-完全平方数" class="headerlink" title="LeetCode279  完全平方数"></a>LeetCode279 <a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener"> 完全平方数</a></h1><table>
<thead>
<tr>
<th></th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
</tr>
<tr>
<td>12</td>
<td>3</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i) = i   ||  dp(i)     ||    dp(i<span class="number">-1</span>)+<span class="number">1</span>  ||   平方数   || dp(i-平方数)+<span class="number">1</span> </span><br><span class="line">        i个<span class="number">1</span>    遍历的上个结果     上个dp+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平方数</span></span><br><span class="line">    <span class="keyword">int</span>[] squares = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) Math.sqrt(n) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; squares.length; i++) &#123;</span><br><span class="line">        squares[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历平方数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; squares.length &amp;&amp; squares[j] &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果是平方数，那么dp(i)=1</span></span><br><span class="line">            <span class="keyword">if</span> (i == squares[j]) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是平方数，那么dp(i)= &#123; i || 前一个+1 || dp(i-平方数)+1 &#125;</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = min(i, dp[i - <span class="number">1</span>] + <span class="number">1</span>, dp[i - squares[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - <span class="number">1</span>] + <span class="number">1</span>, dp[i - squares[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 关键字</title>
    <url>/2020/03/22/synchronized-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<br>

<p>三月的第四周，踏（gǔn）平（jìn）并发大门。</p>
<p>这周来学习 synchronized 关键字，把使用方法和基本原理学清楚。</p>
<hr>
<p>我在春节放假之前特别膨胀，想一个周把 synchronized 和 JUC 实现的 Lock 都看完，结果两个月过去了，synchronized 还不会用。当初是想入门锁，写了一段介绍锁的开头，就写不下去了，我把那段开头粘贴过来：</p>
<blockquote>
<p>锁的出现，是多线程并发编程所需要的，如果程序在并发执行，同时对一个资源进行操作，这是很容易出现问题的：多个线程同时运行，就像是活在同一个地球上不同维度的生物，它们互相感知不到对方，却在操作同一个东西，可能操作着操作着，突然东西就不见了，或者变多了。这是因为它们在同时操作，而且操作的时候没有互相告知。</p>
<p>《Java 编程思想》对并发导致的问题是这么比喻的：</p>
<blockquote>
<p>想象一下，你坐在桌边手拿叉子，正要去叉盘子中的最后一片食物，当你的叉子就要够着它时，这片食物突然消失了。</p>
</blockquote>
<p>这个比喻有点草。</p>
</blockquote>
<p>Java 原生的有两种实现锁的机制，一种是通过底层实现的 synchronized 关键字，另一种是 Doug Lea 在 JDK1.5 实现的 <code>java.util.concurrent</code> 包中的 Lock 类。这两种方法一种是 Java 关键字，另一种是用对象的方式，两种都实现了并发状态下对公共资源的加锁。</p>
<p>这周来学习通过底层实现的 synchronized 关键字。</p>
<hr>
<h1 id="synchronized-原理铺垫"><a href="#synchronized-原理铺垫" class="headerlink" title="synchronized 原理铺垫"></a>synchronized 原理铺垫</h1><br>

<p>synchronized 是一个 Java 的关键字，能够对并发资源上锁，它由 JVM 实现，也就是说 synchronized 跟底层有关系。</p>
<p>synchronized 关键字从 JDK 1.0 就存在了，最开始是一种代价很大的保证线程安全的方法（但也是唯一一种），在 JDK 6 被重新设计，性能大大提升。这一性能提升，一方面归功于软件代码设计的进步，另一方面也要归功于硬件的发展。</p>
<br>

<h2 id="最初的-synchronized-关键字"><a href="#最初的-synchronized-关键字" class="headerlink" title="最初的 synchronized 关键字"></a>最初的 synchronized 关键字</h2><p>最开始的 synchronized 关键字，基于互斥同步的原理来实现。互斥同步的意思是说：如果一个线程在使用资源，另一个线程想要使用资源，就要等，等到能获取资源为止，这里的等就是互斥的表现，一方使用，另一方就不准使用（即阻塞）。互斥同步是一种很消耗性能的操作，这是因为实现互斥的方式：<code>阻塞</code>，是一种很消耗性能的操作。</p>
<p>这里要提到操作系统的用户态和内核态。主流的 Java 虚拟机对于 Java 线程的实现，是直接将 Java 线程映射到操作系统的原生内核线程之上的，因此实现线程阻塞和线程唤起，必须需要操作系统来帮忙完成，操作系统的用户态和内核态之间进行转换。一个线程尝试获取资源时，发生线程阻塞，这里的阻塞是操作系统来帮助进行的，操作系统由用户态转为内核态，在内核态状态下将这一条线程阻塞住。</p>
<p>用户态和内核态是很重要的操作系统的概念，这里不多进行学习，只记住有这么一回事就可以了。用户态和内核态在进行转换的过程中，需要保存上下文信息，将两种状态的信息都存储下来，这是很消耗资源的。因此互斥同步是很很消耗性能的，用户态和内核态之间进行转换消耗的处理器时间，甚至比同步状态下的代码执行时间还要长，这是一种非常重量级的操作，由此造成了最初的 synchronized 关键字性能很差。</p>
<h2 id="经过改进的-synchronized-关键字"><a href="#经过改进的-synchronized-关键字" class="headerlink" title="经过改进的 synchronized 关键字"></a>经过改进的 synchronized 关键字</h2><p>最初 synchronized 关键字性能差的原因，是因为互斥同步是通过线程阻塞来实现的，而线程阻塞必然导致操作系统在用户态和内核态之间做转换，因而性能差。如果 synchronized 关键字不通过互斥同步实现（不通过阻塞线程来实现安全），那么性能说不定就会好很多。</p>
<p>阻塞，是一种无奈之举，因为不阻塞住线程，就不敢保证操作数据的过程是安全的。不安全最常见的现象是：一条线程读取完数据进行操作，还没保存，另一条线程就修改了数据，那么这时再保存，就会无视刚刚修改的数据，换言之，另一条线程的操作被“无效化”了。</p>
<p>一种比较常见的处理办法是，获取资源时记录下数据的值，在保存的时候，先比对数据是否还是当时的大小，如果是，就默认资源没有问题，可以进行保存。这也就是并发中非常重要的概念：<code>CAS</code>（compare and swap - 比较后交换），先比较预期的数据，如果是预期的大小，就交换值（保存）。值得一提的是，<code>CAS</code> 是另一种实现线程安全的方式：JUC 包的核心逻辑。（但是这实际上还是有潜在问题的，比如我在早晨 10 点获取到数据知道是 1，在下午 5 点发现数据还是 1，这并不能保证数据在这段时间中没有被改过，有可能改了又改回来了，即“ABA 问题”，但好在大多数的情况下 ABA 问题不会影响程序并发的正确性）</p>
<p>如果通过 <code>CAS</code> 操作数据，就可以代替阻塞，性能提高。<code>CAS</code> 的英文原名是 compare &amp; swap，这是指 compare 和 swap 必须在一起进行，执行完 compare 就必须接着执行 swap，即这两个动作合在一起是原子性的，是不能拆开的。这也就是为什么 synchronized 关键字性能提升是需要借助于硬件技术的提高的，因为 <code>CAS</code> 必须由硬件执行，而不能是软件（如果是软件实现，那还是通过互斥同步的方式进行，这就没有意义了），最初的 cpu 在硬件指令集中是没有 <code>CAS</code> 操作的，之后才出现这一指令，JDK 5 的 Java 类库开始使用 <code>CAS</code> 操作，在 JDK 6 中使用该操作对 synchronized 进行了改造。</p>
<p>粗略地讲，synchronized 通过 <code>CAS</code> 操作进行改造的原理，是分了两种情况：如果只有一个线程使用资源（但在理论上有可能有别的线程抢资源），直接 <code>CAS</code> 保存数据就可以了，不需要阻塞线程；如果线程一多争抢资源，那没有办法，乖乖地阻塞线程，通过互斥同步来实现线程安全。</p>
<h2 id="顺带一提"><a href="#顺带一提" class="headerlink" title="顺带一提"></a>顺带一提</h2><p>原始的 synchronized 通过互斥同步来实现线程安全，新的 synchronized 通过 <code>CAS</code> 操作来部分实现线程安全，这实际上也是两种思路，两种在面对并发风险时的思路。</p>
<ol>
<li>互斥同步的思路是，有可能发生并发风险，那么我提前准备，一条线程使用，另一条线程就不准使用。</li>
<li><code>CAS</code> 的思路是，有可能发生并发风险，不用提前准备，先进行 <code>CAS</code> 操作保存，真发现了数据不一样再说。</li>
</ol>
<p>一种是提前应对风险，将风险扼杀在摇篮中，另一种是不管风险先进行操作，产生了冲突再进行补偿措施。这两种思路实际上就是锁机制当中的“乐观锁“和”悲观锁“的思路。乐观和悲观指的是面对并发风险时的态度：</p>
<ol>
<li>乐观的话，先不管风险，干了再说，有问题回来找补（对应于 <code>CAS</code> 操作）</li>
<li>悲观的话，先考虑风险，万无一失，再进行数据处理（对应于互斥同步）</li>
</ol>
<p>因此乐观锁回滚重试，悲观锁阻塞事务。JDK 6 之后的 synchronized 关键字就是先乐观，乐观不起来了再悲观。</p>
<hr>
<h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><br>

<p>学习 synchronized 关键字需要对 JVM 中对象的内存布局（尤其是对象头部分）有所了解。对象头的内容，我在上篇文章《对象的大小》中进行了详尽的描述，在此不多赘述，只将上篇文章中绘制的图放在下面。</p>
<p><img src="/assets/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg" alt="对象头"></p>
<p>对象存储在 JVM 堆里，鉴于内存寸土寸金，需要尽可能地缩减对象头的大小，因此对象头有五种状态，在不同的状态下存储不同的信息。上图的前四种与 synchronized 关键字有关，分别在【没有锁】、【偏向锁】、【轻量级锁】和【重量级锁】状态下，存储不同的信息。换个角度理解，这意味着 synchronized 也有四种场景。</p>
<p>synchronized 关键字的原理（改进之后），就像是开车挂挡，起步一档，速度上来之后挂二档，最后一脚油门上了三挡。</p>
<ol>
<li>如果只有一个线程在使用资源，那么挂一档：偏向锁</li>
<li>如果有少数几个线程在使用资源，那么挂二档：轻量级锁</li>
<li>如果有好几个线程在使用资源，那么挂三挡：重量级锁</li>
</ol>
<p>这三种档位是针对于 JDK 6 之后的 synchronized，在这之前起步直接三挡。</p>
<p>对应于这三个档位（外加上空挡）一共有四种状态，这四种状态的标志位如下：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>偏向模式(1 bit)</th>
<th>锁标志位(2 bit)</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>（没有该字段）</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>（没有该字段）</td>
<td>10</td>
</tr>
</tbody></table>
<br>

<p>（下文主要参考《深入理解 Java 虚拟机》书中的第 12、13 章，这本书写得非常出色，常给我一种醍醐灌顶之感）</p>
<br>

<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>对于上锁的对象，有一个资源争抢的升级过程。最开始的情况，是只有一条线程在使用资源，这时并不存在竞争的情况。如果不存在竞争，上锁是没有必要的，或者说上重量级的锁是没有必要的，毕竟没其他线程抢资源。</p>
<p>偏向锁的<code>偏向</code>，是“偏心”的“偏”、“偏袒”的“偏”，其含义是偏向线程，偏向于第一个获取到它的线程。如果之后一直没有其他线程出现，则持有偏向锁的线程永远不需要进行同步。如果出现了新的线程，偏向锁立即终止。</p>
<p>因此，如果只有一条线程使用资源，则使用偏向锁。如果出现了第二条线程，不论这两条线程是否存在竞争，锁都会膨胀，偏向锁即刻作废。（还是有一些例外的，比如根据<a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">《通俗易懂 悲观锁、乐观锁……》</a>这篇博文提示，如果前一条线程死亡了，新的线程来申请资源，还是能继续使用偏向锁的）在这种意义上，偏向锁是不需要解锁的，因为它从始至终只会有一个锁的主人，出现了第二个主人时，它就作废了，没有解锁是偏向锁相比于轻量级锁、重量级锁的一个区别。</p>
<br>

<p>偏向锁的具体实现，实际上还是比较繁琐的。总体上讲，是把偏向线程的线程ID记录在对象头中，之后再此使用前比对线程ID，如果就是当前线程则无需同步，如果不是当前线程那么偏向锁立即停止使用。</p>
<p>细致地讲，偏向锁的上锁过程如下（自行对照上面对象头示意图）：</p>
<ol>
<li><p>确保可以上偏向锁</p>
<p>首先对象应处于未上锁状态（锁标志位是 01），且对象应为可偏向（偏向标志位是 1），因此对象头的标记部分应为 101 结尾。由于无锁和偏向锁的锁标志位是相同的（都是 01），因此另用 1 bit 来表示对象是否可偏向。JDK 6 下的 HotSpot 虚拟机默认开启偏向锁，可以手动设置参数关闭。</p>
<p>我印象中曾看过一篇博文（但是找不到了），他表述说对象最开始的偏向标志位是 0，过了短暂的时间之后，对象就会自动地将偏向标志位设为 1，但是我不敢确定。</p>
<p>参照上图，对象头在无锁的状态下会保存对象的哈希码（hashcode），实际上这并不一定，如果对象没有计算过哈希码（例如调用 Object :: hashCode() 会计算哈希码），那么哈希码将不会保存在对象头中。但一旦计算过哈希码，对象头中就会储存哈希码，这个对象就再也不会进入偏向锁状态了，如需上锁，它只会一步到位膨胀成重量级锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（附上 64 位 JVM 的对象头标记字段，在无锁和偏向锁状态下的内容：）</span><br><span class="line">|------------------------------------------------------------------------------|----------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |     Normal     |（无锁）</span><br><span class="line">|------------------------------------------------------------------------------|----------------|</span><br><span class="line">| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |     Biased     |（偏向锁）</span><br><span class="line">|------------------------------------------------------------------------------|----------------|</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 CAS 尝试上偏向锁</p>
<p>在确保对象进入偏向模式的前提下，JVM 将会使用 CAS 操作把获取到这个锁的线程的ID记录在对象的标记字段中（图中的对象头标记字段，在偏向模式下的偏向 ID 部分，32 位虚拟机占 23 bit，64 位虚拟机占 54 bit）。</p>
<p>如果 CAS 记录线程 ID 成功，那么认为偏向锁上锁成功，以后持有偏向锁的线程每次进入这个锁相关的同步块时，都不需要进行任何同步操作。</p>
<p>如果 CAS 记录线程 ID 失败，那么偏向模式马上就宣告结束。</p>
<ul>
<li><p>如果此时对象没有上锁，那么该对象将先撤销偏向（将偏向标志位设置为 0），再升级为轻量级锁（这一步的撤销偏向是有一定的性能损耗的）</p>
</li>
<li><p>如果此时对象已经上了偏向锁，那么该对象将继续申请轻量级锁</p>
<p>(下图为《深度理解 Java 虚拟机》的配图，描述了偏向锁膨胀到轻量级锁的过程)</p>
<p><img src="/assets/%E5%81%8F%E5%90%91%E9%94%81%E8%86%A8%E8%83%80%E5%88%B0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.jpg" alt="偏向锁膨胀到轻量级锁"></p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>对象头的标记字段中，还有一个字段：偏向时间戳（epoch）</p>
<p>这个字段的作用是统计重偏向次数。重偏向的概念是这样的，如果有一个类实例化 20 个对象出来，这 20 个对象先经历线程 1，再经历线程 2，上锁时需要发生 20 次的撤销偏向，再升级到轻量级锁的过程。偏向锁的撤销是比较昂贵的（原理暂不考究），如果这种现象多次出现，就意味着这个类不适合使用偏向锁。</p>
<p>对于这种场景 JVM 单独做了优化，类记录了一个 epoch 值，对象在创建时也将有一个 epoch 值（创建时与类的相同）。如果类对象发生了一次大规模的撤销偏向行为，类的 epoch 值将加 1（以后创建的对象也会采用新的 epoch 值），如果类的 epoch 值超过某个阈值，则证明该类不适合使用偏向锁，以后的对象也将不会再使用偏向锁，直接使用轻量级锁。</p>
<p>对象头中的 epoch 值是为了和类的 epoch 值对比用的，如果不一样，则将直接膨胀到轻量级锁。</p>
</li>
</ol>
<br>

<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>当资源不再只被一条线程获取，出现了两个及以上的线程时，偏向锁立即作废，膨胀为轻量级锁。</p>
<p>轻量级锁存在的意义是，如果有多个线程获取资源，但是是交替获取的，并没有发生资源竞争的风险，那么加一个轻量级锁，保证其中一条线程在运行时另一条线程不会并行操作即可。因此轻量级锁的目的，是为了消除数据在无竞争情况下的同步原语，提高程序的运行性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（附上 64 位 JVM 的对象头标记字段，在偏向锁和轻量级锁状态下的内容：）</span><br><span class="line">|---------------------------------------------------------------------|--------------------|</span><br><span class="line">| thread:54 |   epoch:2   | unused:1 | age:4 | biased_lock:1 | lock:2 |       Biased       |（偏向锁）</span><br><span class="line">|---------------------------------------------------------------------|--------------------|</span><br><span class="line">|                     ptr_to_lock_record                     | lock:2 | Lightweight Locked |（轻量级锁）</span><br><span class="line">|---------------------------------------------------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<p>无论是无锁还是偏向锁，这两种状态的锁标志位都是 01，都可以膨胀到轻量级锁，将锁标志位修改为 00。对于轻量级锁而言，上锁的对象，其对象头的标记字段只有两部分内容：分别是锁标志位（2 bit，值为 00），以及正在占有对象的线程ID。</p>
<p>无锁膨胀到轻量级锁的过程是这样的（偏向锁的话，要先撤销偏向到无锁状态，再进行膨胀）：</p>
<ol>
<li><p>确保对象没有被锁定，锁标志为是 01。</p>
</li>
<li><p>备份对象头的标记字段</p>
<p>将对象头的标记字段（Mark Word）拷贝到当前线程的栈帧中。也就是把那 8 字节包含着哈希码、分代年龄、偏向状态、锁标志位等信息的标记字段，存储在当前线程的 JVM 栈中。</p>
<p>标记字段保存在线程栈帧的地址，叫做“锁记录”（Lock Record），换种表述方法，这块 Lock Record 用来存储对象目前的 Mark Word 的拷贝。</p>
</li>
<li><p>CAS 更新对象头，上轻量级锁</p>
<p>虚拟机使用 CAS 操作尝试将对象头的 Mark Word 更新为指向 Lock Record 的指针（就是上一步中，线程栈帧备份对象头的地址），并将对象头的锁标记更新为轻量级锁（00）。</p>
<p>如果这步 CAS 操作能够成功，那么轻量级锁就上好了，如果没有成功，则证明在同一时间有多个线程在竞争资源，轻量级锁不再有效，锁进一步膨胀为重量级锁。</p>
</li>
</ol>
<p>如果对象已经上了轻量级锁，当有线程再次申请资源时：</p>
<ol>
<li>如果是同一个线程，则是一次锁重入。每次锁重入依旧会在线程栈帧中创建一个 Lock Record，只不过重入创建的 Lock Record 的值为 null，即它不再是对象头标记字段的备份。</li>
<li>如果是另一个线程，说明存在多个线程竞争锁，锁膨胀为重量级锁。</li>
</ol>
<p>轻量级锁有解锁的操作，当线程操作完对象资源后，需要将轻量级锁解除。解锁的方法，是将对象头的 Mark Word 和线程栈中的 Lock Record 通过 CAS 替换回来，如果 CAS 操作失败代表有其他线程在竞争资源，锁膨胀。</p>
<br>

<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>当出现两个或更多的线程，在同一时间操作资源时，会发生线程竞争，此时锁膨胀为最强的重量级锁，采取互斥同步的方式，让同一时间只有一个线程操作资源，其他线程阻塞等待。</p>
<p>重量级锁通过一个 monitor 对象实现多线程竞争时的互斥同步，monitor（监视器）是并发设计中很重要的设计，在不同的语言中有不同的实现（然而这些我都不会，我只了解一点点 JVM 的 monitor 设计哈哈）。monitor 作为监视器，监视的是资源，每一个类或者每一个对象只能有一个 monitor 对象，这个 monitor 由 JVM 创建，能够保证同一时间只会有一个线程使用资源，其他线程都乖乖阻塞。</p>
<p>在  JVM 中 monitor 是 ObjectMonitor 类的实例对象，该类源码由 C++ 编写，<a href="https://www.jianshu.com/p/c3313dcf2c23" target="_blank" rel="noopener">代码如下：</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//monitor进入数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">//标识拥有该monitor的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//等待线程组成的双向循环链表，_WaitSet是第一个节点</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ; <span class="comment">//多线程竞争锁进入时的单项链表</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个类实例化的 monitor 对象，一对一地监控着每一个需要互斥同步的类或对象，由 <code>_owner</code> 属性记录并发竞争成功的线程，执行完后换下一个线程，实现重量级锁。如果有其他线程尝试获取 monitor，会由于线程重入次数不为 0 而被迫阻塞。</p>
<br>

<p>synchronized 是以代码块的形式使用的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 将 Java 代码解释成 CPU 原语时，解析 synchronized 关键字，会分别将代码块的<code>开始</code>和<code>结束</code>，解释成 <code>monitorenter</code> 和 <code>monitorexit</code>，这两个原语非常形象，就是进入 monitor 和离开 monitor。通过这两个 CPU 原语，JVM 使每个线程都要去 monitor 处报到，等待重新调度。</p>
<p>这部分我学习得很浅，粗略知道 JVM 使用 monitor 对象来实现互斥同步，实际上是在借助操作系统的互斥原语 mutex 实现。等以后对并发的理解更深厚了，再回来进行学习。</p>
<hr>
<h1 id="synchronized-使用"><a href="#synchronized-使用" class="headerlink" title="synchronized 使用"></a>synchronized 使用</h1><br>

<p>以下内容主要参考自<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=synchronized" target="_blank" rel="noopener">《CS-Notes Java 并发》</a>。</p>
<p>synchronized 关键字有四种使用表现，分别是同步对象、类、方法、静态方法，而同步方法和静态方法，实际上还是在同步对象和类，因此从原理上 synchronized 关键字同步的是对象或类。</p>
<br>

<h2 id="1-同步一个对象"><a href="#1-同步一个对象" class="headerlink" title="1.同步一个对象"></a>1.同步一个对象</h2><p>对任意一个对象加 synchronized，代码块当中的代码都会同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>例如下列代码：实现一个 Runnable 接口，按顺序打印 1-10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r1不同步</span></span><br><span class="line">Runnable r1 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r2同步</span></span><br><span class="line">Runnable r2 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时在线程池中分别跑<code>不同步的 r1</code> 和<code>同步的 r2</code>，每次线程池中跑两个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">executorService.execute(r1);</span><br><span class="line">executorService.execute(r1);</span><br><span class="line"><span class="comment">// 打印结果：1 1 2 2 3 4 5 6 7 8 9 10 3 4 5 6 7 8 9 10 </span></span><br><span class="line"></span><br><span class="line">executorService.execute(r2);</span><br><span class="line">executorService.execute(r2);</span><br><span class="line"><span class="comment">// 打印结果：1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>

<br>

<p>一种非常常见的同步对象的方式，是在类方法中同步 this，即表示同步当前对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-同步一个类"><a href="#2-同步一个类" class="headerlink" title="2.同步一个类"></a>2.同步一个类</h2><p>当 synchronized 同步一个类时，使用该类的所有线程，无论是在操作哪一个对象，都将进行同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>例如如下代码：自定义一个 MyClass 类，该类只有一个按顺序打印 1-10 的方法。生成两个该类的对象，并调用两个线程分别执行这两个类的打印数字方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含打印数字方法的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个类对象</span></span><br><span class="line">MyClass clazz1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">MyClass clazz2 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线程池中执行打印数字的方法</span></span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">executorService.execute(() -&gt; clazz1.testSync());</span><br><span class="line">executorService.execute(() -&gt; clazz2.testSync());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：1 2 3 4 5 1 2 3 4 5 6 7 8 9 10 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>

<p>如果对类方法进行 synchronized 同步，同步的内容是一个类（任意一个类都可以），则可实现线程间的同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Object.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （其他代码略）打印结果：1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="3-同步一个方法"><a href="#3-同步一个方法" class="headerlink" title="3.同步一个方法"></a>3.同步一个方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它作用于同一个对象。（这就是 HashTable 不如 ConcurrentHashMap 的地方，因为它在方法上同步，锁住了整个对象，太过笨重）</p>
<br>

<h2 id="4-同步一个静态方法"><a href="#4-同步一个静态方法" class="headerlink" title="4.同步一个静态方法"></a>4.同步一个静态方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它作用于整个类。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>从 lock 到 AQS 再到 ReentrantLock</title>
    <url>/2020/04/05/Lock/</url>
    <content><![CDATA[<br>

<p>四月的第一周（实际上学习了两周有余），来学习另一种并发锁 Lock。</p>
<p>自 JDK 5 起，Java 类库中新提供了 java.util.concurrent 包（通常简称为 JUC 包），本周要学习的 Lock 接口，尤其是 ReentrantLock 类均出自该包当中。</p>
<hr>
<p>Java 中有两种对并发资源加锁的方式，除了上次写过的 synchronized 之外，还有本次要学习的 Lock。synchronized 是 JVM 通过底层实现的，是物理攻击，而 Lock 是通过 JDK 纯粹在软件层面上实现的，是魔法伤害，这周来学习魔法伤害。</p>
<br>

<p>Lock 类本身是一个接口，对锁进行了规范，Lock 接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock 接口一共规范给定了 6 个方法。</p>
<br>

<p>其中最为常用的，是 <code>lock()</code> 方法和 <code>unlock()</code> 方法，这两个方法必须成对出现，否则就有可能出现异常，使用逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如已经创建了一个lock对象</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用 lock 上锁，与使用 synchronized 上锁的效果是相同的，但在使用上从大括号代码块变为 try 代码块，并且一定要使用 finally 语句为 lock 对象解锁。</p>
<p>阿里巴巴的 Java 代码规约中指出：</p>
<blockquote>
<p>锁【lock.lock】必须紧跟try代码块，且unlock要放到finally第一行。</p>
<p>……</p>
<p>说明一：如果在lock方法与try代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。<br>说明二：如果lock方法在try代码块之内，可能由于其它方法抛出异常，导致在finally代码块中，unlock对未加锁的对象解锁，它会调用AQS的tryRelease方法（取决于具体实现类），抛出IllegalMonitorStateException异常。<br>说明三：在Lock对象的lock方法实现中可能抛出unchecked异常，产生的后果与说明二相同。</p>
</blockquote>
<p>已经说得非常清晰了。</p>
<br>

<p>Lock 接口规定了四种上锁，除了上文说到的最传统的 <code>lock()</code> 方法之外，还有以下三种：</p>
<ul>
<li><code>lockInterruptibly()</code> 会处理线程中断的上锁</li>
<li><code>tryLock()</code> 尝试上锁并立即返回，上锁成功则 true，上锁失败则 false</li>
<li><code>tryLock(long time, TimeUnit unit)</code> 尝试一段时间上锁后返回，上锁成功则 true，上锁失败则 false</li>
</ul>
<p>除以上上锁方法之外，最后还有一个方法 <code>newCondition()</code>，该方法用于协调线程，这个后面再提。</p>
<hr>
<p>写到这里，必须来补充学习两点其他的内容：线程中断、AQS，这两点是接下来要学习的基础。</p>
<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>去年写过一篇文章学习线程，但基本只局限在线程的创建上，对线程的使用逻辑仍是知之甚少。这次学习 Lock 锁需要简单学习下线程的状态，以及线程中断的逻辑。</p>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">通常意义上</a>线程有六种状态，但依我来看线程实际上只有两种状态：可运行状态、不可运行状态。</p>
<ul>
<li>可运行状态：线程可以运行，但是并不一定正在运行，细分的话可以分为<code>正在运行</code>和<code>等待运行</code>两种状态。</li>
<li>不可运行状态：线程不能运行，可能是主动的（主动等待），也可能是被动的（要用的资源被锁住了）。细分的话能分为三种状态：无限期等待状态、限期等待状态、阻塞状态，前两种是线程自己发起的，第三种是线程被迫的。</li>
</ul>
<p>（下图主要参考《<a href="https://www.zhihu.com/question/56494969/answer/154053599" target="_blank" rel="noopener">Java 线程运行怎么有第六种状态？》</a>、<a href="https://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="noopener">《Java 6 Thread States and Life Cycle》</a>）</p>
<p><img src="/assets/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt="线程状态"></p>
<p>对各个状态分别进行解释：</p>
<ul>
<li><p><code>New</code> 新增：线程刚刚创建（例如 <code>Thread t = new Thread()</code>），还没有执行代码</p>
</li>
<li><p><code>Runnable</code> 可运行：线程可以运行（例如 <code>thread.start()</code>），但并不代表一定在运行，是否正在运行要看虚拟机和 CPU 的线程调度情况。</p>
<p>CPU 将时间划分为 10-20 ms 的一个个时间片，在每一个时间片中执行一条线程，到时间就切换（切换地太快导致似乎在并行执行多条线程），这被称为 CPU 在调度线程。在 <code>Runnable</code> 状态下，每一条线程都有可能会被执行，但是执行和切换的速度都很快，非要分出来是在执行还是在等待并没有太大的意义。</p>
<ul>
<li><code>Ready</code> 等待运行：等待 CPU 调度</li>
<li><code>Running</code> 正在运行：CPU 正在执行</li>
</ul>
</li>
<li><p><code>Waiting</code> 无限期等待：线程主动等待，并且不设置等待结束的时间，直到被其他线程“唤醒”（例如 <code>thread.join()</code>）。</p>
</li>
<li><p><code>Timed Waiting</code> 限期等待：线程主动等待，但是设置一个等待的时长，到时间就自动唤醒（例如 <code>thread.sleep(sleepTime)</code>），在等待的这段时间也可以被其他线程“唤醒”。</p>
</li>
<li><p><code>Blocked</code> 阻塞等待：线程被动等待，因为抢锁失败了，被迫等着（例如使用 synchronized 同时让多条线程获取资源，总有线程会被迫等待）。</p>
</li>
</ul>
<br>

<p>有关线程状态还可以剖析地更深一些：</p>
<ul>
<li>Java 的 Thread 类看似是一个寻常的 Java 对象，实际上可以视为对底层系统操作线程的封装，因此使用 Thread 类时不能完全按照面向对象的常规思维来思考，而是要以底层硬件的实现逻辑来思考。</li>
<li>上文我将线程分为了可运行状态和不可运行状态，细分析的话，这实际上是指 CPU 有没有为线程分配时间片。在另外的地方（线程和进程的区别）学习到，线程是操作系统能够调度的最小单位，“能调度的最小单位“这种说法，就是指 CPU 划分出一个个时间片，每一个时间片”调度“一个线程。可运行状态指的是 CPU 能够调度线程，而不可运行状态指的是 CPU 不能调度线程，比如某一个线程中执行 <code>Thread.sleep(sleepTime)</code> 方法，那么这个线程进入 <code>Timed Waiting</code> 状态，在这种状态下 CPU 不再调度该线程，直到该线程休眠时间结束，回到 <code>Runnable</code> 状态，CPU 才可以调度该线程，这个行为被称作线程的“挂起”。</li>
<li>线程通过 <code>sleep(time)</code> 和 <code>wait(time)</code> 方法都可以进入 <code>Timed Waiting</code> 状态，CPU 都不再会调度该线程，但是 sleep 的一方不会释放锁，wait 的一方会释放锁。其他线程如果需要正在 sleep 的线程的资源，将一直阻塞到那个线程醒来再释放资源。</li>
<li>只有使用 synchronized 才能导致线程进入 <code>Blocked</code> 状态，线程从 <code>Waiting</code> 状态无法直接进入 <code>Runnable</code> 状态，只能先进入 <code>Blocked</code> 状态去获取锁。（顺便一提，进入 <code>Waiting</code> 状态的 wait()、notify()、notifyAll() 方法，只能在 synchronized 代码块中使用）</li>
</ul>
<br>

<p>我们终于要写到中断了。</p>
<p>线程中断，这里的“中断”是一个颇有迷惑性的词语，它并不是指线程就此停止，而是指线程收到了一个“中断信号”，线程应该根据这个信号来自行了断一些事情（但是收到中断信号也可以不处理）。</p>
<p>比如，线程 1 向线程 2 发送了一条中断信息，线程 2 的中断状态发生了改变，线程 2 根据中断状态来进行逻辑处理。所以我认为，中断是线程间通信的一种方式，通信的内容是“建议另一条线程停止行为”，但是线程并不一定采取意见，即使采取意见也绝不是终止线程，而是停止某个一直重复运行的行为，继续执行后续的代码。</p>
<p>我目前所见，中断有两种使用场景：</p>
<ol>
<li><p>线程根据中断状态，停止某个循环（例如下面这段伪代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(还没中断)&#123;</span><br><span class="line">    循环执行</span><br><span class="line">&#125;</span><br><span class="line">中断了，进行后续操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程，但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 当前线程休眠1秒</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程中断，不让继续休眠了，处理后续的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的用法是，当线程处于不可运行状态时（暂停 CPU 调度），以异常的形式，强制让线程处理中断，以恢复回到可运行状态（CPU 可调度）。虽然这是在处理异常，但实际上并不是指程序有什么错误，而是代表一种强制手段：必须要对中断进行处理。再换句话说，这是一种恢复线程状态，停止发呆的一种机制。</p>
</li>
</ol>
<p>线程中断有三个相关方法：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>public void interrupt()</td>
<td>中断线程</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>查看线程是否中断</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>静态方法，查看当前线程是否中断的同时，清除中断状态<br>即如果线程中断，执行之后将不再处于中断状态</td>
</tr>
</tbody></table>
<p>中断的源码，以及阻塞状态下的线程抛出中断异常的原理，这里暂不考究了。在此只掌握到两点即可：</p>
<ol>
<li>线程中断不代表线程活动终止</li>
<li>线程中断的基本原理，是给线程的中断标志位赋 true</li>
</ol>
<br>

<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 可以算是 JUC 包的核心，一大片并发类，包括本周要学习的 ReentrantLock 锁，都是以 AQS 为内核，不了解 AQS 则无法继续学习。</p>
<p>AQS 的全称是 AbstractQueuedSynchronizer（抽象队列同步器，中文一般简称“队列同步器”），它的作用正如其名，是一个队列，需要同步的线程们在队列里排队，每次让一个线程占用资源，剩下的线程在队列同步器里待命。这样的设计实现了这种效果：当多个线程争抢资源时，保证只会有一条线程在运行，其他线程都在等待队列里等候安排。</p>
<p>打开 AQS 接口看源码，会看到多如牛毛的方法，初识 AQS 如果从这些方法着手，就可以准备去世了，因此我们从 AQS 的成员变量着手，对 AQS 进行猜测性学习。</p>
<p>以下代码部分，基本全部参考自<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">《一行一行源码分析清楚 AbstractQueuedSynchronizer》</a>，这篇博文写的真的非常好，学习 AQS 必看（主要也是因为 AQS 的代码太神奇了，自己看完全看不懂……Doug Lea 这老爷子我服了）。</p>
<br>

<p>AQS 重要的成员变量有四个，分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做【当前持有锁的线程】可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程（该变量继承自父类），举个最重要的使用例子</span></span><br><span class="line"><span class="comment">// 因为锁可以重入，reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>

<p>AQS 接口中定义了一个内部类：Node，这个类是 AQS 队列的基本构成元素，即并发线程们在 AQS 队列里等候时，都是装在这个 Node 对象里排序的。Node 类源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">// 代表此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本文不分析condition</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 同样的不分析，略过吧</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// =====================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node 类的代码容易看得人一头雾水，初学时应当将其视为一个普通的链表节点，它必须需要</p>
<ul>
<li>Node prev：指向前个节点</li>
<li>Node next：指向后个节点</li>
<li>Thread Thread：本节点需要存储的内容</li>
</ul>
<p>除此之外该节点还有一个状态位：</p>
<ul>
<li>int waitStatus：节点状态，在之后的代码中很重要</li>
</ul>
<p>Node 类定义的其他内容不用太过纠结，看之后的代码会懂。</p>
<p>根据学习这个类，以及参考学习其他 AQS 相关的博文，可以大概知道 AQS 队列的基本结构和设计逻辑是这样的：</p>
<p><img src="/assets/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="AQS数据结构"></p>
<p>看图应该就能明白 AQS 的数据结构，需要注意的是，head 并不在 AQS 的阻塞队列当中。</p>
<br>

<p>以下部分是 AQS 的源码分析，同样基本参考自<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">《一行一行源码分析清楚 AbstractQueuedSynchronizer》</a>这篇文章，这部分的内容很难，可以不看，不会影响到 Lock 接口的学习。</p>
<p>之前的代码中说过，使用 Lock 接口上锁的基本步骤是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();		--&gt; AQS#acquire()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();	--&gt; AQS#release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，lock() 和 unlock() 方法的原理，是使用 AQS 的 acquire() 和 release() 方法实现的，因此我们来粗略地学习这两个方法，并大致了解 AQS 的原理。（以下代码说明均为简略版，查看详细代码说明请参见上述博文）</p>
<ol>
<li><p>上锁（新线程加入队列）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">                                       <span class="comment">// 如果是首次进入队列的节点，那么尝试获取锁</span></span><br><span class="line">                                       <span class="comment">// 如果不是首次进入队列，那么调整一下队列（之前的节点可能超时退出了）</span></span><br><span class="line">         <span class="comment">/* 先尝试获取一次锁 */</span>           ┌-----------------------------------------------------┐</span><br><span class="line">         <span class="comment">/* 如果能拿到，就不用排队了 */</span>    |                 <span class="comment">/* 把线程包装成node，并加入阻塞队列 */</span>   |</span><br><span class="line">         ┌----------------------┐      |                ┌---------------------------┐        |</span><br><span class="line">    <span class="keyword">if</span> ( |   !tryAcquire(arg)   |  &amp;&amp;  | acquireQueued( | addWaiter(Node.EXCLUSIVE) |, arg)) |</span><br><span class="line">         └----------------------┘      |                └---------------------------┘        |</span><br><span class="line">                                       └-----------------------------------------------------┘</span><br><span class="line">        <span class="comment">// 线程已经进入队列了</span></span><br><span class="line">        <span class="comment">// 阻塞线程，耐心等吧</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>解锁（老线程执行完毕，传唤下一个线程）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放线程</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>AQS 的具体实现代码，我自认为是又长又难的，因此不把全部代码整理出来了，只在此记录一些点吧：</p>
<ul>
<li>AQS 中有大量的方法，是为了处理并发的，例如队列还是空的，同时有两个线程进来申请锁，如何来让一个线程拿到锁，另一个线程去队列里排队等候。AQS 解决并发问题的原理是 CAS（CAS 的原理去看上篇介绍 synchronized 的博文），AQS 去调用 JDK5 刚刚出现的 sun.misc.Unsafe 类里面的方法，这个类对 CPU 的 CAS 指令进行了封装。</li>
<li>进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。当占用锁的线程结束，调用 unlock() 方法，此时 AQS 会去队列里唤醒排在最前面的节点线程。</li>
<li>AQS 接口确定了队列同步的主要逻辑，也就是上锁时线程先尝试获取锁，失败则加入队列；解锁时队列先尝试解除锁，如果解锁成功则唤醒后继节点。但是<code>尝试获取锁</code>和<code>尝试解除锁</code>这两个操作，都是交由子类去实现的。这就使得 AQS 框架确立了基础的并发队列机制，但锁的形式可以有各种不同。实际上每个锁（每个 AQS 接口的实现类）就是在重写 AQS 的 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，其他的都依赖于 AQS 接口代码。</li>
<li>AQS 有两个很重要的变量，分别是队列的状态 state，以及队列节点的状态 waitStatus。<ul>
<li>state：0 代表锁没有被占用，1 代表有线程正在占用锁，1 往上代表有线程正在重入占用锁</li>
<li>waitStatus：0 代表初始化，大于 0 代表该节点取消了等待，-1 代表后继节点需要被唤醒</li>
</ul>
</li>
</ul>
<p>先写到这里吧。</p>
<br>

<hr>
<p>接下来首先学习最常用的锁：ReentrantLock。</p>
<p>ReentrantLock 的字面意义是可重入锁，代表线程可以多次执行 lock() 方法占有锁，不会导致死锁问题。</p>
<p>ReentrantLock  允许公平锁，只要在构造方法中传入 true（<code>new ReentrantLock(true)</code>）即可。公平锁的意思是，当多个线程获取锁时，按照先来后到的顺序，先申请锁的线程一定先得到锁，后申请锁的线程一定后得到锁。如果是非公平锁，那么各个线程获取到锁的顺序是“随机”的。对于 ReentrantLock 的非公平锁而言，后到的线程可以先试着获取一次锁，获取到了就直接返回，获取不到就跟公平锁一样在后面排队。ReentrantLock 实现公平锁和非公平锁的方式，是在内部维护两种 AQS 队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁（Sync是一个AQS队列）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>经过刚才对 AQS 的学习，我们知道学习锁实际上只需要看 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，其他都交由 AQS 接口就可以了。</p>
<ol>
<li><p>上锁 <code>tryAcquire()</code></p>
<ul>
<li><p>公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">        <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">            <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">            <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="comment">// 回到上面一个外层调用方法（AQS的acquire()方法）继续看:</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了nonfairTryAcquire()方法，往下看</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 与公平锁相比，只有这里有区别</span></span><br><span class="line">        <span class="comment">// 非公平锁不会先判断AQS队列中是否有等候的节点，而是直接试着获取一次锁</span></span><br><span class="line">        <span class="comment">// 如果这次尝试获取不到，则和公平锁一样尾插队列</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>公平锁和非公平锁只有两点区别：</p>
<ol>
<li><p>非公平锁实际上会先 CAS 获取一次锁，如果失败则调用 AQS 的 acquire() 方法（这段上面没提）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁的lock()方法（会先CAS获取一次锁，获取不到再走AQS接口）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁的lock()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在首次试着获取锁失败的情况下，非公平锁会在 tryAcquire() 方法中再试着获取一次锁，但是公平锁会严格地按照先来后到的顺序获取</p>
</li>
</ol>
<p>可以总结出来，非公平锁比公平锁多尝试获取了两次锁，如果成功就不用进入队列了。这样可以提高并发的线程吞吐量，但是有可能导致先等待的线程一直获取不到锁。</p>
</li>
<li><p>解锁 <code>tryRelease()</code></p>
<p>公平锁和非公平锁，共用一套解锁方法，也就是 <code>Lock#unlock() -&gt; AQS#release() -&gt; Lock#tryRelease() -&gt; AQS#unparkSuccessor()</code>，其中 tryRelease() 方法是交由实现类 ReentrantLock 去重写的（不明白的话回到上面看一看 AQS 的解锁逻辑）。ReentrantLock 重写的 tryRelease() 方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 处理重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 作为可重入锁，每次上锁就使 AQS 队列的状态（初始化是 0）增加 1，解锁使状态减少 1，如果 AQS 队列的状态变为 0 了，就代表没有线程持有锁。</p>
</li>
</ol>
<br>

<hr>
<p>学习得越深入，越感觉锁是一个无底洞，至少还需要再学习 ReentrantReadWriteLock、Semaphore、CountDownLatch、CyclicBarrier、Condition 等内容，本篇承载不了那么多，暂时先写到这里。后续的内容容我先消化一段时间，然后再回来补上。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 入门</title>
    <url>/2020/06/07/MongoDB/</url>
    <content><![CDATA[<br>

<p>六月份到了，六月的第一周来写 MongoDB。</p>
<p>MongoDB 是一种面向文档的非关系型数据库，面向文档的意思是，把半结构化的数据存储为文档（XML、YAML、JSON 等），MongoDB 把数据存储为 BSON（<a href="http://bsonspec.org/" target="_blank" rel="noopener">Binary JSON, is a bin­ary-en­coded seri­al­iz­a­tion of JSON-like doc­u­ments</a>）格式。</p>
<p>有关面向文档，看到这么一篇知乎文章：《<a href="https://www.zhihu.com/question/28003788/answer/632972138" target="_blank" rel="noopener">常见 NoSQL 数据库的应用场景是怎么样的？</a>》</p>
<blockquote>
<p>在文档数据库中的“文档”和传统意义的“文档”没什么关系，它不是书、信或者文章，这里说的“文档”其实是一个数据记录，这个记录能够对包含的数据类型和内容进行“自我描述”。XML 文档、HTML 文档和 JSON 文档就属于这一类。文档数据库可以包含非常复杂的数据结构，比如嵌套对象并且不需要使用特定的数据模式，每个文档可以具有完全不同的结构。</p>
</blockquote>
<p>如果做一个简单映射，那么关系型数据库的<code>表</code>，就是 MongoDB 的<code>集合（Collection）</code>；关系型数据库的<code>行</code>，就是 MongoDB 的<code>文档（Document）</code>，关系型数据库的这两行数据：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>AGE</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>22</td>
</tr>
</tbody></table>
<p>就是 MongoDB 中的这两个文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ID"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"NAME"</span>:<span class="string">"张三"</span>,</span><br><span class="line">    <span class="attr">"AGE"</span>:<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ID"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"NAME"</span>:<span class="string">"李四"</span>,</span><br><span class="line">    <span class="attr">"AGE"</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h1><h2 id="SQL-术语和-MongoDB-术语之间的映射关系："><a href="#SQL-术语和-MongoDB-术语之间的映射关系：" class="headerlink" title="SQL 术语和 MongoDB 术语之间的映射关系："></a>SQL 术语和 MongoDB 术语之间的<a href="https://docs.mongodb.com/manual/reference/sql-comparison/" target="_blank" rel="noopener">映射关系</a>：</h2><table>
<thead>
<tr>
<th align="left">SQL Terms/Concepts</th>
<th align="left">MongoDB Terms/Concepts</th>
</tr>
</thead>
<tbody><tr>
<td align="left">database</td>
<td align="left">database</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">collection</td>
</tr>
<tr>
<td align="left">row</td>
<td align="left">document or BSON document</td>
</tr>
<tr>
<td align="left">column</td>
<td align="left">field</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">index</td>
</tr>
<tr>
<td align="left">table joins</td>
<td align="left">$lookup, embedded documents</td>
</tr>
<tr>
<td align="left">primary key</td>
<td align="left">primary key（在 MongoDB 中，primary key 是自动生成并设置为设置为 <code>_id</code> 字段的</td>
</tr>
<tr>
<td align="left">aggregation (e.g. group by)</td>
<td align="left">aggregation pipeline（聚合管道）</td>
</tr>
</tbody></table>
<br>

<h2 id="一个样例文档（Document）："><a href="#一个样例文档（Document）：" class="headerlink" title="一个样例文档（Document）："></a>一个样例文档（Document）：</h2><p>（对应着 SQL 中的一条数据）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _id: ObjectId("509a8fb2f3f4948bd2f983a0"),</span><br><span class="line">  user_id: "abc123",</span><br><span class="line">  age: 55,</span><br><span class="line">  status: 'A',</span><br><span class="line">  tags: ['test', '2020']</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>实际上有很多函数可用，例如删除相关的函数有 <code>delete</code>、<code>deleteOne</code>、<code>deleteMany</code>、<code>remove</code>、<code>findOneAndRemove</code>、<code>findAndModify()</code> 等，下面列出我自认为常用的，此外还可以参考<a href="https://docs.mongodb.com/manual/reference/sql-comparison/" target="_blank" rel="noopener">官方文档</a>（当页往下翻）。</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td>select * from user</td>
<td>db.user.find()</td>
</tr>
<tr>
<td></td>
<td>select name, age from user</td>
<td>db.user.find({},{name:1,age:1})</td>
</tr>
<tr>
<td></td>
<td>select * from user where name = ‘ZhangSan’</td>
<td>db.user.find({name:”ZhangSan”})</td>
</tr>
<tr>
<td></td>
<td>select * from user where name is not null</td>
<td>db.user.find({name:{$ne:null}})</td>
</tr>
<tr>
<td></td>
<td>select * from user where name like ‘%name%’</td>
<td>db.user.find({name:{$regex:”name”}})<br>db.user.find({name:/name/})</td>
</tr>
<tr>
<td></td>
<td>select * from user order by age desc</td>
<td>db.user.find().sort({age:-1})</td>
</tr>
<tr>
<td></td>
<td>select * from user group by age</td>
<td>参见聚合</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>增加</td>
<td>INSERT INTO user (name, age) VALUES (‘pz’, 23)</td>
<td>db.user.insert({name:”pz”, age:23})</td>
</tr>
<tr>
<td></td>
<td>插入多条</td>
<td>db.user.insertMany([<br>{name:”boy1”, age:20},<br>{name:”boy2”, age:18, tags:[“funny”]}<br>])</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>更改</td>
<td>UPDATE user SET age=21 WHERE age=20</td>
<td>db.user.updateMany({age:20},{$set:{age:21}})</td>
</tr>
<tr>
<td></td>
<td>UPDATE user SET age=21 WHERE age=20 limit 1</td>
<td>db.user.update({age:20},{$set:{age:21}})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>删除</td>
<td>delete from user where age = 20</td>
<td>db.user.deleteMany({age:20})</td>
</tr>
<tr>
<td></td>
<td>delete from user where age = 20 limit 1</td>
<td>db.user.delete({age:100})</td>
</tr>
</tbody></table>
<br>

<h2 id="聚合（aggregate）"><a href="#聚合（aggregate）" class="headerlink" title="聚合（aggregate）"></a>聚合（aggregate）</h2><p>聚合可以简单理解成高级操作，官方的解释有点绕：聚合处理数据并返回结果（Aggregation operations process data records and return computed results）。</p>
<p>聚合有三种类型，分别是聚合管道（Aggregate Pipeline）、Map-Reduce（一般不翻译）、单用途聚合操作（Single Purpose Aggregation Operations）。一般提到聚合，指的是第一种：聚合管道。</p>
<p>下面逐个学习这三种聚合。</p>
<br>

<h3 id="1-聚合管道"><a href="#1-聚合管道" class="headerlink" title="1. 聚合管道"></a>1. 聚合管道</h3><p>MongoDB 指的 pipeline 像是 Java 中的流运算，或者是 linux 系统中的管道，意思是文档（数据）经历一系列的节点（当然也可以是一个节点），一个节点接一个地处理文档，上个节点运算完的结果，作为下个节点的输入，最终输出一堆聚合文档，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.user.aggregate(</span><br><span class="line">    [</span><br><span class="line">        <span class="comment">// name和age不能为null</span></span><br><span class="line">        &#123;</span><br><span class="line">            $match:&#123;name:&#123;$ne:<span class="keyword">null</span>&#125;, age:&#123;$ne:<span class="keyword">null</span>&#125;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 只输出name、age、tags字段</span></span><br><span class="line">        &#123;</span><br><span class="line">            $project:&#123;name:<span class="number">1</span>, age:<span class="number">1</span>, tags:<span class="number">1</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 按照age倒序排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            $sort:&#123;age:-<span class="number">1</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>aggregate</th>
<th>描述</th>
<th>样例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-project.html#pipe._S_out" target="_blank" rel="noopener">$project</a></td>
<td>指定字段</td>
<td>db.user.aggregate([     {         $project:{name:1, age:1}     } ])</td>
<td><code>_id</code> 默认指定，如果不想要，则需 <code>_id:0</code></td>
</tr>
<tr>
<td></td>
<td>指定字段（起别名）</td>
<td>db.user.aggregate([     {         $project:{alias:”$name”}     } ])</td>
<td>别名在冒号前，字段名在冒号后</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-match.html#pipe._S_lookup" target="_blank" rel="noopener">$match</a></td>
<td>匹配字段</td>
<td>db.user.aggregate([     {         $match:{age:{$gt:10}}     } ])<br>（年龄大于10岁）</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-count.html#pipe._S_collStats" target="_blank" rel="noopener">$count</a></td>
<td>计数</td>
<td>db.user.aggregate([     {         $count:”countNum”     } ])</td>
<td>冒号后代表展示字段名</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-group.html#pipe._S_graphLookup" target="_blank" rel="noopener">$group</a></td>
<td>分组</td>
<td>db.user.aggregate([     {         $group:{_id:”$age”,nameList:{$addToSet:”$name”}}     } ])（按年龄统计，获取名字列表）</td>
<td><code>_id</code> 必填，指定要分组的字段，字段均需要带<code>$</code>符号，更多操作可参考 <a href="https://www.cnblogs.com/shaosks/p/5760819.html" target="_blank" rel="noopener">这篇博文</a></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-sort.html#pipe._S_skip" target="_blank" rel="noopener">$sort</a></td>
<td>排序</td>
<td>db.user.aggregate([     {         $sort:{age:1}     } ])</td>
<td>1：升序、-1：降序<br>如果在 <code>$sort</code> 操作之前发生 <code>$project</code>、<code>$unwind</code>或 <code>$group</code>，则 <code>$sort</code> 不能使用任何索引。</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-lookup.html#pipe._S_listSessions" target="_blank" rel="noopener">$lookup</a></td>
<td>左连接</td>
<td>db.user.aggregate([     {         $lookup:{             from:”organization”,             localField:”organization_name”,             foreignField:”name”,             as:”orgInfo”         }     } ])</td>
<td><code>from</code>：要关联的集合（表）、<code>localField</code>：本集合字段、<code>foreignField</code>：要关联的字段、<code>as</code>：新字段名</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-limit.html#pipe._S_indexStats" target="_blank" rel="noopener">$limit</a></td>
<td>只取前几条</td>
<td>db.user.aggregate([     {         $limit:10     } ])</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-skip.html#pipe._S_sample" target="_blank" rel="noopener">$skip</a></td>
<td>跳过前N个文档</td>
<td>db.user.aggregate([     {         $skip:5     } ])</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-unwind.html#pipe._S_sortByCount" target="_blank" rel="noopener">$unwind</a></td>
<td>一个文档（数据）拆成多个文档</td>
<td>db.user.aggregate([     {         $unwind:”$tags”     } ])</td>
<td>注意 <code>$</code> 符号</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-sample.html#pipe._S_replaceRoot" target="_blank" rel="noopener">$sample</a></td>
<td>随机选N个文档</td>
<td>db.user.aggregate([     {         $sample:{size:10}     } ])</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-out.html#pipe._S_match" target="_blank" rel="noopener">$out</a></td>
<td>将结果保存成新表</td>
<td>db.user.aggregate([     {         $limit:10     },     {         $out:”test”     } ])<br>（将 user 表的前 10 条数据存入 test 表中</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-bucket.html#pipe._S_addFields" target="_blank" rel="noopener">$bucket</a></td>
<td>分组</td>
<td>db.user.aggregate([     {         $bucket:{             groupBy:”$sort”,             boundaries:[5,8,10,12],             default:”other”,             output:{                 count:{$sum:1},                 titles:{$push:”$sort”}             }         }     } ])</td>
<td>难以描述，用得不多，现用现查</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-graphLookup.html" target="_blank" rel="noopener">$graphLookup</a></td>
<td>递归往上查</td>
<td>{     $graphLookup:{         from:”user”,         startWith:”$parentId”,         connectFromField:”parentId”,         connectToField:”_id”,         as:”fatherList”     } }</td>
<td>注意 <code>startWith</code> 后面跟的内容带 <code>$</code> 符号，结果会按递归查到的顺序逆序排列</td>
</tr>
</tbody></table>
<p>还有一些别的，用到了再回来补。</p>
<br>

<h3 id="2-Map-Reduce"><a href="#2-Map-Reduce" class="headerlink" title="2. Map-Reduce"></a>2. Map-Reduce</h3><p>我目前用到的还不多，所以不想写了（hh），可以参考这篇文章<a href="https://www.jianshu.com/p/bb1c809dcf37" target="_blank" rel="noopener">《MongoDB Map-Reduce详细操作总结》</a>，写得很容易理解概念。</p>
<p>以后需要用到了再回来补。</p>
<br>

<h3 id="3-单用途聚合操作"><a href="#3-单用途聚合操作" class="headerlink" title="3. 单用途聚合操作"></a>3. 单用途聚合操作</h3><p>就是简化版的聚合管道，官方目前（Version 4.2）在文档中提到了三种，简单整理成下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>计数</td>
<td>select count(*) from user</td>
<td>db.collection.estimatedDocumentCount()</td>
</tr>
<tr>
<td></td>
<td></td>
<td>db.user.count()（废弃）</td>
</tr>
<tr>
<td>返回字段的所有值</td>
<td>（有点像）select name from user group by name</td>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-method-db.collection.distinct.html#db.collection.distinct" target="_blank" rel="noopener">db.user.distinct(“name”)</a>（不理解的话点击看官方文档）</td>
</tr>
</tbody></table>
<p>除了这三种应该还有的是方法，但是我分辨不出来是不是属于这一类，因此先不整理了。</p>
<br>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-eq.html#op._S_eq" target="_blank" rel="noopener">$eq</a></td>
<td>等于</td>
<td>db.user.find({name:{$eq:”pz”}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-ne.html#op._S_ne" target="_blank" rel="noopener">$ne</a></td>
<td>不等于</td>
<td>db.user.find({name:{$ne:null}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-gt.html#op._S_gt" target="_blank" rel="noopener">$gt</a></td>
<td>大于</td>
<td>db.user.find({age:{$gt:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-gte.html#op._S_gte" target="_blank" rel="noopener">$gte</a></td>
<td>大于等于</td>
<td>db.user.find({age:{$gte:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-lt.html#op._S_lt" target="_blank" rel="noopener">$lt</a></td>
<td>小于</td>
<td>db.user.find({age:{$lt:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-lte.html#op._S_lte" target="_blank" rel="noopener">$lte</a></td>
<td>小于等于</td>
<td>db.user.find({age:{$lte:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-in.html#op._S_in" target="_blank" rel="noopener">$in</a></td>
<td>匹配 array 中指定的任何值</td>
<td>db.user.find({age:{$in:[10,20]}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-nin.html#op._S_nin" target="_blank" rel="noopener">$nin</a></td>
<td>匹配 array 中指定的任何值之外</td>
<td>db.user.find({age:{$nin:[10,20]}})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-and.html#op._S_and" target="_blank" rel="noopener">$and</a></td>
<td>并且</td>
<td>db.user.find({$and:[{age:23},{name:”pz”}]})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-not.html#op._S_not" target="_blank" rel="noopener">$not</a></td>
<td>非</td>
<td>db.user.find({name:{$not:/name/}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-nor.html#op._S_nor" target="_blank" rel="noopener">$nor</a></td>
<td>都非</td>
<td>db.user.find({$nor:[{name:”pz”},{age:10}]})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-or.html#op._S_or" target="_blank" rel="noopener">$or</a></td>
<td>或</td>
<td>db.user.find({$or:[{name:”pz”},{age:10}]})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-exists.html#op._S_exists" target="_blank" rel="noopener">$exists</a></td>
<td>具有指定字段（包括null）</td>
<td>db.user.find({age:{$exists:true}})</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/type/#op._S_type" target="_blank" rel="noopener">$type</a></td>
<td>字段是指定类型</td>
<td>db.user.find({name:{$type:”string”}})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-regex.html#op._S_regex" target="_blank" rel="noopener">$regex</a></td>
<td>匹配正则表达式</td>
<td>db.user.find({name:{$regex:”^name.*$”}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-expr.html#op._S_expr" target="_blank" rel="noopener">$expr</a></td>
<td>允许在查询语言中使用聚合表达式</td>
<td>db.user.find({$expr:{$gt:[“$age”,10]}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-mod.html#op._S_mod" target="_blank" rel="noopener">$mod</a></td>
<td>指定字段是取模成功的</td>
<td>db.user.find({age:{$mod:[10,0]}})</td>
</tr>
</tbody></table>
<p>剩下的用到再补，英文文档参考<a href="https://docs.mongodb.com/manual/reference/operator/query/" target="_blank" rel="noopener">《Query and Projection Operators》</a>，汉化文档（机翻，版本 v3.6）参考<a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query.html#%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8A%95%E5%BD%B1%E6%93%8D%E4%BD%9C%E5%91%98" target="_blank" rel="noopener">《查询和投影操作员》</a>。</p>
<hr>
<h1 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h1><p>数据库连接、事务之类的操作就先不学习了，本篇主要学习 CRUD。</p>
<br>

<p>Spring 操作 MongoDB 的类有两种（在我的工作中），分别是 <code>MongoTemplate</code> 和 <code>ReactiveMongoTemplate</code>，前者是普通操作数据库，后者是响应式操作数据库（响应式以后应该会写博文），操作这两个类的 API 几乎是完全相同的，区别只在返回值上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条数据，返回这个数据</span></span><br><span class="line">Object insert1 = mongoTemplate.insert(object);</span><br><span class="line"><span class="comment">// 插入一条数据，返回一个Mono</span></span><br><span class="line">Mono&lt;Object&gt; insert2 = reactiveMongoTemplate.insert(object);</span><br></pre></td></tr></table></figure>

<p>下文以 <code>MongoTemplate</code> 为例，学习 Spring Data MongoDB（其实是一样的，区别只在响应式上）。</p>
<br>

<h2 id="普通操作"><a href="#普通操作" class="headerlink" title="普通操作"></a>普通操作</h2><p>作为 Spring Data 中的一族，Spring Data Mongo 的普通操作（CRUD）跟其他 ORM 框架操作很相近，用过几次就很熟悉了，这里不详细用语言描述了，只整理表格如下（表格下有备注）：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>方法</th>
<th>样例（方法返回值不写了，写了不直观）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>查</td>
<td>find</td>
<td>mongoTemplate.find(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.find(query, User.class, “user”);</td>
<td>指定表名，用于表和输出结果不匹配的情况</td>
</tr>
<tr>
<td></td>
<td>findById</td>
<td>mongoTemplate.findById(id, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findById(id, User.class, “user”);</td>
<td>指定表名，同find</td>
</tr>
<tr>
<td></td>
<td>findOne</td>
<td>mongoTemplate.findOne(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findOne(query, User.class, “user”);</td>
<td>指定表名，同find</td>
</tr>
<tr>
<td></td>
<td>findAll</td>
<td>mongoTemplate.findAll(User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findAll(User.class, “user”);</td>
<td>指定表名，同find</td>
</tr>
<tr>
<td></td>
<td>findDistinct</td>
<td>mongoTemplate.findDistinct(“name”, User.class, String.class)</td>
<td>查指定字段（一共有四种，就写了两种）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findDistinct(query, “name”, User.class, String.class)</td>
<td></td>
</tr>
<tr>
<td>计数</td>
<td>count</td>
<td>mongoTemplate.count(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.count(query, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.count(query, UserDto.class, “user”);</td>
<td>指定输出类、表名</td>
</tr>
<tr>
<td>插入</td>
<td>insert</td>
<td>mongoTemplate.insert(user);</td>
<td>单条插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.insert(user, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.insert(userList, “user”);</td>
<td>批量插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.insert(userList, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insertAll</td>
<td>mongoTemplate.insertAll(userList);</td>
<td></td>
</tr>
<tr>
<td>保存</td>
<td>save</td>
<td>mongoTemplate.save(user);</td>
<td>只能保存单条数据，有则更新，无则插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.save(user, “user”);</td>
<td></td>
</tr>
<tr>
<td>更新</td>
<td>updateFirst</td>
<td>mongoTemplate.updateFirst(query, update, User.class);</td>
<td>修改第一条</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateFirst(query, update, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateFirst(query, update, UserDto.class, “user”);</td>
<td>指定输出类、表名</td>
</tr>
<tr>
<td></td>
<td>updateMulti</td>
<td>mongoTemplate.updateMulti(query, update, User.class);</td>
<td>修改所有</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateMulti(query, update, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateMulti(query, update, UserDto.class, “user”);</td>
<td>指定输出类、表名</td>
</tr>
<tr>
<td>更新或插入</td>
<td>upsert</td>
<td>mongoTemplate.upsert(query, update, User.class);</td>
<td>有则更新，无则插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.upsert(query, update, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.upsert(query, update, User.class, “user”);</td>
<td></td>
</tr>
<tr>
<td>存在</td>
<td>exists</td>
<td>mongoTemplate.exists(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.exists(query, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.exists(query, User.class, “user”);</td>
<td>第二个参数没有意义，可以为null，<br>查询时以第三个参数为依据</td>
</tr>
<tr>
<td>删除</td>
<td>remove</td>
<td>mongoTemplate.remove(user);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(user, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(query, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(query, User.class, “user”);</td>
<td></td>
</tr>
</tbody></table>
<p>备注：</p>
<ol>
<li><p>查询时常用到 <code>Query</code> 和 <code>Criteria</code> 类，这两个类我懒得写了，贴一点代码吧，看一看就懂了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line">Query query = Query.query(Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line">Criteria criteria = Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>)</span><br><span class="line">                .and(<span class="string">"age"</span>).is(<span class="number">23</span>)</span><br><span class="line">                .and(<span class="string">"height"</span>).gt(<span class="number">170</span>);</span><br><span class="line">Query query = <span class="keyword">new</span> Query(criteria);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line">Criteria criteria = Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>);</span><br><span class="line">Query query = <span class="keyword">new</span> Query();</span><br><span class="line">query.addCriteria(criteria);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Update</code> 类是跟 <code>Query</code> 同等地位的类，用于 MongoDB 的更新操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于&#123;$set: &#123;name: "pz"&#125;&#125;，内部Java实现是return new Update().set(key, value);</span></span><br><span class="line">Update update = Update.update(<span class="string">"name"</span>, <span class="string">"pz"</span>);</span><br><span class="line"></span><br><span class="line">Update update = <span class="keyword">new</span> Update();</span><br><span class="line"><span class="comment">// 相当于&#123;$set: &#123;name: "pz"&#125;&#125;</span></span><br><span class="line">update.set(<span class="string">"name"</span>, <span class="string">"pz"</span>);</span><br><span class="line"><span class="comment">// 相当于&#123;$push: &#123;tags: "IT"&#125;&#125;，即tags字段（列表）增加一个元素"pz"</span></span><br><span class="line">update.push(<span class="string">"tags"</span>, <span class="string">"IT"</span>);</span><br><span class="line"><span class="comment">// 相当于&#123;$inc: &#123;age: 2&#125;&#125;，即age字段增加2</span></span><br><span class="line">update.inc(<span class="string">"age"</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>find 还有几种方法：<code>findAndModify</code>、<code>findAndRemove</code>、<code>findAndReplace</code>、<code>findAllAndRemove</code>，我觉得没什么用，没整理。</p>
</li>
</ol>
<br>

<h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><p>Spring Data MongoDB 涉及到聚合相关的类有四个，分别是：</p>
<ul>
<li><p><code>Aggregation</code>：代表着 MongoDB 的 aggregate（聚合），例如下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于db.user.aggregate([...])</span></span><br><span class="line">mongoTemplate.aggregate(aggregation, User.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TypedAggregation</code>：是 Aggregation 的子类，在 Aggregation 的基础上增加了类型，来指定是对哪张表进行聚合操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定操作user表的aggregate</span></span><br><span class="line">TypedAggregation&lt;User&gt; typedAggregation = Aggregation.newAggregation(User.class, operations);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AggregationOperation</code>：聚合的具体操作，有很多子类，对应着一个个的 <code>MongoDB aggregation pipeline operation</code>，举例而言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于&#123;$project: &#123;a: 1, b: 1, thing2: $thing1&#125;&#125;</span></span><br><span class="line">Aggregation.project(<span class="string">"a"</span>, <span class="string">"b"</span>).and(<span class="string">"thing1"</span>).as(<span class="string">"thing2"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AggregationResults</code>：聚合查询结果（非响应式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AggregationResults&lt;User&gt; result = mongoTemplate.aggregate(typedAggregation, User.class);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>举一个例子，把 <code>Aggregation</code>、<code>AggregationOperation</code>、<code>AggregationResults</code> 串起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// db.user.aggregate([</span></span><br><span class="line"><span class="comment">//   &#123;$match: &#123;name: "pz"&#125;&#125;,</span></span><br><span class="line"><span class="comment">//   &#123;$project: &#123;name: 1, age: 1, tags: 1&#125;&#125;,</span></span><br><span class="line"><span class="comment">//   &#123;$limit: 1&#125;</span></span><br><span class="line"><span class="comment">// ])</span></span><br><span class="line">AggregationResults&lt;User&gt; result = mongoTemplate.aggregate(</span><br><span class="line">        Aggregation.newAggregation(</span><br><span class="line">                Aggregation.match(Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>)),</span><br><span class="line">                Aggregation.project(<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"tags"</span>),</span><br><span class="line">                Aggregation.limit(<span class="number">1</span>)</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">"user"</span>,     <span class="comment">// 数据库表</span></span><br><span class="line">        User.class  <span class="comment">// 输出类型</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>学习 Spring Data MongoDB 聚合，主要是学习 <code>AggregationOperation</code> 的所有子类，把各种聚合操作都熟悉之后，用 <code>Aggregation.newAggregation()</code> 组合在一起执行就可以了。</p>
<p>有关聚合的所有操作，基本都有两种创建方式：静态工厂方法和构造方法，官方推荐使用静态工厂方法创建，而非构造方法（尽管背后实现是完全相同的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方推荐，这样更易于阅读</span></span><br><span class="line">ProjectionOperation projectionOperation1 = Aggregation.project();</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">ProjectionOperation projectionOperation2 = <span class="keyword">new</span> ProjectionOperation();</span><br></pre></td></tr></table></figure>

<p>接下来一个个 <code>AggregationOperation</code> 说，把常用的聚合操作学习完。</p>
<br>

<h3 id="1-ProjectionOperation"><a href="#1-ProjectionOperation" class="headerlink" title="1. ProjectionOperation"></a>1. ProjectionOperation</h3><p>指定字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $project:&#123;</span></span><br><span class="line"><span class="comment">//       name:1,</span></span><br><span class="line"><span class="comment">//       age:1,</span></span><br><span class="line"><span class="comment">//       idDelete:"$is_deleted",</span></span><br><span class="line"><span class="comment">//       _id:0,</span></span><br><span class="line"><span class="comment">//       nickName:1</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">ProjectionOperation projectionOperation = Aggregation.project(<span class="string">"name"</span>, <span class="string">"age"</span>)</span><br><span class="line">        .and(<span class="string">"is_deleted"</span>).as(<span class="string">"idDelete"</span>)</span><br><span class="line">        .andExclude(<span class="string">"_id"</span>)</span><br><span class="line">    	.andInclude(<span class="string">"nickName"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>and()</code> 需要配合 <code>as()</code> 一起用，表示别名，不能单独使用（因为返回类型不一样）</li>
<li><code>andInclude()</code> 和 <code>and()</code> 的区别是，前者单独使用，后者配合 <code>as()</code> 使用 </li>
</ul>
<br>

<h3 id="2-MatchOperation"><a href="#2-MatchOperation" class="headerlink" title="2. MatchOperation"></a>2. MatchOperation</h3><p>查询（相当于 Query）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $match:&#123;</span></span><br><span class="line"><span class="comment">//         name:"pz",</span></span><br><span class="line"><span class="comment">//         age:&#123;$gt: 20&#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Criteria criteria = Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>).and(<span class="string">"age"</span>).gt(<span class="number">20</span>);</span><br><span class="line">MatchOperation matchOperation = Aggregation.match(criteria);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="3-LookupOperation"><a href="#3-LookupOperation" class="headerlink" title="3. LookupOperation"></a>3. LookupOperation</h2><p>联表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $lookup:&#123;</span></span><br><span class="line"><span class="comment">//         from:"user",</span></span><br><span class="line"><span class="comment">//         localField:"name",</span></span><br><span class="line"><span class="comment">//         foreignField:"username",</span></span><br><span class="line"><span class="comment">//         as:"userInfo"</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">LookupOperation lookupOperation1 = Aggregation.lookup(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"username"</span>, <span class="string">"userInfo"</span>);</span><br><span class="line"><span class="comment">// 还有一种方式，更直观</span></span><br><span class="line">LookupOperation lookupOperation2 = LookupOperation.newLookup()</span><br><span class="line">        .from(<span class="string">"user"</span>)</span><br><span class="line">        .localField(<span class="string">"name"</span>)</span><br><span class="line">        .foreignField(<span class="string">"username"</span>)</span><br><span class="line">        .as(<span class="string">"userInfo"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-SortOperation"><a href="#4-SortOperation" class="headerlink" title="4. SortOperation"></a>4. SortOperation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $sort:&#123;age: 1, grade: -1&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Sort sort = Sort.by(<span class="string">"age"</span>).and(Sort.by(<span class="string">"grade"</span>).descending());</span><br><span class="line">SortOperation sortOperation = Aggregation.sort(sort);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="5-LimitOperation"><a href="#5-LimitOperation" class="headerlink" title="5. LimitOperation"></a>5. LimitOperation</h3><p>取前 N 条</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $limit:10</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">LimitOperation limitOperation = Aggregation.limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="6-CountOperation"><a href="#6-CountOperation" class="headerlink" title="6. CountOperation"></a>6. CountOperation</h3><p>计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $count:"countNum"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">CountOperation countNum = Aggregation.count().as(<span class="string">"countNum"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="7-UnwindOperation"><a href="#7-UnwindOperation" class="headerlink" title="7. UnwindOperation"></a>7. UnwindOperation</h3><p>拆分字段，常见于联表查询之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $lookup:&#123;</span></span><br><span class="line"><span class="comment">//         from:"user",</span></span><br><span class="line"><span class="comment">//         localField:"name",</span></span><br><span class="line"><span class="comment">//         foreignField:"username",</span></span><br><span class="line"><span class="comment">//         as:"userInfo"</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $unwind:"$userInfo"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">LookupOperation lookupOperation = Aggregation.lookup(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"username"</span>, <span class="string">"userInfo"</span>);</span><br><span class="line">UnwindOperation unwindOperation = Aggregation.unwind(<span class="string">"userInfo"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="8-SkipOperation"><a href="#8-SkipOperation" class="headerlink" title="8. SkipOperation"></a>8. SkipOperation</h3><p>跳过前 N 条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $skip: 100</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">SkipOperation skipOperation = Aggregation.skip(<span class="number">100L</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="9-SampleOperation"><a href="#9-SampleOperation" class="headerlink" title="9. SampleOperation"></a>9. SampleOperation</h3><p>随机取样 N 条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $sample: 10</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">SampleOperation sampleOperation = Aggregation.sample(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="10-GroupOperation"><a href="#10-GroupOperation" class="headerlink" title="10. GroupOperation"></a>10. GroupOperation</h3><p>合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $group:&#123;</span></span><br><span class="line"><span class="comment">//         _id: "$appid",</span></span><br><span class="line"><span class="comment">//         list: &#123;$addToSet: "$account"&#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">GroupOperation groupOperation = Aggregation.group(<span class="string">"appid"</span>)</span><br><span class="line">        .addToSet(<span class="string">"account"</span>).as(<span class="string">"list"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="11-GraphLookupOperation"><a href="#11-GraphLookupOperation" class="headerlink" title="11. GraphLookupOperation"></a>11. GraphLookupOperation</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $graphLookup:&#123;</span></span><br><span class="line"><span class="comment">//         from:"user",</span></span><br><span class="line"><span class="comment">//         startWith:"$parentId",</span></span><br><span class="line"><span class="comment">//         connectFromField:"parentId",</span></span><br><span class="line"><span class="comment">//         connectToField:"_id",</span></span><br><span class="line"><span class="comment">//         as:"fatherList"</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">GraphLookupOperation operation4 = Aggregation.graphLookup(<span class="string">"user"</span>).startWith(<span class="string">"parentId"</span>)</span><br><span class="line">        .connectFrom(<span class="string">"parentId"</span>).connectTo(<span class="string">"_id"</span>).as(<span class="string">"fatherList"</span>);</span><br></pre></td></tr></table></figure>

<br>

<p>这篇就先写到这里了。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的时间类</title>
    <url>/2019/10/01/%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<br>

<p>此篇是十月第一周的内容，拖延症太严重了，不得已鸽掉了九月。</p>
<p>分四个部分讲，分别是 Java 基础时间类、Java sql 时间类、Joda Time 时间类、 <code>java.time</code> 时间类。</p>
<p>既然本篇主讲时间，就顺便把我的博文更新的周数算法讲一下：每月1日所在的周，是本月的第一周，如果这周的前几天属于上一个月，则这几天归入到本月所在周中，例如 2019 年 10 月 1 日是周二，则该周是 10 月的第一周，同时 9 月 30 日也算作 10 月的第一周，而不属于 9 月的第六周。这种周数算法的原因在于，我喜欢一点点任务透支的感觉，以及重新开始的感觉。本周数算法从 10 月起正式生效，之前的博文既往不咎。</p>
<hr>
<h1 id="Java-基础时间类"><a href="#Java-基础时间类" class="headerlink" title="Java 基础时间类"></a>Java 基础时间类</h1><p>Java 的基础时间类有三个，分别是 <code>java.util</code> 包下的 <font color="#32CD32"><strong>Date</strong></font> 类和 <font color="#32CD32"><strong>Calendar</strong></font> 类，以及 <code>java.text</code> 包下的  <font color="#32CD32"><strong>SimpleDateFormat</strong></font> 类。</p>
<p>简单提两嘴这两个包，<code>java.util</code> 包是 Java 的实用工具类库包，包含 Java 的集合类、时间类、事件模型类等；<code>java.text</code> 包是跟文本、格式化打交道的包，比如处理时间、数字等。这两个包都是 Java 的上古基础包。</p>
<br>

<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 类是 Java 里时间类中的老爹，它出场早，脾气倔，在保留着日期和时间最基本用法的同时，总能用其偏执的使用思路让人觉得拧巴。但是在程序员懒得找其他替代品时，它又几乎是第一选择，因为它的确是足够基础，当然了，使用时还要容忍它的反人类。</p>
<p>Date 类有两种构造函数，一种是获取当前时间，一种是根据你的输入时间来实例化时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fastTime = var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Date 类有很多方法，大部分均已标记 <code>@Deprecated</code> （已废弃），剩下的几个基本只有一个方法能用：<code>getTime()</code> ，而这个方法非常硬核，它 get 到的 Time 不是年月日，而是一个 <code>long</code> 类型的毫秒数，表示在格林尼治时间 1900 年开始之后，经过了多少毫秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date.getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印结果：1569456444308</span></span><br></pre></td></tr></table></figure>

<p>Date 类的反人类处</p>
<ul>
<li>Date 类计算年份时，是跟 1900 年进行比较的，比如今年（2019 年）对于 Date 类而言，它是 119 年，当调用 <code>getYear()</code> 方法时（该方法已被官方建议不要使用），它会说这是 119 年。</li>
<li>Date 类计算月份是，是从 0 开始计算的，因此这个月（9 月）对于 Date 类而言，它是 8 。</li>
<li><code>getDay()</code> 方法是获取当周的第几天， <code>getDate()</code> 方法是获取当月的第几天（这两个方法也已被遗弃）。</li>
<li>Date 类自己的一切 <code>getXXX()</code> 方法，实际上只剩下了 <code>getTime()</code> 方法，表示获取当前时间（精确到毫秒）与 1900 年 1 月 1 日 0 时 0 分 0 秒这一瞬间（包含时差），中间间隔的毫秒数，其他获取年月日等时间的方法均被遗弃，官方建议使用 Calendar 类。</li>
<li>Date 类的 <code>getTime()</code> 方法是指获取毫秒数，比如现在时间的 <code>getTime()</code> 的值为 1569454704886 ，太硬核了。更硬核的是，Date 类的构造函数只剩下两种能用，一种是无参构造（得到当下的时间），另一种是以刚才的那个毫秒数为参数。</li>
<li>Date 类的值不是 final 的，是可以在实例化之后通过 <code>setTime()</code> 改变值的，非线程安全。</li>
<li>当调用 Date 类的 <code>toString()</code> 方法时，它会打印出例如 <code>Tue Sep 10 00:00:00 CST 2019</code> （中国标准时间 2019 年 9 月 10 日 0 时 0 点 0 分）的值，你发现这里包含时区信息 CST，但令人无语的是，这个时区信息是 Date 类在调用 <code>toString()</code> 方法时，根据系统时区动态打印的。换句话说，刚才那个时间的程序在中国执行，时区是 CST，在美国执行，那时区就是 PDT。</li>
</ul>
<br>

<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>calendar 是日历的意思，因此见名知意，Calendar 类是用来跟年月日等时间打交道的类。</p>
<p>Calendar 类本身是一个抽象类，它代表着日历类的标准与规范，有 GregorianCalendar 类（格林尼治日历时间）等实现类。实例化一个 Calendar 类，如果不使用子类，那就要通过工厂方法获得了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Calendar类的实例化方法</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种是错误的</span></span><br><span class="line">Calendar calendar = <span class="keyword">new</span> Calendar();</span><br></pre></td></tr></table></figure>

<p>这里通过 <code>Calendar.getInstance()</code> 获得的，是一个 GregorianCalendar 对象。</p>
<p>Calendar 类最实用的方法是它的 <code>get()</code> 方法，用这个方法获取年、月、日、周、小时等等 17 类不同的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取calendar的年份信息 如2019</span></span><br><span class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取calendar的月份信息 如9</span></span><br><span class="line"><span class="keyword">int</span> month = calendar.get(Calendar.MONTH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取calendar的当月天数信息，如10</span></span><br><span class="line"><span class="keyword">int</span> date = calendar.get(Calendar.DATE);</span><br></pre></td></tr></table></figure>

<p>上面诸如 <code>Calendar.YEAR</code> 之类的值，其实是 Calendar 类定义的常量值，<code>Calendar.YEAR</code> 其实就是 1，换句话说，下面两行代码是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year1 = calendar.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> year2 = calendar.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>通过 Calendar 类的 <code>get()</code> 方法能得到 17 类不同的时间信息，这 17 个常量值列在下面：</p>
<table>
<thead>
<tr>
<th>常量名</th>
<th>常量值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>ERA</td>
<td>0</td>
<td>纪元（0：BC 即公元前，1：AD 即公元后）</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>2</td>
<td>月</td>
</tr>
<tr>
<td>WEEK_OF_YEAR</td>
<td>3</td>
<td>本年第几周</td>
</tr>
<tr>
<td>WEEK_OF_MONTH</td>
<td>4</td>
<td>本月第几周</td>
</tr>
<tr>
<td>DATE</td>
<td>5</td>
<td>本月第几日</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>5</td>
<td>本月第几日，与 DATE 完全相同</td>
</tr>
<tr>
<td>DAY_OF_YEAR</td>
<td>6</td>
<td>本年第几日</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>7</td>
<td>本周第几日</td>
</tr>
<tr>
<td>DAY_OF_WEEK_IN_MONTH</td>
<td>8</td>
<td>当前月第几周</td>
</tr>
<tr>
<td>AM_PM</td>
<td>9</td>
<td>上午/下午（0：AM 即上午，1：PM 即下午）</td>
</tr>
<tr>
<td>HOUR</td>
<td>10</td>
<td>当天第几个小时（12 小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>11</td>
<td>当天第几个小时（24 小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>12</td>
<td>当小时第多少分钟</td>
</tr>
<tr>
<td>SECOND</td>
<td>13</td>
<td>当分钟第多少秒</td>
</tr>
<tr>
<td>MILLISECOND</td>
<td>14</td>
<td>当秒第多少毫秒</td>
</tr>
<tr>
<td>ZONE_OFFSET</td>
<td>15</td>
<td>距 GMT 时区偏移时间（以毫秒为单位，mdzz）</td>
</tr>
<tr>
<td>DST_OFFSET</td>
<td>16</td>
<td>夏令时偏移时间（以毫秒为单位）</td>
</tr>
</tbody></table>
<p>具体的使用可以参考这一篇文章：<a href="https://blog.csdn.net/cqx13763055264/article/details/81088635" target="_blank" rel="noopener">《Calendar的基本使用和属性说明》</a>，整理得很细致。</p>
<p>Calendar 类相比于 Date 类更为先进的地方是，它可以通过人类能理解的方式设置和变更时间，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置了一个时间：2019年9月1日0时0分0秒</span></span><br><span class="line">calendar.set(<span class="number">2019</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把时间往前12个月</span></span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把时间往后8个月（但是只改变月份，不改变其他年份等其他时间）</span></span><br><span class="line">calendar.roll(Calendar.MONTH, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>但让人依旧无语的是，Calendar 类的月份也是从 0 开始的。此外 Calendar 类不支持格式化。</p>
<br>

<h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p>SimpleDateFormat 类是一个【格式化】和【解析日期】的工具类，即 <code>Date -&gt; Text</code> 或者 <code>Text -&gt; Date</code>，而且能够按照要求格式转换，如输出 <code>2019-09-10 12:00:00</code> 这种时间文本。</p>
<p>下面就是最常见的用法，声明好格式之后，使用 <code>format()</code> 方法把时间转换成字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss zzz"</span>);</span><br><span class="line">String dateStr = simpleDateFormat.format(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dateStr : "2019-09-26 23:49:26 CST"</span></span><br></pre></td></tr></table></figure>

<p>另一种常见的用法是把字符串转换成时间，但是要异常处理，毕竟是处理字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss zzz"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Date date = simpleDateFormat.parse(<span class="string">"2019-09-26 23:49:26 CST"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// date.toString() : Thu Sep 26 23:49:26 CST 2019</span></span><br></pre></td></tr></table></figure>

<p>字母与时间的对应关系如下（<a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html" target="_blank" rel="noopener">数据来源</a>）：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>日期或时间元素</th>
<th>表示</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>G</code></td>
<td>Era 标志符</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener">Text</a></td>
<td><code>AD</code></td>
</tr>
<tr>
<td><code>y</code></td>
<td>年</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#year" target="_blank" rel="noopener">Year</a></td>
<td><code>1996</code>; <code>96</code></td>
</tr>
<tr>
<td><code>M</code></td>
<td>年中的月份</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#month" target="_blank" rel="noopener">Month</a></td>
<td><code>July</code>; <code>Jul</code>; <code>07</code></td>
</tr>
<tr>
<td><code>w</code></td>
<td>年中的周数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>27</code></td>
</tr>
<tr>
<td><code>W</code></td>
<td>月份中的周数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td>年中的天数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>189</code></td>
</tr>
<tr>
<td><code>d</code></td>
<td>月份中的天数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>F</code></td>
<td>月份中的星期</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td>星期中的天数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener">Text</a></td>
<td><code>Tuesday</code>; <code>Tue</code></td>
</tr>
<tr>
<td><code>a</code></td>
<td>Am/pm 标记</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener">Text</a></td>
<td><code>PM</code></td>
</tr>
<tr>
<td><code>H</code></td>
<td>一天中的小时数（0-23）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>k</code></td>
<td>一天中的小时数（1-24）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>24</code></td>
</tr>
<tr>
<td><code>K</code></td>
<td>am/pm 中的小时数（0-11）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td>am/pm 中的小时数（1-12）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>m</code></td>
<td>小时中的分钟数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>s</code></td>
<td>分钟中的秒数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>55</code></td>
</tr>
<tr>
<td><code>S</code></td>
<td>毫秒数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>978</code></td>
</tr>
<tr>
<td><code>z</code></td>
<td>时区</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#timezone" target="_blank" rel="noopener">General time zone</a></td>
<td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td>
</tr>
<tr>
<td><code>Z</code></td>
<td>时区</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#rfc822timezone" target="_blank" rel="noopener">RFC 822 time zone</a></td>
<td><code>-0800</code></td>
</tr>
</tbody></table>
<p>虽然使用 SimpleDateFormat 类能进行文本处理了，但是使用起来还是挺不方便的，而且还要考虑异常处理，此外它还线程不安全。</p>
<hr>
<h1 id="java-sql-包中的时间类"><a href="#java-sql-包中的时间类" class="headerlink" title="java.sql 包中的时间类"></a><code>java.sql</code> 包中的时间类</h1><p>在 java 中有一个与数据库相对应的类包，是 <code>java.sql</code> 包，该包下有三个对应数据库时间类型的类，分别是 <font color="#32CD32"><strong>Date</strong></font> 类、 <font color="#32CD32"><strong>Time</strong></font> 类和 <font color="#32CD32"><strong>TimeStamp</strong></font> 类，这是三个废物类，一无是处。</p>
<p>这三个类是与数据库中的时间数据类型完全对应的：</p>
<table>
<thead>
<tr>
<th>数据库的时间类型</th>
<th>java.sql 时间类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>Date</td>
<td>2019-09-01</td>
</tr>
<tr>
<td>TIME</td>
<td>Time</td>
<td>12:00:00</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>Timestamp</td>
<td>2019-09-01 12:00:00.000</td>
</tr>
</tbody></table>
<p>说这三个类废物，不是没有根据的：</p>
<ol>
<li>这三个时间类的构造方法都只有一种（另一种官方废弃不建议使用），那就是【当下时间距离 1970 年 1 月 1 日 0 时 0 分 0 秒 0 毫秒】的毫秒数，反人类。</li>
<li>这三个时间类没有诸如 <code>getDate()</code> 之类获取时间的方法，它们有什么方法呢，只有转换成别的时间类的方法 ：)</li>
<li>除了这三个类之外，别的时间类也可以对接数据库。</li>
</ol>
<p>一无是处。</p>
<br>

<hr>
<h1 id="Joda-Time-时间类"><a href="#Joda-Time-时间类" class="headerlink" title="Joda Time 时间类"></a>Joda Time 时间类</h1><p>从上面两部分的时间类看得出，用 JDK 自带的时间类编程，还是比较痛苦的：其一，想完成某个需求，可能需要好几个时间类同时使用；其二，上述时间类还存在着许多例如月份从 0 开始计数、时区信息伪造等暗坑。</p>
<p>这种痛苦的局面在 JDK 8 得到了解决，因为 JDK 8 设计了全新的时间类，但是低版本的 JDK 依旧痛苦。想解决这种痛苦，就要使用第三方类库，Joda Time 就是一个优秀的第三方时间类库。</p>
<p>此外想吐槽的一点是，Joda Time 有一种死心塌地的备胎感，因为它的官网在所有地方都在反复提及：如果使用 JDK 8 及其之后的版本，应该使用 JDK 8 提供的 <code>java.time</code> 包中的时间类，不要使用 Joda Time。真是让人感动，当然我猜这是因为 Joda Time 的作者参与了 JDK 8 的 <code>java.time</code> 包的设计，人家暗中备胎转正了。</p>
<br>

<p><code>org.joda.time</code> 包下的类，大致可以分为三种：</p>
<ol>
<li>时间类（类似于上文的 Date 类）</li>
<li>格式化与解析类（类似于上文的 SimpleDateFormat 类）</li>
<li>时间跨度类</li>
</ol>
<p>时间类就是真正用来记录如 <code>2019-10-07 22:48:03</code> 这类时间的类，格式化与解析类是把时间类型和字符串类型进行相互转换的类，时间跨度类是记录如 <code>2年零3个月</code> 这类间隔时间的类。</p>
<p>接下来逐个类型讲解。</p>
<br>

<h2 id="Joda-Time-的时间类"><a href="#Joda-Time-的时间类" class="headerlink" title="Joda Time 的时间类"></a>Joda Time 的时间类</h2><p>首先要注意：<font color="#FF0000"><strong>Joda Time 所设计的时间类，统统都不可改变（immutable）</strong></font>，跟 String 是一样的，一经实例化，不得改变其值，从源头上实现了线程安全。当需要改变时间时，Joda Time 会返回一个全新的 Joda 实例，也跟 String 的设计是一样的。</p>
<p><code>org.joda.time</code> 包下有五个常用的时间类，以表格形式列在下面：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
<th>示例（2019 年 10 月 1 日 12 时整）</th>
</tr>
</thead>
<tbody><tr>
<td>DateTime</td>
<td>日期+时间（含时区信息）</td>
<td>2019-10-01T00:00:00.000+08:00</td>
</tr>
<tr>
<td>Instant</td>
<td>日期+时间（格林威治时间，存疑）</td>
<td>2019-10-01T12:00:00.000Z</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>日期+时间（不含时区信息）</td>
<td>2019-10-01T12:00:00.000</td>
</tr>
<tr>
<td>LocalDate</td>
<td>日期（不含时区信息）</td>
<td>2019-10-01</td>
</tr>
<tr>
<td>LocalTime</td>
<td>时间（不含时区信息）</td>
<td>12:00:00.000</td>
</tr>
</tbody></table>
<p><font color="#32CD32"><strong>Instant</strong></font> 类是指时间轴上一个确定的时间点（精确到微妙），但是我自认为用处实在是不多，还是其他四个类：<font color="#32CD32"><strong>DateTime</strong></font> 类、<font color="#32CD32"><strong>LocalDateTime</strong></font> 类、<font color="#32CD32"><strong>LocalDate</strong></font> 类、<font color="#32CD32"><strong>LocalTime</strong></font> 类使用比较频繁，如果需要时区信息则使用第一个，如果不需要时区信息，那就使用后面三个以“Local”开头的类。</p>
<p>以上五个时间类，使用方法可以用随心所欲来形容，你想怎么用就怎么用。以 <font color="#32CD32"><strong>DateTime</strong></font> 类为例，介绍 Joda Time 时间类的主要用法：</p>
<ol>
<li><p>得到一个时间对象</p>
<p>有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line">DateTime dateTime1 = <span class="keyword">new</span> DateTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意一种时间类的实例，自动转换</span></span><br><span class="line">DateTime dateTime2 = <span class="keyword">new</span> DateTime(dateTime1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动填写年月日时间等信息，有9种填写规则</span></span><br><span class="line">DateTime dateTime3 = <span class="keyword">new</span> DateTime(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自1970年1月1日0日整之后的毫秒数</span></span><br><span class="line">DateTime dateTime4 = <span class="keyword">new</span> DateTime(<span class="number">1569902400000L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态方法，读取一个字符串转换成时间</span></span><br><span class="line">DateTime dateTime5 = DateTime.parse(<span class="string">"2019-10-01T12:00:00.000+08:00"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取时间信息</p>
<p>同样有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前月份</span></span><br><span class="line"><span class="keyword">int</span> monthOfYear = dateTime.getMonthOfYear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当天过了多少秒</span></span><br><span class="line"><span class="keyword">int</span> secondOfDay = dateTime.getSecondOfDay();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自1970年1月1日0时之后过了多少微秒</span></span><br><span class="line"><span class="keyword">long</span> millis = dateTime.getMillis();</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改时间信息（会返回一个全新的 DateTime 实例）</p>
<p>再次有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 天数 + 1（plus)</span></span><br><span class="line">DateTime plusDateTime = dateTime.plusDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小时数 - 10（minus）</span></span><br><span class="line">DateTime minusDateTime = dateTime.minusHours(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置月份为 8 月（with）</span></span><br><span class="line">DateTime withDateTime = dateTime.withMonthOfYear(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他操作</p>
<p>再再次有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该时间是否比当下时间早</span></span><br><span class="line"><span class="keyword">boolean</span> beforeNow = dateTime.isBeforeNow();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比另一个时间（随意一个时间类的实例），判断是否在其之后</span></span><br><span class="line"><span class="keyword">boolean</span> afterTime = dateTime.isAfter(dateTime2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成废物的java.util.date类</span></span><br><span class="line">Date date = dateTime.toDate();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我知道你懒得看，你只要知道，Joda Time 几乎无所不能，使用时随心所欲，就可以了。</p>
<br>

<h2 id="Joda-Time-的格式化与解析类"><a href="#Joda-Time-的格式化与解析类" class="headerlink" title="Joda Time 的格式化与解析类"></a>Joda Time 的格式化与解析类</h2><p>Joda Time 的格式化与解析类，常用的有三个类，分别是 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类、<font color="#32CD32"><strong>DateTimeFormat</strong></font> 类和 <font color="#32CD32"><strong>DateTimeFormatterBuilder</strong></font> 类。其实不使用这三个类，也可以实现时间解析与格式化处理，直接用字符串指定好样式就可以了，使用这三个类是为了简便和统一操作。</p>
<ol>
<li><p><font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类</p>
<p>时间解析与格式化处理类，用于日期和时间与字符串之间的转换。</p>
<p>当<code>时间类 -&gt; 字符串</code>时，使用时间类的<code>toString(DateTimeFormatter formatter)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormat.fullDateTime();</span><br><span class="line">String dateTimeStr = dateTime.toString(dateTimeFormatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dateTimeStr: "2019年10月1日 星期二 下午01时00分00秒 CST"</span></span><br></pre></td></tr></table></figure>

<p>当<code>字符串 -&gt; 时间类</code>时，使用时间类的静态方法<code>parse(String str, DateTimeFormatter formatter)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dateTime = DateTime.parse(<span class="string">"2019年10月1日 星期二 下午01时00分00秒 CST"</span>, dateTimeFormatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dateTime.toString: "2019-10-01T13:00:00.000-05:00"</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><font color="#32CD32"><strong>DateTimeFormat</strong></font> 类</p>
<p>这是 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类的工厂类，提供各种创建  <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类的实例方法。</p>
<table>
<thead>
<tr>
<th>工厂方法名</th>
<th>示例（ 2019 年 10 月 1 日 13 时整）</th>
</tr>
</thead>
<tbody><tr>
<td>fullDateTime()</td>
<td>2019年10月1日 星期二 下午01时00分00秒 CST</td>
</tr>
<tr>
<td>fullDate()</td>
<td>2019年10月1日 星期二</td>
</tr>
<tr>
<td>fullTime()</td>
<td>下午01时00分00秒 CST</td>
</tr>
<tr>
<td>longDateTime()</td>
<td>2019年10月1日 下午01时00分00秒</td>
</tr>
<tr>
<td>longDate()</td>
<td>2019年10月1日</td>
</tr>
<tr>
<td>longTime()</td>
<td>下午01时00分00秒</td>
</tr>
<tr>
<td>mediumDateTime()</td>
<td>2019-10-1 13:00:00</td>
</tr>
<tr>
<td>mediumDate()</td>
<td>2019-10-1</td>
</tr>
<tr>
<td>mediumTime()</td>
<td>13:00:00</td>
</tr>
<tr>
<td>shortDateTime()</td>
<td>19-10-1 下午01:00</td>
</tr>
<tr>
<td>shortDate()</td>
<td>19-10-1</td>
</tr>
<tr>
<td>shortTime()</td>
<td>下午01:00</td>
</tr>
<tr>
<td>forPattern(String pattern)</td>
<td>自定义格式</td>
</tr>
<tr>
<td>forStyle(String style)</td>
<td>按样式，建议阅读<a href="https://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html#forStyle-java.lang.String-" target="_blank" rel="noopener">官方API</a></td>
</tr>
<tr>
<td>patternForStyle(String style, Locale locale)</td>
<td>根据地区告知样式内容，返回一个样式字符串<br>如样式是”MM”且地区为中国时，返回：yyyy’年’M’月’d’日’ EEEE ahh’时’mm’分’ss’秒’ z</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p><font color="#32CD32"><strong>DateTimeFormatterBuilder</strong></font> 类</p>
<p>这个类是用作生成复杂时间样式的类，可以自由拼接时间，自由指定间隔样式等等，例如“十月 01 日 星期二 下午”。这个类本身是可以改变的（非线程安全），但是它可以转换成 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类，此时就是不能改变的（线程安全）。</p>
<p>本类的操作跟 StringBuilder 类几乎是一致的，使用场景不多，用起来也比较顺手，只贴出一段代码示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatterBuilder dateTimeFormatterBuilder = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">    .appendEraText()              <span class="comment">// 纪元（由于是Text，不需要自己指定精度）</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)           <span class="comment">// 分隔（此处用空格分隔）</span></span><br><span class="line">    .appendYear(<span class="number">4</span>, <span class="number">4</span>)             <span class="comment">// 年（参数表示数字精度，最少4位，最多四位）</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)</span><br><span class="line">    .appendMonthOfYear(<span class="number">2</span>)         <span class="comment">// 月份</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)</span><br><span class="line">    .appendDayOfMonth(<span class="number">2</span>)          <span class="comment">// 日</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)</span><br><span class="line">    .appendDayOfWeekText()        <span class="comment">// 周几</span></span><br><span class="line">    .appendLiteral(<span class="string">" 该天已度过"</span>) <span class="comment">// 分隔（此处用语句分隔）</span></span><br><span class="line">    .appendFractionOfDay(<span class="number">2</span>, <span class="number">2</span>)    <span class="comment">// 当天已过去多少百分比</span></span><br><span class="line">    .appendLiteral(<span class="string">"%"</span>);</span><br><span class="line">DateTimeFormatter dateTimeFormatter = dateTimeFormatterBuilder.toFormatter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印示例：公元 2019 10 01 星期二 该天已度过54%</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>

<h2 id="Joda-Time-的时间跨度类"><a href="#Joda-Time-的时间跨度类" class="headerlink" title="Joda Time 的时间跨度类"></a>Joda Time 的时间跨度类</h2><p>Joda Time 设计了三个类，用来表示时间跨度，分别是 <font color="#32CD32"><strong>Duration</strong></font> 类、<font color="#32CD32"><strong>Period</strong></font> 类和 <font color="#32CD32"><strong>Interval</strong></font> 类。</p>
<ul>
<li><font color="#32CD32"><strong>Duration</strong></font> 类保存了一个精确的毫秒数，比如你设置它为一天，它会记录下这是 86400 秒（如有毫秒会精确到小数点后三位）。</li>
<li><font color="#32CD32"><strong>Period</strong></font> 类保存了一段时间，例如 1 年 10 个月 1 小时 1 毫秒（它记录成 P1Y10MT-1H-0.001S）</li>
<li><font color="#32CD32"><strong>Interval</strong></font> 类保存了一个开始时刻和一个结束时刻，因而也能够表示一段时间。</li>
</ul>
<p>我觉得官方 API 的说明对理解很有帮助：</p>
<blockquote>
<p>Duration: An immutable duration specifying a length of time in milliseconds.</p>
<p>Period: An immutable time period specifying a set of duration field values.</p>
<p>Interval: Interval is the standard implementation of an immutable time interval.</p>
</blockquote>
<p>虽然在我测试和学习之后，感觉这三个类有蛮多道道，也有设计精巧的地方，但我认为，这三个类没有太多的应用场景，时间跨度不是一个常见的需求，用到的时候看一看方法名就能大致猜到了，不写了。</p>
<br>

<hr>
<h1 id="java-time-包中的时间类"><a href="#java-time-包中的时间类" class="headerlink" title="java.time 包中的时间类"></a><code>java.time</code> 包中的时间类</h1><p>当我们迎来 JDK 8 时，我们再也不需要 Joda Time 之类的第三方类库了，因为官方给我们提供了全新的时间类，这些类都属于 <code>java.time</code> 包下。</p>
<p>官方提供的全新时间类，仍然可以分成三种类型：</p>
<ol>
<li>时间类（类似于上文的 Date 类）</li>
<li>格式化与解析类（类似于上文的 SimpleDateFormat 类）</li>
<li>时间跨度类</li>
</ol>
<p>当一个个类接触下去之后，你会发现 JDK 8 所提供的 <code>java.time</code> 包中的时间类，和 Joda Time 是何其相似，相似到你觉得简直像是 Joda Time 备胎转正，我猜想这跟 Joda Time 的作者参与到 <code>java.time</code> 包的开发中有关。</p>
<p>我感觉这两个类库的设计，最主要的区别在于，Joda Time 习惯于 new 一个对象出来，而 <code>java.time</code> 习惯于用静态工厂方法实例化一个对象出来。</p>
<br>

<h2 id="java-time-包的时间类"><a href="#java-time-包的时间类" class="headerlink" title="java.time 包的时间类"></a><code>java.time</code> 包的时间类</h2><p><code>java.time</code> 包中的时间类设计，几乎与 Joda Time 一模一样，也是有五个类。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
<th>示例（2019 年 10 月 1 日 12 时整）</th>
</tr>
</thead>
<tbody><tr>
<td>ZonedDateTime</td>
<td>日期+时间（含时区信息）</td>
<td>2019-10-01T00:00:00.000+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td>Instant</td>
<td>日期+时间（格林威治时间，存疑）</td>
<td>2019-10-01T12:00:00.000Z</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>日期+时间（不含时区信息）</td>
<td>2019-10-01T12:00:00.000</td>
</tr>
<tr>
<td>LocalDate</td>
<td>日期（不含时区信息）</td>
<td>2019-10-01</td>
</tr>
<tr>
<td>LocalTime</td>
<td>时间（不含时区信息）</td>
<td>12:00:00.000</td>
</tr>
</tbody></table>
<p>你若将 <code>java.time</code> 包与 Joda Time 所表示时间的五个类进行比较，你会发现，后四个类的类名、作用、具体示例是一模一样的，完全相同，只有第一个【包含时区信息的日期+时间】的类，两个是稍有不同的。</p>
<p>在 Joda Time 中类名是 <font color="#32CD32"><strong>DateTime</strong></font>，而在 <code>java.time</code> 包中是 <font color="#32CD32"><strong>ZonedDateTime</strong></font>，更明显地表现出这是一个跟时区有关系的类，这两个类通过 <code>toString()</code> 方法打印出来，也仅仅是最末尾相差了一处地区信息：[Asia/Shanghai]，除此之外，分毫未差。</p>
<p>这五个类在使用上也几乎没什么区别，最主要的的区别只有一处，那就是：JDK 8 的 <code>java.time</code> 包中的时间类，不再具有 public 的构造方法，而只有类静态方法。</p>
<p>也就是说，通过类构造方法实例化对象，是错误的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误！</span></span><br><span class="line">LocalDate localDate = <span class="keyword">new</span> LocalDate();</span><br></pre></td></tr></table></figure>

<p>因为这个类构造方法是私有（private）的，不对外公开。</p>
<p>实例化对象，需要使用类静态方法（有很多个静态方法，这里只展示两个有代表性的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法 now() 当前时间</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 of()  构造时间</span></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="java-time-包的格式化与解析类"><a href="#java-time-包的格式化与解析类" class="headerlink" title="java.time 包的格式化与解析类"></a><code>java.time</code> 包的格式化与解析类</h2><p><code>java.time</code> 包省去了 <font color="#32CD32"><strong>DateTimeFormat</strong></font> 类，将其方法合并到 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类中，实例化一个 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 对象也就只能用这个类自己的静态工厂方法，但是使用起来和 Joda Time 并没有什么太大的区别。</p>
<p><code>java.time</code> 包保留了 <font color="#32CD32"><strong>DateTimeFormatterBuilder</strong></font> 类，使用起来跟 Joda Time 也是几乎完全一样。</p>
<p>这部分不写了，具体的内容可以参考这篇文章：<a href="https://www.twle.cn/c/yufei/java8/java8-basic-datetime-format-api.html" target="_blank" rel="noopener">《Java 8 新日期时间 API ( 下 ) - 格式化》</a></p>
<br>

<h2 id="java-time-包的时间跨度类"><a href="#java-time-包的时间跨度类" class="headerlink" title="java.time 包的时间跨度类"></a><code>java.time</code> 包的时间跨度类</h2><p><code>java.time</code> 包去除掉了 Joda Time 中鸡肋的 <font color="#32CD32"><strong>Interval</strong></font> 类（保存一个开始时间和一个结束时间），保留下了另外两个类：<font color="#32CD32"><strong>Duration</strong></font> 类和 <font color="#32CD32"><strong>Period</strong></font> 类。</p>
<p>跟 Joda Time 的设计稍微不同，<font color="#32CD32"><strong>Duration</strong></font> 类保存了一个精确到纳秒的时间（例如 5 小时零 1 纳秒是 PT5H0.000000001S），但是 <font color="#32CD32"><strong>Period</strong></font> 类是一致的，仍然是保存一段时间。在使用上，<font color="#32CD32"><strong>Duration</strong></font> 类更偏向于时间（time），而 <font color="#32CD32"><strong>Period</strong></font> 类更偏向于日期（calendar）。</p>
<p>具体的方法、使用的逻辑，与 Joda Time 如出一辙，那就写到这里吧。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC 初探</title>
    <url>/2020/05/27/IOC/</url>
    <content><![CDATA[<br>

<p>本文是对<a href="https://www.javadoop.com/post/spring-ioc" target="_blank" rel="noopener">《Spring IOC 容器源码分析》</a>的总结，我对照这篇文章和 Spring 源码进行学习之后，精要化出一些结论。如果时间紧迫可以参考本篇文章，如果时间充裕，更建议对照那篇文章过一遍源码（那篇文章写于2017年，和最新的源码稍有一点点出入，没关系）。</p>
<p>我之前写过一篇介绍 IOC 概念的文章，现在回看想掐死自己……一副什么都不懂却特别跳的样子，气人。</p>
<p>这里重新简要写一下 IOC 的概念：IOC 是控制反转（Inversion of Control）的缩写，控制指的是“控制对象的获得”，比如当需要一个对象的时候，怎么获得这个对象：</p>
<ul>
<li>常见的“控制”思路，是什么时候需要对象就什么时候 new 一个出来，对象没有创建就无法继续下去，“new 对象”控制了后续代码</li>
<li>“控制反转”的思路，是什么时候需要对象就什么时候向资源池要，因为代码需要，所以才向资源池要对象，后续代码控制了对象的获得。</li>
</ul>
<p>细品一下“控制对象的获得”这几个字就能理解了，可以简单理解为先后顺序。如果先 new 对象再写后续代码，或者是工厂方法获得对象，等等，都使得获取过程要靠自身实现，代码高耦合不便于维护。所以 IOC 的思想是资源由资源池管理，需要的时候让第三方资源池提供。</p>
<p>在 Spring 中 IOC 向资源池要对象，资源池指的是 <code>beanDefinitionMap</code>，这篇文章要学习的内容，就是 <code>beanDefinitionMap</code> 加载资源的初始化过程，也就是 Bean 读取和装载的过程。</p>
<p>（尽管现在使用 IOC 都是通过注解 @AutoWired，但本文仍以最原始的解析 xml 文件来展开。）</p>
<hr>
<p>通过 <code>ClassPathXmlApplicationContext</code>，将 xml 文件解析成一个个的 Bean，只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>这个构造方法实际上是在调用另一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个构造方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(parent);</span><br><span class="line">   <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">   setConfigLocations(configLocations);</span><br><span class="line">   <span class="comment">// 核心方法</span></span><br><span class="line">   <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>ClassPathXmlApplicationContext</code>，主要就是在调用 <code>refresh()</code> 方法，叫 refresh 的原因是它会销毁原来的 ApplicationContext，用以重建。这个方法海纳百川，内容量爆炸，我们只看前三个方法（足够理解 IOC 了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 加锁，否则 refresh() 没结束，又来一次 refresh() 就出事了</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备（包括记录启动时间、设置”已启动“状态，处理配置文件的占位符）</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建 Bean 工厂（包括初始化 BeanFactory、加载 Bean、注册 Bean 等）</span></span><br><span class="line">      <span class="comment">// 这一步结束时，Bean 实例尚未创建</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们今天的重点，是第二个方法创建 BeanFactory（<code>obtainFreshBeanFactory()</code>），这个方法能往里扒快 20 层，主要功能是创建 BeanFactory、从 xml 文件中读取信息并解析成多个 BeanDefinition、把所有 Bean 注册到 <code>beanDefinitionMap</code> 中。</p>
<p>但是我们还是从第一个方法开始。</p>
<hr>
<h1 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h1><p>记录时间、状态、校验数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录启动时间</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">// 设置“已启动”状态（这两个都是 AtomicBoolean 类型）</span></span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打日志</span></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理配置文件的占位符（默认空实现，交由子类）</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验配置文件（比如校验 xml 配置文件）</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过。</p>
<hr>
<h1 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h1><p>这个方法会创建 Bean 工厂，注册 Bean，是最为重要的一个方法。</p>
<p>我在看博文和源码时，是边学习边截图代码用 PS 拼图的，本想把这部分代码整理成一张大图，结果里面有二十多个子方法，一层层剥进去十几层，PS 画布长八米多……因此用图片做直观学习是不太现实了。</p>
<p>本方法按顺序依次实现了下面这些内容：</p>
<ol>
<li>销毁旧的所有 Bean，关闭旧的 BeanFactory</li>
<li>创建一个新的 BeanFactory</li>
<li>经过一系列步骤，读取 xml 配置文件</li>
<li>解析 Bean 定义，生成一个个的 BeanDefinition 的实例</li>
<li>根据名字，把所有的 Bean 注册在 beanDefinitionMap 里</li>
<li>注册事件等后续</li>
</ol>
<p>按照顺序一点点把代码搬上来。</p>
<h2 id="1-销毁旧的-Bean-和-BeanFactory"><a href="#1-销毁旧的-Bean-和-BeanFactory" class="headerlink" title="1. 销毁旧的 Bean 和 BeanFactory"></a>1. 销毁旧的 Bean 和 BeanFactory</h2><p>如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory（这里销毁的是当前 ApplicationContext 的旧 BeanFactory ，BeanFactory 是可以多个的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 已经加载过 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      <span class="comment">// 销毁所有 Bean</span></span><br><span class="line">      destroyBeans();</span><br><span class="line">      <span class="comment">// 关闭 BeanFactory</span></span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-创建一个新的-BeanFactory"><a href="#2-创建一个新的-BeanFactory" class="headerlink" title="2. 创建一个新的 BeanFactory"></a>2. 创建一个新的 BeanFactory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// ...（销毁旧的 Bean 和 BeanFactory）</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 BeanFactory，默认指定 DefaultListableBeanFactory</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建的新的 BeanFactory 类型是 DefaultListableBeanFactory，<code>createBeanFactory()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactory 的继承关系如图（图片源于学习博文）：</p>
<p><img src="/assets/BeanFactory.png" alt="BeanFactory"></p>
<p>从继承关系可以看到，这个 DefaultListableBeanFactory 是所有 BeanFactory 的集大成者，实现了</p>
<ul>
<li>可以获取多个 Bean（最顶层 BeanFactory 接口的方法都是获取单个 Bean 的）</li>
<li>可以将各个 BeanFactory 设置为父子关系</li>
<li>可以自动装配 Bean（Autowire）</li>
</ul>
<p>在创建了一个 BeanFactory 之后，紧接着给它设置了三个属性（代码不贴了）：</p>
<ul>
<li>设置序列化 ID（使用 applicationContext 的 ID）</li>
<li>设置是否允许 BeanDefinition 覆盖</li>
<li>设置是否允许循环引用</li>
</ul>
<p>BeanDefinition 覆盖的默认配置是：在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。循环引用的意思是：A 依赖 B，而 B 依赖 A；或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>
<h2 id="3-经过一系列步骤，读取-xml-配置文件"><a href="#3-经过一系列步骤，读取-xml-配置文件" class="headerlink" title="3.  经过一系列步骤，读取 xml 配置文件"></a>3.  经过一系列步骤，读取 xml 配置文件</h2><p>这块我都不想贴代码了，一系列步骤的意思就是一系列步骤，往里扒到吐血的那种。</p>
<p>总体上走了这些流程（这些都是指读取 xml 数据）：</p>
<ol>
<li>创建一个 XmlBeanDefinitionReader 并设置参数，用于读取 xml 数据</li>
<li>读取 Resource[] 资源数组，遍历逐一处理</li>
<li>把 Resource 包装成 EncodedResource</li>
<li>创建一个 Set（ThreadLocal），逐一装入 EncodedResource，检查是否重复加入</li>
<li>将 EncodedResource 读出 InputStream，再转换成 InputSource</li>
<li>将 InputSource 转换成 Document（是 w3c 定义的接口，代表着 xml 的节点）</li>
<li>创建 DocumentReader，用以解析 Document（实际上是解析 Document 中的 Element）。</li>
<li>DocumentReader 内部创建了 BeanDefinitionParserDelegate，用以负责解析 Bean 定义</li>
<li>解析 Bean 定义（看下一部分），并最终将所有的 Bean （实际上是 BeanDefinition）都装入到 BeanFactory 的 beanDefinitionMap 中，这是一个 ConcurrentHashMap。</li>
</ol>
<h2 id="4-解析-Bean-定义"><a href="#4-解析-Bean-定义" class="headerlink" title="4. 解析 Bean 定义"></a>4. 解析 Bean 定义</h2><p>在经过一系列的流程之后，终于将 xml 资源转换成一个个的 Element，这是 w3c 定义的类，在此对应着 xml 文件中的各个节点。</p>
<p>xml 文件中有很多类型的节点，比如 <code>&lt;bean /&gt;</code>、<code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code> 等。默认的 Element 只有四种：<code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code> 和 <code>&lt;beans /&gt;</code>，这是 <code>xmlns=&quot;http://www.springframework.org/schema/beans&quot;</code> 定义的，也就是默认的命名空间（default namespace），如果想要解析别的类型，需要增加额外的命名空间。</p>
<p>解析这四种默认的 Element 是采用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签定义</span></span><br><span class="line">      <span class="comment">// &lt;alias name="fromName" alias="toName"/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义，这是我们关注的地方</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只关注处理 <code>&lt;bean /&gt;</code> 标签定义，也就是 <code>processBeanDefinition()</code> 方法。</p>
<p>这个方法实际上是把 xml 中的 bean 信息解析成 BeanDefinition，然后再包装成 BeanDefinitionHolder，最终注册到 BeanFactory 中的 beanDefinitionMap 中。</p>
<h2 id="4-5-Bean-是什么"><a href="#4-5-Bean-是什么" class="headerlink" title="4.5 Bean 是什么"></a>4.5 Bean 是什么</h2><p>学习到这里要停一下，来探讨一下 Bean 到底是个什么东西。从代码层面上讲，Spring 中的 Bean，可以简单认为是 BeanDefinition 的实例，BeanDefinition 中保存了 Bean 的信息，比如 Bean 指向的是哪个类、是否是单例的、是否懒加载等等。</p>
<p>再梳理一下关系：</p>
<ul>
<li><p>ApplicationContext 内部持有一个实例化的 BeanFactory（默认是 DefaultListableBeanFactory），以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
</li>
<li><p>BeanFactory 也就是 Bean 容器，它存放着 Spring 中的所有 Bean，存放的方式是用一张 map 存所有的 BeanDefinition（Bean 定义），在 DefaultListableBeanFactory 类中有一个 beanDefinitionMap 变量，就是那张存放所有的 Bean 定义的 map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory.java  181行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>也就是说，解析 xml，实际上就是把 xml 中的所有 Bean 信息都转换成 BeanDefinition 实例，然后存储在 beanDefinitionMap 中。</p>
</li>
</ul>
<p>来看一下 BeanDefinition 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 默认只有两种：SINGLETON、PROTOTYPE</span></span><br><span class="line">   <span class="comment">// 作用域：单例</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="comment">// 作用域：多例（每次获取 Bean 都会生成一个新的实例）</span></span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 据说不重要，略</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* ———————————————— 以下都是一些 get()、set() 方法 ———————————————— */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 父 Bean（Bean 继承 =&gt; 继承父 Bean 的配置信息）</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String parentName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 的作用域</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 是否懒加载</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 依赖的所有的 Bean（不是属性依赖，是 depends-on="" 属性设置的值）</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否可以注入到其他类型</span></span><br><span class="line">   <span class="comment">// 当注入是根据类型注入时，该设置有效，否则无效，例如根据名称注入无效，都能注入</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同一个 BeanDefinition 接口的多个实现</span></span><br><span class="line">   <span class="comment">// 如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称</span></span><br><span class="line">   <span class="comment">// Bean 可以反射创建，也可以工厂方法创建，这里就是指定工厂</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂方法名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* ———————————————— 下面这些懒得写了 ———————————————— */</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-（继续）解析-Bean-定义"><a href="#4-（继续）解析-Bean-定义" class="headerlink" title="4. （继续）解析 Bean 定义"></a>4. （继续）解析 Bean 定义</h2><p>回来，来看通过解析 xml 得到的一个个 Element，是怎么转换成 BeanDefinition 实例的。</p>
<p>上面说到，从 Element 解析成 BeanDefinition 实际上是这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">   processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>跟进去看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有自定义属性的话，进行相应的解析</span></span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共做了三件事：</p>
<ol>
<li>把 Element 解析成 BeanDefinitionHolder</li>
<li>把 BeanDefinitionHolder 中的 BeanDefinition 加入到 Bean 容器的 map 中（注册 Bean）</li>
<li>发送事件</li>
</ol>
<p>我们先只看第一步，把相关代码贴上来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 顺便提下，这里的 Element 是 w3c 定义的，对应一个个 xml 的节点</span></span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE); <span class="comment">// id</span></span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); <span class="comment">// name</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，转成 aliases 列表</span></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// StringUtils.hasLength() 是在判断非空</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果没有指定 id, 那么用 aliases 列表的第一个名字作为 beanName，并在 aliases 中删掉第一个名字</span></span><br><span class="line">   <span class="comment">// 例如 &lt;bean name="m1, m2, m3" class="com.pz.example.MessageServiceImpl" /&gt;</span></span><br><span class="line">   <span class="comment">// id(beanName)：m1  aliases：m2、m3</span></span><br><span class="line">   String beanName = id;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果解析的是 Bean，不包含子 Bean</span></span><br><span class="line">   <span class="comment">// 这里会是 null，然后检查一下 id、aliases、ele 是否是非空，再记录一下新增信息</span></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中</span></span><br><span class="line">   <span class="comment">// 这行结束后，一个 BeanDefinition 实例就出来了，具体怎么做的跟进去看</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有 id(beanName)，会进入下面这段代码</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 没有子 Bean，containingBean 是 null，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果不定义 id 和 name，那么按照刚才的举例</span></span><br><span class="line">               <span class="comment">// 1. beanName 为：com.pz.example.MessageServiceImpl#0</span></span><br><span class="line">               <span class="comment">// 2. beanClassName 为：com.pz.example.MessageServiceImpl</span></span><br><span class="line">               beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">               logger.trace(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 Bean 的类名和父 Bean</span></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    String parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">        parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 className 和 parent 创建 BeanDefinition</span></span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">        error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长很繁琐，将 Element 中的信息转换成了 BeanDefinition，其中最重要的是设置 BeanDefinition 的 beanName，也就是 Bean 的 ID。</p>
<p>至此，xml 中的一个节点，就被解析成了一个 BeanDefinition 实例（是一个）。</p>
<h2 id="5-注册-Bean-到-beanDefinitionMap-里"><a href="#5-注册-Bean-到-beanDefinitionMap-里" class="headerlink" title="5. 注册 Bean 到 beanDefinitionMap 里"></a>5. 注册 Bean 到 beanDefinitionMap 里</h2><p>当获取到一个 BeanDefinition 实例之后，需要把这个实例注册到 Bean 容器里，也就是加入到 BeanFactory 中的 beanDefinitionMap 里。</p>
<p>这一步发生在从 Element 解析到 BeanDefinition 的第二步（往上翻 <code>processBeanDefinition()</code> 方法，没多远），也就是说，注册 Bean 实际上是在解析 xml 时一并完成的，刚获取到一个 BeanDefinition 实例，就直接把这个实例加入到 beanDefinitionMap 里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册 Bean</span></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 往后看</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">         <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验</span></span><br><span class="line">    Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                   <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的 Bean 注册之后都会放在 beanDefinitionMap 里（这是个 ConcurrentHashMap）</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 处理重复名称的 Bean 定义的情况（说的是 Bean 循环引用覆盖）</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不允许重复，抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面分情况打日志，表明在不同情形下发生了 Bean 覆盖</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                            <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                            existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                             <span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                             <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                             <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                             <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Bean 覆盖</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">        <span class="comment">// 注意，"注册Bean" 这个动作结束，Bean 依然还没有初始化</span></span><br><span class="line">        <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// 为了迭代器正常，这里需要加锁锁住 beanDefinitionMap</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最正常的应该是进到这个分支</span></span><br><span class="line">            <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="comment">// 这是在处理手动注册的 singleton bean（我们一路走来并没有碰过）</span></span><br><span class="line">            <span class="comment">// 如 "environment"、"systemProperties" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它</span></span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory)"></a>prepareBeanFactory(beanFactory)</h1><p>看不太明白，抄一下代码和注释吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span></span><br><span class="line">   <span class="comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 PropertyEditorRegistrar</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span></span><br><span class="line">   <span class="comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span></span><br><span class="line">   <span class="comment">// Spring 会通过其他方式来处理这些依赖</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span></span><br><span class="line"><span class="comment">    * 之前我们说过，"当前 ApplicationContext 持有一个 BeanFactory"，这里解释了第一行。</span></span><br><span class="line"><span class="comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span></span><br><span class="line"><span class="comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span></span><br><span class="line"><span class="comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span></span><br><span class="line">   <span class="comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span></span><br><span class="line">   <span class="comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面几行代码我们可以知道，Spring 往往很 "智能" 就是因为它会帮我们默认注册一些有用的 bean，</span></span><br><span class="line"><span class="comment">    * 我们也可以选择覆盖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>到此为止，我们看完了 <code>refresh()</code> 的三个方法，Spring 已经解析并注册了所有 Bean，设置好了 BeanFactory，但是还没有真正实例化 Bean，创建 Bean 实例在 <code>finishBeanFactoryInitialization()</code> 方法中完成，本篇就先不继续学习了，到此为止。</p>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 入门</title>
    <url>/2019/10/08/Spring-Cloud/</url>
    <content><![CDATA[<br>

<p>十月的第二周，来学习 Spring Cloud 。</p>
<p>Spring Cloud 在我眼里是一套东拼西凑攒出来的框架，学这个框架学的都是一个个分散的零件。</p>
<hr>
<p>一切讲 Spring Cloud 教程的视频、书籍、博客，都是从微服务讲起的。讲技术之前先讲思想，来暗示技术的存在合理性。</p>
<p>微服务是个软件架构概念，一个大项目应该拆成多个小项目，各个小项目独立部署，松散耦合，各自实现小业务功能。微服务的对立面是单体式应用程序，一个应用程序内包含了所有需要的业务功能。</p>
<p>我理解的 Spring Cloud，是一个管理微服务的工具集。工具集，工具之集合也，意即 Spring Cloud 不是一个东西，而是一堆东西，它就是一个个分散的工具合在一起的总称。就像是下图展示的这样，Spring Cloud 是由 Eureka、Ribbon、Feign 等一个个零碎的组件组成的，学习 Spring Cloud 也应该是一个个逐个学习的。</p>
<p><img src="/assets/SpringCloud%E4%BD%93%E7%B3%BB.png" alt="SpringCloud体系"></p>
<p>（这张图是我在 B 站的一个教学视频《<a href="https://www.bilibili.com/video/av55304977" target="_blank" rel="noopener">Spring Cloud 从入门到实战</a>》中，讲者所认为的 Spring Cloud 框架。BTW：我认为这个教学视频讲得很出色。）</p>
<br>

<p>Spring Cloud 这么多组件，大部分都是 netflix 提供的开源组件，导包的时候就能发现，artifactId 总是 <code>spring-cloud-netflix- ……</code>。我初看到 netflix 还有点惊讶，毕竟这是网飞的英文原名，但我还是以为这是重名巧合，后来反复去查才发现，这真的就是那家做在线视频的网飞公司。</p>
<p>总有知名品牌搞跨界来颠覆我的认知，网飞搞微服务架构技术给我的感觉，就像是卖轮胎的米其林给人推荐餐厅一样，怎么就没听说爱奇艺去做开源编程组件的……</p>
<br>

<p>我自知 Spring Cloud 是一套框架的内容，其包含的一个个组件是有整合过的，不是真的分散毫无关联的，但我依旧认为，在学习时把 Spring Cloud 理解成一个个分散的组件，是能更高效理解的方式。下文的内容，也是一个个分开来写的。</p>
<hr>
<p>我认为微服务是一种很容易理解的架构，大项目分而治之。但是 Spring Cloud 的组件实在是有点多，为了方便理解，我还是举一个现实情景好了。</p>
<p>我觉得微服务就是个智能家居系统，如果有一个家用电器，能够同时看电视、洗衣服、吹空调、冰鲜食物等等（<font color="#32CD32">单体式应用程序</font>），还是一件比较恐怖的事情，我们比较希望的事情是，电视是电视、洗衣机是洗衣机、空调是空调……每个家用电器做自己的事情（<font color="#32CD32">微服务</font>）。</p>
<ol>
<li>为了实现智能家居的效果，我们买了一个智能音箱（<font color="#32CD32">Zuul</font>），对智能音箱喊，智能音箱帮我们去做事情。</li>
<li>当然，这个的前提是，家电和智能音箱连在同一个局域网里，智能音箱能找到家电（<font color="#32CD32">Eureka</font>）。</li>
<li>我们的家电之间还要能互动（<font color="#32CD32">Feign</font>），比如红外线感应器感应到我回家了，空调就自动打开。</li>
<li>当我们有多个相同的家电时，要合理分配（<font color="#32CD32">Ribbon</font>），比如有两个扫地机器人，要让两个分开扫屋子。</li>
<li>当家电出故障时，要及时做出调整（<font color="#32CD32">Hystrix</font>），比如空调坏了，智能音箱就不要一直让空调调温度了。</li>
<li>此外还要配置家电使用时段等信息（<font color="#32CD32">Config</font>），监控家电（<font color="#32CD32">Actuator</font>），查询家电是为何而工作（<font color="#32CD32">Zipkin</font>）等等。</li>
</ol>
<p>你能感受出来，Spring Cloud 就是一套协调微服务正常运行的框架。</p>
<hr>
<p>学习 Spring Cloud 至少要有一点点的 Spring Boot 的基础，因为 Spring Cloud 这个框架是基于 Spring Boot 的，里面每个组件的配置过程，其实都是 Spring Boot 的内容，所以我们要先了解一下，Spring Boot 是怎么使用的。</p>
<p>Spring Boot，boot 这个词用得真是传神，你去查 boot 的意思，它有一个动词词性的释义：（计算机）启动、操作系统已安装。什么意思呢，就是说 Spring Boot 是一个帮你配好 Spring 几乎所有配置的框架，你使用它，相当于直接配好了所有东西，拿来就直接用。</p>
<p>对 Spring 没有任何了解，上来就看 Spring Boot 的人，可能并不理解程序员为何如此吹捧它，好像它实现的功能也就那么一回事。有这种感觉，是因为不清楚 Spring 的配置过程有多么繁琐，基本可以用“配置地狱”来形容。Spring Boot 的出现，是为了解决 Spring 配置过于复杂的痛点。写代码时你引了个包，加了个注解，实现了一个功能，看上去平平无奇，这个平平无奇就是 Spring Boot 的作用。</p>
<br>

<p>我们今天学习的是 Spring Cloud，由于它基于 Spring Boot，因此在配置方面，我们其实是在学习 Spring Boot 。</p>
<p>Spring Boot 使用起来可以简单地分两步走：</p>
<ol>
<li>添加第三方依赖。</li>
<li>注解声明，我要使用 Spring Boot 啦。</li>
</ol>
<p>第一步：添加第三方依赖。我采用 maven 来管理第三方依赖，maven 是一个管理项目的工具，对此我也基本处于小白状态，只是知道它可以用 xml 文件的形式来配置，以及简单地写写。</p>
<p>添加第三方依赖对于 maven 来讲是件很容易的事情，在 <code>dependencies</code> 中添加上需要的依赖就可以了。例如我要使用 Spring Cloud 其中一个组件 Eureka，我只需要在 Eureka 服务端的 <code>pom.xml</code> 文件中，添加这么一点代码。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="comment">&lt;!-- 全球唯一标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- 构件标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                            <span class="comment">&lt;!-- 版本号（自动，无需填写） --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：注解声明要使用 Spring Boot。这一步在启动类中添加，启动类怎么说呢，可以认为是新建完工程模块之后，唯一的那个 <code>java</code> 文件里面的类，哎呀我也道行不够，反正就这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种是一种通用写法，是在声明这个类是一个 Spring Boot 的启动类。如果更具体一些，例如我要使用 Spring Cloud 中的 Eureka 组件，要声明某个类是服务端，就要多加个注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于 <code>@SpringBootApplication</code> 等这些注解是怎么工作的，<code>main</code> 方法里面的 <code>SpringApplication.run()</code> 方法在干什么，这个就要自己去看 Spring Boot 的内容了。</p>
<br>

<p>Spring Boot 在设计之初就有一种理念，即“约定大于配置”，意思是说，我们约定好了就用某种方式来配置。比如说原来一个程序，里面有 A、B、C 三个地方要配置，A 有 5 种配置方法，B 有 3 种，C 有 4 种，这一排列组合就有 60 种配置方式，但是你得 A、B、C 一个个地手动配，大家都配烦了，这时 Spring Boot 配好了其中一种，说既然这种使用得最多，也就别一个个地配了，就用这种吧。Spring Boot 的代码，在字里行间中就有这种约定俗成的“潜规则”感，例如启动类起名都叫 <code>xxxApplication.java</code> ，别问，问就是约定俗成。但是潜规则这种东西，说不清道不明的，还是得自己多试试脾气。</p>
<hr>
<h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p>Eureka 是 Spring Cloud 的头号组件，它的使用方法也代表了 Spring Cloud 中组件的一般使用方法，所以我们借着 Eureka 来学习，Spring Cloud 一般是如何配置和使用的。但是在此之前，我们先要知道 Eureka 是做什么的。</p>
<p>Spring Cloud 是一种微服务架构，比如说原来一个项目实现 15 个功能点，现在这 15 个功能点拆分成 10 个小项目，由这 10 个小项目组合起来作为一个微服务大项目。如果用图示可能会更直观一些：</p>
<p><img src="/assets/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="微服务示意图"></p>
<p>这是我认为的微服务架构示意图，像是局域网一样采用星型拓扑结构，每一个小黑点代表一个微服务，联结起来组成一个微服务群。</p>
<p>Eureka 正如上图中的黑线，它的作用是把一个个分散的微服务联结起来，让这些微服务组成一个集群，让每个微服务都能“登记在册”。</p>
<br>

<p>Eureka（音标 [juˈriːkə] ），用更为专业的术语来描述它，应该称它为“服务的注册和发现中心”，服务就是微服务，注册就是让一个个的微服务登记在册，发现就是在登记册中找到这一个个服务。</p>
<p>再换句话说，每个微服务，都要到 Eureka 那里签到（注册），要找服务的话，也要去 Eureka 那里去找（发现），也就是说，Eureka 是微服务的中介中心。</p>
<p>说来 Eureka 这个词还有点美式幽默，它是阿基米德发现浮力定律后兴奋地在大街上裸奔，边跑边喊“知道了！我知道了！”的那个词，当时的含义是“我终于找到浮力定律了！”。在微服务框架中，Eureka 的含义是“啊我发现这个服务了”，即代表某个服务在中心注册过了，也代表在中心找到了这个服务，颇有幽默意味。</p>
<br>

<p>Eureka 组件中有两种角色：服务端、客户端。如果用上张图来解释这两种角色，那么服务端是灰点，客户端是黑点，黑点（客户端）注册到灰点（服务端）之后，每次可以通过灰点找到黑点。其实呢这是一个 <code>C/S 架构</code>，Eureka 就是一个基于 <code>C/S 架构</code>而设计出来的组件。</p>
<p>现在我们来思考一下，如何使用 Eureka。我们通过 Eureka，目标是实现【把一个个微服务登记在册，以备用时查找】，加以思索会发现，Eureka 的功能是【服务注册和服务发现】这样很通用的功能，对于不同的微服务、不同的项目，功能也是一样的。我们并不需要改变功能，而应该改变例如 IP 地址、端口号等等的配置信息。也就是说，【功能】和【配置】是分开的，对于【功能】，所有的微服务都是一样的，既然都是一样的那就让框架去写，我们只写【配置】。</p>
<p>Spring Cloud 的组件使用起来基本都是这样子，你并不需要写代码，只需要写一写配置文件就可以了。</p>
<br>

<p>我们来看看，Eureka 的配置文件怎么写吧。</p>
<p>Spring Cloud 所有组件的配置文件，都可以在 resource 目录下创建一个 <code>application.yml</code> 的 yml 文件。刚才说了 Eureka 分为服务端和客户端，那么分开看：</p>
<p>Eureka 的服务端配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span>                      <span class="comment"># 服务的端口号（Eureka 默认使用 8761 端口）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">pz-eureka-server</span>        <span class="comment"># 服务的名字</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>   <span class="comment"># 将当前的server作为client注册</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span>         <span class="comment"># 获取其他server的数据</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">     defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span>    <span class="comment"># 注册中心的访问地址</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span>               <span class="comment"># 关闭自我保护机制</span></span><br><span class="line"><span class="attr">    eviction-interval-timer-in-ms:</span> <span class="number">5000</span>           <span class="comment"># 每隔 5 秒清理失效服务</span></span><br></pre></td></tr></table></figure>

<p>Eureka 的客户端配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr"> port:</span> <span class="number">5750</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr"> application:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pz-eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr"> client:</span></span><br><span class="line"><span class="attr">  service-url:</span></span><br><span class="line"><span class="attr">   defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span>   <span class="comment"># 注册中心的访问地址</span></span><br><span class="line"><span class="attr"> instance:</span></span><br><span class="line"><span class="attr">  prefer-ip-address:</span> <span class="literal">true</span>      <span class="comment"># 把当前服务的ip注册到eureka的server</span></span><br></pre></td></tr></table></figure>

<p>照着配，用的时候再去理解。yml 文件是一种更人性化的配置文件格式，它采用 YAML 语言来编写，看一眼主要特征也就看出来了：靠缩进来表示层级。</p>
<p>差点忘了讲，代码中还是要写一行的，加一行注解，表示自己要使用 Eureka 组件。这行注解就加在上文提 Spring Boot 时，启动类的上方，写在 <code>@SpringBootApplication</code> 注解旁边：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span>      <span class="comment">// 就是这行注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eureka 服务的注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是服务端，那么注解是 <code>@EnableEurekaServer</code>，如果是客户端，那么连注解都不用加。</p>
<br>

<p>我们其实相当于说完了 Eureka，只不过非常潦草，那回头来多看一看 Eureka 这个组件。Eureka 是 Spring Cloud 这一微服务框架的注册和发现中心，它专注的事情是一项历史悠久的内容：服务发现。我查询了相当长时间的资料，觉得目前的学习阶段，对于服务发现这一内容还是浅尝辄止为好：服务发现有两种模式，一种是【客户端发现模式】，一种是【服务端发现模式】，Eureka 属于前者。</p>
<p>关于 Eureka 的最基本原理，要知道的有这么几条：</p>
<ol>
<li>Eureka 采用 C/S 架构。</li>
<li>Eureka 的客户端向服务端不停地发送心跳，来保持自己的注册状态，如果不发送了，服务端会移除它。</li>
<li>Eureka 的服务端有自我保护机制，此时会认为网络本身有问题，不移除服务。</li>
</ol>
<p>推荐下面三篇文章一读：</p>
<p><a href="https://martian101.github.io/2017/04/20/微服务之服务发现-Eureka的介绍与使用/" target="_blank" rel="noopener">《微服务之服务发现 Eureka 的介绍与使用》</a></p>
<p><a href="https://www.cnblogs.com/chihirotan/p/11366394.html" target="_blank" rel="noopener">《作为服务注册中心，Eureka 比 Zookeeper 好在哪里》</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">《CAP 定理的含义》</a></p>
<br>

<hr>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>Zuul 是 Spring Cloud 的服务网关，能够实现动态路由、IP 过滤、数据监控等功能，并内部集成负载均衡功能，不过我们今天只看动态路由这一个功能。</p>
<br>

<p>了解 zuul 的作用，我们要先知道什么是网关（Gateway）。我理解的网关（这里的网关，可以更确切地叫做 API 网关）是一个入口，入口之外是用户，入口之内服务系统，用户并不需要知道系统内部是什么样子，用户只想完成功能，那么这时让网关去处理，用户走到网关面前，跟网关说我要做什么，网关就带用户过去。</p>
<p>这里说入口之外是用户，是一个场景化的说法，其实也不一定是用户，比如 A 服务想调用 B 服务，也可以通过网关来调用。维基对于网关的解释是“ 网关是转发其他服务器通信数据的服务器 ”，但我觉得也不是很易懂，可能网关这个概念就是难表述一些，但其实是一件很常见的功能。</p>
<p><img src="/assets/api_gateway.png" alt="api_gateway"></p>
<p>zuul 是 Spring Cloud 的 API 网关组件，实现服务网关的功能。</p>
<p>举一个很简单的例子：比如有一个服务叫 serviceA，这个服务的 url 地址是 <code>http://localhost:8001/</code>，还有一个服务叫 serviceB，它的 url 地址是 <code>http://localhost:8002/</code>，两个服务的 url 地址的区别在于端口号不同，如果调用的话是一件很糟糕的事情，因为既不便于识别，也不便于维护。这里只有两个服务，若是上百个，那真的是很折磨人。通过 zuul，可以通过新的 url 来访问服务，比如通过 <code>http://localhost:8000/A</code> 访问 serviceA，再通过 <code>http://localhost:8000/B</code> 访问 serviceB，这样就很直观，也很便捷。</p>
<p>你应该看出来了网关（尤其是 API 网关）的入口作用，它把控了内外的通道，使得【外部访问 -&gt; 网关 -&gt; 内部服务】。上述只写了网关可以实现动态路由的功能，其实既然把控了入口，也完全可以做 IP 过滤、数据监控等等的功能。但是我们今天只关注动态路由这个功能，也就是上面例子中的变更访问 url 地址。</p>
<br>

<p>我们来看一下 zuul 的配置文件，我写了一则示例放在下面：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">5752</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">pz-zuul</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    pz-eureka-client:</span> <span class="string">/client/**</span></span><br></pre></td></tr></table></figure>

<p>你定睛一看，发现这个配置文件一共配了四个块，前三个块都是 Spring Cloud 的通用配置内容：服务端口号、服务名、服务中心，只有第四个块，配置到了 zuul，而且只配置了一项内容。</p>
<p>配置的这项内容是，把服务名为 <code>pz-eureka-client</code> 的服务，路由到一个新的 url 地址上（** 代表任意 url）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http://localhost:5752/client/**</span></span><br></pre></td></tr></table></figure>

<p>何其简单呐！</p>
<p>这一次启动类的注解是 <code>@EnableZuulProxy</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zuul 服务的注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>好吧，上面的配置文件简单，是因为 zuul 的那么多网关功能，只用到【路由】，其他功能都没有用 :P 。而且设置路由的时候，还使用了省略写法。我们首先把路由的不省略的写法写出来：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 省略写法</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    pz-eureka-client:</span> <span class="string">/client/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非省略写法</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    pz-eureka-client:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/client/**</span>             <span class="comment"># 路径规则</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">pz-eureka-client</span>  <span class="comment"># 服务名，当和routes后的名字同名时可以省略</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://localhost:8000</span>   <span class="comment"># 指定url，这个和 serviceId 任选其一使用，但是这种方式无法实现负载均衡</span></span><br></pre></td></tr></table></figure>

<p>zuul 的配置还有一些别的可讲的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 路由前缀</span></span><br><span class="line"><span class="attr">zuul:</span> </span><br><span class="line"><span class="attr">  routes:</span> </span><br><span class="line"><span class="attr">    pz-eureka-client:</span> <span class="string">/client/**</span></span><br><span class="line"><span class="attr">    prefix:</span> <span class="string">/api</span>                   <span class="comment"># 设置统一的路由前缀 本例中网关访问 /api/client/**</span></span><br><span class="line"><span class="attr">    strip-prefix:</span> <span class="literal">false</span>            <span class="comment"># 表示不要把代理的前缀去掉，否则网关访问 /api/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略（即不创建路由规则）</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  ignored-services:</span> <span class="string">eureka-client</span>  <span class="comment"># 忽略服务，本例是忽略名为 eureka-client 的服务</span></span><br><span class="line"><span class="attr">  ignored-patterns:</span> <span class="string">/**/hello/**</span>   <span class="comment"># 忽略url路径，本例是忽略所有包含 /hello/ 的路径</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><p>Ribbon 是 Spring Cloud 中负责负载均衡的组件。负载均衡，字面意思是指把负载合理地分摊出去，例如我们设计好了一个网站，后端有十台服务器，怎么能让十台服务器同时合理工作，而不出现有一台跑死、剩下九台闲死的状况，就是负载均衡的目标。维基对于负载均衡作用的阐释很得我心：</p>
<blockquote>
<p> 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。 </p>
</blockquote>
<p>在微服务架构中，某个服务部署了多个是个常见的情况，那么当另一个服务需要调用这好几个同一服务时，该如何调用就是一个负载均衡的问题，Ribbon 的作用就是解决这个调用时的负载均衡问题。例如有 5 台服务器在同时运行 A 服务，B 服务该怎么调用 A 服务，是随机挑一个调用，还是找最闲的服务器调用，还是指定哪一台调用，这是个负载均衡的问题，需要 Ribbon 组件来处理。</p>
<br>

<p>下面该讲 Ribbon 的配置了，讲到现在是第三个组件，你应该发现，Spring Cloud 的配置通常是非常简单的。但 Ribbon 尤其过分，你甚至都可以不用配置 <code>application.yml</code> 文件，写一个注解就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>    <span class="comment">// @LoadBalanced 声明基于Ribbon的负载均衡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的位置不再是启动类之上，而放在了 RestTemplate 类之上。RestTemplate 类是 Spring 框架发起 HTTP 请求的一个类，它在服务中采用 RESTful 风格（RESTful 风格自己去查）与 HTTP 服务进行通信，简化了操作，用后就会觉得非常优雅。</p>
<p>调用服务的时候，实际上也就是在发送 HTTP 请求，因此如果在调用服务时考虑负载均衡的问题，就要在发送 HTTP 请求的类—— RestTemplate 类上添加注解，加上 <code>@LoadBalanced</code>。</p>
<br>

<p>不用配置 yml 文件的原因是，ribbon 默认采用的负载均衡规则为轮询（轮流访问服务器），如果你想使用别的负载均衡规则，那还是要配置一下，例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pz-eureka-client:</span>  <span class="comment"># 要调用的服务的服务名（需要负载均衡的那个）</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span>  <span class="comment"># 随机选择</span></span><br></pre></td></tr></table></figure>

<p>下面是 ribbon 的负载均衡策略说明，来源：<a href="https://www.e-learn.cn/content/qita/2212784" target="_blank" rel="noopener">《ribbon负载均衡策略》</a></p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">中文</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RandomRule</td>
<td align="left">随机策略</td>
<td align="left">随机选择server</td>
</tr>
<tr>
<td align="left">RoundRobinRule</td>
<td align="left">轮询策略</td>
<td align="left">按顺序循环选择server</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td align="left">重试策略</td>
<td align="left">在配置时间内选择server不成功，则一直尝试选择一个可用的server</td>
</tr>
<tr>
<td align="left">BestAvailableRule</td>
<td align="left">最低并发策略</td>
<td align="left">逐个考察server,如果server断路打开，则忽略，再选择并发连接最低的server</td>
</tr>
<tr>
<td align="left">AvailabilityFilteringRule</td>
<td align="left">可用过滤策略</td>
<td align="left">过滤掉一直连接失败并标记为circuit breaker tripped的server,过滤掉高并发连接的server</td>
</tr>
<tr>
<td align="left">WeightedResponseTimeRule</td>
<td align="left">响应时间加权策略</td>
<td align="left">根据server的响应时间分配权重，响应时间越长，权重越低，被选择的概率越低;响应时间越高，权重越高，被 选中的概率越高</td>
</tr>
<tr>
<td align="left">ZoneAvoidanceRule</td>
<td align="left">区域权衡策略</td>
<td align="left">综合判断server所在区域的性能和server的可用性轮询选择server</td>
</tr>
</tbody></table>
<br>



<hr>
<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>Hystxic 是 Spring Cloud 的容错框架，也被称为熔断器。在高并发访问下，系统服务的稳定性非常重要，各种不可控因素都会影响服务的运行，例如网络连接突然变慢、服务脱机、访问量激增等等，Hystrix 就是用来让微服务正常运行的一套容错组件。这一容错组件能实现很多功能，例如隔离、降级、熔断、监控等等。</p>
<p>Netflix 这家公司真的是起名鬼才，Eureka 的意思是阿基米德裸奔时喊的“我发现了”，Hystrix 的意思是豪猪（Hystrix 的 logo 也是一只豪猪），表示这个组件跟豪猪一样浑身是刺能很好地保护自己。我看博文的时候，看到有一哥们说：</p>
<blockquote>
<p> netflix 使用这畜生来命名这框架实在是非常的贴切。</p>
</blockquote>
<p>太草了。</p>
<br>

<p>Hystrix 最常用的三个功能分别是资源隔离、降级、熔断。</p>
<ol>
<li><p>资源隔离</p>
<p>Hystrix 的隔离分为两部分，分别是<strong>线程池隔离</strong>和<strong>信号量隔离</strong>。</p>
<p>举个具体的例子，来解释这两种隔离方法。现在有两个服务：服务1和服务2，原本这两个服务一起运行，因为某些原因，服务1的访问量特别大，把服务器给挤崩了，结果服务2跟着遭殃，也无法使用了。<strong>线程池隔离</strong>是指，给服务1和服务2分别设置一个线程池，服务1的访问在自己的线程池当中，即使自己崩了也不会影响服务2。<strong>信号量隔离</strong>是指，服务1和服务2仍然共用一个线程池，但是给这个线程池设置一个最大访问量，超过了就不接受新的访问，保证服务器不崩。</p>
<p><strong>线程池隔离</strong>有一定的性能损耗，但是依旧是默认的资源隔离策略，毕竟<strong>信号量隔离</strong>会直接丢弃请求。当服务类型很多，并发量又大，建立线程池损耗明显亏损较多时，建议采用<strong>信号量隔离</strong>。</p>
<p>这一块的配置，emm，我象征性地找了一张图，入门嘛，不学了哈哈哈。（图片来源找不到了，抱歉……）</p>
<p><img src="/assets/Hystrix%E9%85%8D%E7%BD%AE.png" alt="Hystrix配置"></p>
</li>
<li><p>降级</p>
<p>当服务负荷太高，已经无法继续下去的时候，为了不让请求阻塞，让服务器崩溃掉，可以事先准备好一个“次等”的返回结果，例如告知用户【抱歉服务器崩溃了】，或者只完成一部分核心服务，至少不会让请求无限地进行下去。这个事先准备好的“次等”的返回结果，就是<strong>降级</strong>（fallback）。</p>
<p>一般服务降级的触发原因有两种，一种是线程池满了，另一种是请求超时。</p>
<p>降级的使用方法，是在一个接口方法之上，增加 <code>@HystrixCommand</code> 注解，标明当服务崩溃时，要跳转到哪个降级接口上。部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原接口方法</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(defaultFallback = <span class="string">"fallClass"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryById</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">    String url = <span class="string">"http://userService/user/"</span> + id;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降级接口方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fallClass</span> <span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"服务器异常，无法查询用户"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hystrix 的配置参数与方法，在这里暂时不提。</p>
</li>
<li><p>熔断</p>
<p>我在三年前第一次听到“熔断”这个词，那时中国股市引入了熔断机制，如果当日股市的涨跌幅超过 5 %，熔断机制开启，股市暂停 15 分钟，暂停回来后涨跌幅超过 7 %，熔断机制再次开启，股市直接停盘。我听说股市里引入熔断的概念是为了设定一个阈值，超过阈值就暂停，让股市冷静冷静。不过当时的中国股市不是很容易冷静，开盘十几分钟就熔断，一恢复又熔断，总共交易了不到 20 分钟当天就收市了，这事一发生，第二天熔断机制就被废除了。</p>
<p>Hystrix 的熔断机制指的是，当服务器的错误率达到某个设定值时，服务暂停，之后的所有请求全部丢弃，之后服务会去试探是否恢复正常、能否重启，试探成功就重启继续运行。</p>
<p>这里的错误率、熔断时间、重启要求等，都是要进行配置的地方。这里需要配置的有点多，Hystrix 也有一套默认配置值，我觉得就暂且不深探究了。</p>
</li>
</ol>
<br>

<hr>
<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>Feign 是 Spring Cloud 的服务间通信工具。这个基本上是 Spring Cloud 中最重要的组件，因为微服务作为一个集群，总是要相互调用共同协作的，Feign 的作用就是微服务之间的通信。不使用 Feign 也能通过 RestTemplate 类等方式进行通信，但是 Feign 是 Spring Cloud 已经封装好的，使用起来更为优雅快捷的组件，所以一定要学习。</p>
<p>Feign 算是 Spring Cloud 的集大成者，它集成了 Eureka、Ribbon、Hystrix 等组件（因此默认支持负载均衡和服务熔断），支持 Spring MVC 注解，在此之外还基于注解简化操作，因此你可以认为，Feign 是一个活儿全的服务通信工具。（活儿不全的服务通信组件是 Ribbon + RestTemplate）</p>
<br>

<p>在这里我们先说使用方法，再说配置。</p>
<p>服务A要调用服务B的接口方法，正常的操作是这样的：服务B有几个接口对外开放，可以调用，任何地方都可以在允许的情况下，通过发送 HTTP 请求来调用服务B的接口，服务A也不例外。因此服务A想调用服务B的接口，也要在得知服务B的请求 url 前提下， 向服务B发送 HTTP 请求（可以通过 RestTemplate 来发送）。</p>
<p>Feign 的作用在于，发 HTTP 请求这种事情大同小异，我提供一个模板，你照着这个模板把地址之类的参数写清楚，我帮你发 HTTP 请求。顺便我帮你把负载均衡、服务容错这些事情一起处理了。</p>
<p>例如下面的这段代码（涉及到一点 Spring MVC 的知识，将就着看一看）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Feign 来实现一个接口，接口中调用了服务B的获取用户信息接口</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"pz-service-B"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignProviderClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"user/&#123;userId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Feign 所定义的接口，让服务A能够在不发送 HTTP 请求的情况下，调用服务B的获取用户信息接口</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"feign"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeignProviderClient feignProviderClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserFromServiceB</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> feignProviderClient.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分上下两块。上面的代码是使用 Feign 组件，下面的代码是服务A调用服务B的接口。</p>
<p>原来呢，下面的代码，即服务A调用其他服务的接口，是需要自己发送 HTTP 请求的。现在注入了 Feign 之后（<code>@Autowired</code> 那块），直接调用 Feign 就可以了。为什么呢，因为在上面的代码中，Feign 已经连接上服务B了。</p>
<p>梳理一遍，照着代码从上到下具体走一通。</p>
<ol>
<li><p>我们首先定义了一个接口类：<code>FeignProviderClient</code> 类，该类通过注解 <code>@FeignClient</code> 表明它要使用 Feign 组件，并且指明它要连接的服务是一个名为 <code>pz-service-B</code> 的服务（服务B）。</p>
</li>
<li><p>在刚刚定义的接口类 <code>FeignProviderClient</code> 类中，声明了一个方法 <code>getUser</code>，这个方法的作用是通过用户ID获取用户信息。但是这个方法并没有实现类，它只是单纯地声明了出来：有这么一个方法。</p>
<p>为什么呢，因为这个方法在服务B那里实现，在这里我们并不需要去实现它，我们只需要声明它的存在，当使用它时，让 Feign 去发送请求调用方法。</p>
</li>
<li><p>我们又定义了一个 Controller 类：<code>FeignHandler</code> 类，这个类是我们服务A的一个 Controller 类。</p>
</li>
<li><p>在这个 <code>FeignHandler</code> 类当中，我们首先自动注入了 <code>FeignProviderClient</code> 类。</p>
</li>
<li><p>在这个 <code>FeignHandler</code> 类当中，我们新定义了一个接口方法 <code>getUserFromServiceB</code>，这个方法的目的是，调用服务B的接口，通过用户ID拿到用户信息。</p>
<p>这个新的接口方法的具体实现，就是使用刚刚定义的 Feign 接口类里面的方法。我们调用 Feign 接口类里面声明的方法，怎么发请求，怎么拿到数据，这个让 Feign 去解决。</p>
</li>
</ol>
<br>

<p>写一个使用的更全面一点的 Feign 接口类，注解属性的作用已备注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(</span><br><span class="line">        value = <span class="string">"pz-service-B"</span>,                   <span class="comment">// 指定FeignClient的服务名称，这里使用value，其实使用name、serviceId也可，作用相同</span></span><br><span class="line">        path = <span class="string">"/user"</span>,                           <span class="comment">// 请求的前缀名，例如这里是：https://192.168.1.101/8080/user</span></span><br><span class="line">        url = <span class="string">"https://192.168.1.101/8080"</span>,       <span class="comment">// 手动指定请求的url，其实在一个Eureka注册下是不必写的，写清楚服务名就可以了</span></span><br><span class="line">        configuration = FeignConfiguration.class, <span class="comment">// 配置类</span></span><br><span class="line">        fallback = UserRemoteClientHystrix.class  <span class="comment">// 集成Hystrix，服务容错的降级类</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignProviderClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>我们还是写一点原理，下面这段内容引自<a href="https://blog.csdn.net/neosmith/article/details/52449921" target="_blank" rel="noopener">《使用 Spring Cloud Feign 作为 HTTP 客户端调用远程 HTTP 服务》</a>。</p>
<blockquote>
<p> <code>@FeignClient</code> 用于通知 Feign 组件对该接口进行代理，使用者可直接通过 <code>@Autowired</code> 注入。Spring Cloud应用在启动时，Feign 会扫描标有 <code>@FeignClient</code> 注解的接口，生成代理，并注册到 Spring 容器中。生成代理时 Feign 会为每个接口方法创建一个 RequetTemplate 对象，该对象封装了 HTTP 请求需要的全部信息，请求参数名、请求方法等信息都是在这个过程中确定的，Feign 的模板化就体现在这里。</p>
</blockquote>
<br>

<p>最后我们来补 Feign 的配置，其实跟前文的任何一个组件都差不多，启动类加注解，application.yml 文件里配置信息。</p>
<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 就是这行注解，否则在 Controller 里 @Autowired 注入 Feign 接口类时会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml 配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span> <span class="comment"># 这里是开启 Hystrix 服务容错，更多配置内容这里不提</span></span><br></pre></td></tr></table></figure>

<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器（的插入元素方法）</title>
    <url>/2020/01/12/Java-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<br>

<p>一月的第二周，来补习 Java 的容器设计。</p>
<p>自己所欠的 Java 基础实在是多，主要是因为能力不足。如今的我，感觉可以追进 Java 容器的源码中了，之前写过了 HashMap 和 TreeMap，这周来看剩下的容器。</p>
<p>像是之前写 HashMap 和 TreeMap 一样，学习每个容器时从 add() 或 put() 方法开始，牵扯出背后的代码与逻辑。</p>
<hr>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList 是列表的一种，特点是能够自动扩容（即动态数组）。</p>
<p>ArrayList 的 add() 方法本身很简短，在检查容量大小之后，在数组中添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这三行代码的方法中只能看出，ArrayList 的内部是由数组实现的，也就是代码中的 <code>elementData</code>。</p>
<p>继续追进去看里面的代码，会发现代码很零碎，一个方法嵌套着另一个，而每一个方法都只有几行代码而已。因此我整理了一下，将涉及到的代码整理成下面这个样子（每一行很长，要水平拖动才能看到全部）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;                                                                                                     |</span><br><span class="line">                                                                                                                              |</span><br><span class="line">   ┌-----------------------------------------------------------------------------------------------------------------------┐  |</span><br><span class="line">   | ensureCapacityInternal(size + <span class="number">1</span>);                                                                                     |  ■ 确保列表容量足够</span><br><span class="line">   |               ↘ ↘ ↘                                                                                                   |  |</span><br><span class="line">   | <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                                                                |  |</span><br><span class="line">   |                                                                                                                       |  |</span><br><span class="line">   |    ┌--------------------------------------------------------------------------------------------------------------┐   |  |</span><br><span class="line">   |    | ensureExplicitCapacity( ┌-------------------------------------------------------------------------------┐ ); |   |  ■ 检查列表容量足够</span><br><span class="line">   |    |                         | calculateCapacity(elementData, minCapacity)                                   |    |   |  ■ 计算列表容量，最小是<span class="number">10</span></span><br><span class="line">   |    |          ↓↓↓            |                 ↘ ↘ ↘                                                         |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            | <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123; |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;                   |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |         <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);                       |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |     &#125;                                                                         |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |     <span class="keyword">return</span> minCapacity;                                                       |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            | &#125;                                                                             |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            └-------------------------------------------------------------------------------┘    |   |  |</span><br><span class="line">   |    |                                                                                                              |   |  |</span><br><span class="line">   |    |  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                                                      |   |  |</span><br><span class="line">   |    |      modCount++;                                                                                             |   |  ■ 每一次检查容量，都会使modCount+<span class="number">1</span></span><br><span class="line">   |    |      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)                                                               |   |  |</span><br><span class="line">   |    |                                                                                                              |   |  |</span><br><span class="line">   |    |        ┌-----------------------------------------------------------------┐                                   |   |  |</span><br><span class="line">   |    |        | grow(minCapacity);                                              |                                   |   |  ■ 当最小容量超过列表长度时，扩容</span><br><span class="line">   |    |        |     ↘ ↘ ↘                                                       |                                   |   |  |</span><br><span class="line">   |    |        | <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                            |                                   |   |  |</span><br><span class="line">   |    |        |     <span class="keyword">int</span> oldCapacity = elementData.length;                       |                                   |   |  |</span><br><span class="line">   |    |        |     <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);         |                                   |   |  ■ 每次容量扩容<span class="number">1.5</span>倍</span><br><span class="line">   |    |        |     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)                          |                                   |   |  |</span><br><span class="line">   |    |        |         newCapacity = minCapacity;                              |                                   |   |  |</span><br><span class="line">   |    |        |     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)                       |                                   |   |  |</span><br><span class="line">   |    |        |         newCapacity = hugeCapacity(minCapacity);                |                                   |   |  |</span><br><span class="line">   |    |        |     elementData = Arrays.copyOf(elementData, newCapacity);      |                                   |   |  ■ 将原数组的数据，拷贝到新数组中</span><br><span class="line">   |    |        | &#125;                                                               |                                   |   |  |</span><br><span class="line">   |    |        └-----------------------------------------------------------------┘                                   |   |  |</span><br><span class="line">   |    |  &#125;                                                                                                           |   |  |</span><br><span class="line">   |    |                                                                                                              |   |  |</span><br><span class="line">   |    └--------------------------------------------------------------------------------------------------------------┘   |  |</span><br><span class="line">   | &#125;                                                                                                                     |  |</span><br><span class="line">   └-----------------------------------------------------------------------------------------------------------------------┘  |</span><br><span class="line">                                                                                                                              |</span><br><span class="line">    elementData[size++] = e;                                                                                                  |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;                                                                                                              |</span><br><span class="line">&#125;                                                                                                                             |</span><br></pre></td></tr></table></figure>

<p>从 ArrayList 添加元素的 add() 方法可以看出：</p>
<ol>
<li>ArrayList 内部由数组实现</li>
<li>ArrayList 的默认容量大小是 10，每次扩容时增加到原来的 1.5 倍（通过位运算实现）</li>
<li>ArrayList 每次扩容，都会将之前保存的内容，全部复制拷贝到新数组中。</li>
<li>每次 ArrayList 增加元素时，会在确保容量足够的时候就增加 modCount。</li>
<li>ArrayList 允许添加 null。</li>
</ol>
<br>

<h2 id="没什么用的小知识"><a href="#没什么用的小知识" class="headerlink" title="没什么用的小知识"></a>没什么用的小知识</h2><p>曾经在其他博客中看到 <code>Arrays.asList()</code> 方法，这个方法与 ArrayList 有李逵李鬼的关系。</p>
<p><code>Arrays.asList()</code> 方法可以将多个元素直接拼接为列表，并返回该列表，如下面这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>, <span class="string">","</span>, <span class="string">"world"</span>, <span class="string">"!"</span>);</span><br></pre></td></tr></table></figure>

<p>应当注意的是，这里得到列表是无法增加元素的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="string">"准备报错"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行该语句时报错</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.lang.UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p>现在去探索为什么会报错。看源码时发现，在 <code>Arrays.asList()</code> 方法的内部，是这么处理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它返回了一个 ArrayList 对象，但是很坑的是，此 ArrayList 非彼 ArrayList，这里的 ArrayList，是 Arrays 类内部定义的列表类，而不是我们常规意义上的动态列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...构造方法、类方法如size()、get()等</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个内部定义的 ArrayList 类，是没有重写父类 AbstractList 类的 add() 方法的，而父类默认的 add() 方法是直接抛 <code>UnsupportedOperationException</code> 异常的。</p>
<p>回看 <code>Arrays.asList()</code> 方法，它在注释中已经说明清楚了：</p>
<blockquote>
<p>Returns a fixed-size list …</p>
</blockquote>
<p>返回一个定长列表。</p>
<br>

<hr>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector 是上古类，从 JDK 1.0 开始就存在了（ArrayList 在 JDK 1.2 才出现）。这个类怎么说呢，我工作至今，一次都没有用过……我感觉这个类存在的意义，就是为了招聘面试。</p>
<p>Vector 能够实现的功能，跟 ArrayList 几乎完全一样，除了它是线程安全的。Vector 线程安全的实现方式是，在所有方法外面都加上 <code>synchronized</code> 关键字，同时间只允许一个线程执行方法。</p>
<br>

<p>对比 Vector 和 ArrayList 的 add() 方法，逻辑上几乎完全相同，唯二值得单独提出来的地方，一处是 Vector 的 add() 方法加了 <code>synchronized</code> 关键字，代码对比如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList的add()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vector的add()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一处稍微值得提下的地方是，ArrayList 扩容时每次增加到 1.5 倍，而 Vector 扩容时每次增加到 2 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList扩容的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 新容量 = 原始容量 + 原始容量/2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vector扩容的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ? capacityIncrement : oldCapacity);  <span class="comment">// 新容量 = 原始容量 + 原始容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 ArrayList 扩容是到 1.5 倍，而 Vector 扩容是到 2 倍，为何设计上不相同，我试着查了一下没有查到说法。我目前只能归结为，是因为写代码的大佬不是同一个人，大佬们有自己的想法。</p>
<br>

<p>参考别的大佬给出的最佳实践，Vector 类基本是被废弃掉的，如果需要一个线程安全的 list，那么可以使用 JUC 包下的 CopyOnWriteArrayList 类，或者使用 <code>Collections.synchronizedList()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>不使用 Vector 类，是因为 Vector 类实现线程安全的方式，是在所有方法的外面加上 synchronized 关键字，这个线程同步的方式比较笨重，带来的消耗比较大，因此都建议不去使用。但是为什么 synchronized 关键字消耗大，这个我暂时不清楚，等之后积累并发基础吧。</p>
<br>

<hr>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList 是另一种数据结构的列表，它通过链表（Node）的形式构成，插入和删除快，但查找慢。</p>
<p>LinkedList 的 add() 方法，简单地令人发指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e); ---┐</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;   ↙</span><br><span class="line">&#125;                ↙</span><br><span class="line">               ↙</span><br><span class="line">             ↙ </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是尾插节点。</p>
<p>LinkedList 的构成元素是双向链表，就是一个值带着两个指针，一个指针指向前一个节点，一个指针指向后一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 增加元素时，如果需要扩容，那么需要拷贝全部数据，删除元素时也需要大量搬移数据。LinkedList 增加和删除元素是直接改动的，但是查找时会慢。</p>
<p>一个没啥好说的类，略了。</p>
<br>

<hr>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>LinkedHashMap 类是一个奇怪的 map，在存储上它使用 HashMap 的方式，但是在遍历时，它可以按照插入的顺序输出。举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, Object&gt; map2 = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map1.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">map1.put(<span class="string">"3"</span>, <span class="number">2</span>);</span><br><span class="line">map1.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">map2.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">map2.put(<span class="string">"3"</span>, <span class="number">3</span>);</span><br><span class="line">map2.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"HashMap 输出：\t\t"</span> + map1);</span><br><span class="line">System.out.println(<span class="string">"LinkedHashMap 输出：\t"</span> + map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// HashMap 输出：       &#123;1=1, 2=2, 3=2&#125;</span></span><br><span class="line"><span class="comment">// LinkedHashMap 输出： &#123;1=1, 3=3, 2=2&#125;</span></span><br></pre></td></tr></table></figure>

<p>分别实例化一个 HashMap 对象和一个 LinkedHashMap 对象，按照一样的顺序插入三组 key-value（key 的顺序是 “1”、”3”、”2”），然后分别输出这两个对象。发现 HashMap 按照内部存储的顺序输出 1 -&gt; 2 -&gt; 3，而 LinkedHashMap 按照插入的顺序输出 1 -&gt; 3 -&gt; 2。</p>
<p>尽管 LinkedHashMap 按照插入的顺序输出，但实际上 LinkedHashMap 存储时的内部结构，是跟 HashMap 一样的，也就是说它跟 HashMap 有一样快的查找速度。</p>
<p>这真是很有意思。</p>
<br>

<p>在学习 LinkedHashMap 之前，必须先回顾 HashMap，因为 LinkedHashMap 就是由 HashMap 而来的。</p>
<p>简单来讲，HashMap 有以下几个特征：</p>
<ol>
<li>HashMap 采用哈希算法计算存储位置，因此查找速度理论上非常快，为 O(1)。</li>
<li>HashMap 采用数组+链表+红黑树的拉链法存储结构，正常来讲存数组，哈希冲突时存链表，链表长度超过 8 则转红黑树。</li>
<li>当 HashMap 的实际存储个数超过一定大小时（规则：实际个数 &gt; 数组长度 × 负载因子，负载因子默认 0.75），数组扩容。</li>
<li>HashMap 内部用于存储的数组默认长度是 16，这个长度可以人为规定，但真正的长度只会是 2 的幂，不足则自动设为下一个 2 的幂（例如指定长度为 7 则实际长度为 8，指定长度为 19 则实际长度为 32），而且每次数组扩容时将扩容到上一次的两倍。这种设计跟 HashMap 的哈希计算存储位置有关。</li>
</ol>
<p>好吧，看来也不简单。</p>
<br>

<p>可以来看 LinkedHashMap 的 put() 方法了。</p>
<p>但是当看 LinkedHashMap 时，会发现它并没有 put() 方法，其实这在上次查看 HashMap 的 put() 方法时就初见端倪了。这是因为，LinkedHashMap 的确没有 put() 方法，它继承自 HashMap 类，直接使用 HashMap 的 put() 方法。</p>
<p>但是 HashMap 的 put() 方法中留下了空实现几个方法，LinkedHashMap 重写了这几个空实现的方法，此外还重写了另一个方法，使得它虽然是继承使用 HashMap 的 put() 方法，但是并不完全一样。</p>
<p>HashMap 的 put() 方法核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">                 ┌----------------------------------┐</span><br><span class="line">        tab[i] = | newNode(hash, key, value, <span class="keyword">null</span>); |  <span class="comment">// LinkedHashMap重写了此方法</span></span><br><span class="line">                 └----------------------------------┘</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                             ┌----------------------------------┐</span><br><span class="line">                    p.next = | newNode(hash, key, value, <span class="keyword">null</span>); |  <span class="comment">// LinkedHashMap重写了此方法</span></span><br><span class="line">                             └----------------------------------┘</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">           ┌---------------------┐</span><br><span class="line">           | afterNodeAccess(e); |  <span class="comment">// 预留给LinkedHashMap使用</span></span><br><span class="line">           └---------------------┘</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    ┌----------------------------┐</span><br><span class="line">    | afterNodeInsertion(evict); |  <span class="comment">// 预留给LinkedHashMap使用</span></span><br><span class="line">    └----------------------------┘</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这真是很有意思，看 HashMap 的源码时，总会发现一些特别巧妙的设计（以及艰涩难读的代码……）。</p>
<br>

<p>先说点基础做铺垫。</p>
<p>从总体上说，LinkedHashMap 内部维护了两套存储内容，一套跟 HashMap 完全相同（实际上就是在使用 HashMap），另一套是一条双向链表。每当继承自 HashMap 的那套存储内容发生变化的时候，例如新建、删除、插入等，都要同时在另一套自己维护的双向链表中去做处理。这样，既能白嫖到 HashMap 的极快的查找速度，也能享受到自己维护的双向链表的额外功能。</p>
<p>LinkedHashMap 实现两套存储内容，是通过特殊设计存储结构实现的。LinkedHashMap 沿用 HashMap 的设计，使用数组+链表来实现（暂时忽略红黑树），数组中存放的是链表节点。</p>
<p>HashMap 的链表节点的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、getter方法、setter方法等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 的链表节点的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    <span class="comment">// 构造方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，LinkedHashMap 的链表节点类（Entry），继承自 HashMap 的链表节点类（Node）。HashMap 的链表节点具有四个信息，分别是 key、value、hash 值、下一个节点的指针。而 LinkedHashMap 的链表节点类除了具有以上四个属性之外，还具有指向 before 节点和 after 节点的指针（需要注意，after 指向的内容，跟 next 指向的内容，并不是同一个东西）。因此可以认为，LinkedHashMap 的链表节点，实际上是具有三个方向的，是一个三向链表节点，它除了具有指向下一个节点的方向之外，还额外新增了两个方向：一个指向 before，一个指向 after。</p>
<p>因此，LinkedHashMap 内部维护了两套存储逻辑，一套跟 HashMap 完全相同，另一套是一条双向链表。</p>
<p>这条双向链表，有两种用处（排序方式）：</p>
<ol>
<li>按照插入顺序排序，遍历时可以按照插入的顺序输出</li>
<li>按照访问顺序排序，遍历时按照曾经访问过的先后顺序输出（LRU 算法）</li>
</ol>
<p>这两种排序方式都是有意义的，一个可以记录 LinkedHashMap 插入数据的顺序，另一个可以记录 LinkedHashMap 访问数据的顺序，可以用作缓存，按时间先后输出最近看过的数据。</p>
<br>

<p>了解了以上这些，我们回看 LinkedHashMap 的 put() 方法，也就是使用父类 HashMap 的 put() 方法时，重写的那三个方法，究竟在做些什么。</p>
<p>LinkedHashMap 一共重写了三个方法：</p>
<ol>
<li>newNode() 方法，用于创建链表节点</li>
<li>afterNodeAccess() 方法，用于处理按照访问顺序排序的情况</li>
<li>afterNodeInsertion() 方法，用于处理按照插入顺序排序的情况</li>
</ol>
<h2 id="newNode-方法"><a href="#newNode-方法" class="headerlink" title="newNode() 方法"></a>newNode() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">   ┌------------------┐</span><br><span class="line">   | linkNodeLast(p); |  →┐</span><br><span class="line">   └------------------┘   ↓</span><br><span class="line">    <span class="keyword">return</span> p;             ↙</span><br><span class="line">&#125;                       ↙</span><br><span class="line">                      ↙</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原先创建链表节点的基础上，将该节点设为双向链表的最后一个节点。</p>
<h2 id="afterNodeAccess-方法"><a href="#afterNodeAccess-方法" class="headerlink" title="afterNodeAccess() 方法"></a>afterNodeAccess() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K, V&gt; e)</span> </span>&#123;                                  ■ 传入访问节点</span><br><span class="line">    LinkedHashMap.Entry&lt;K, V&gt; last;                                   |</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;                          |</span><br><span class="line">        LinkedHashMap.Entry&lt;K, V&gt; p = (LinkedHashMap.Entry&lt;K, V&gt;) e,  |</span><br><span class="line">                                  b = p.before,                       |</span><br><span class="line">                                  a = p.after;                        |</span><br><span class="line">        p.after = <span class="keyword">null</span>;                                               ■ 访问节点之后清空</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)                                                ■ 处理访问节点原先位置的前一个节点</span><br><span class="line">            head = a;                                                 |</span><br><span class="line">        <span class="keyword">else</span>                                                          |</span><br><span class="line">            b.after = a;                                              |</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)                                                ■ 处理访问节点原先位置的后一个节点</span><br><span class="line">            a.before = b;                                             |</span><br><span class="line">        <span class="keyword">else</span>                                                          |</span><br><span class="line">            last = b;                                                 |</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)                                             ■ 将访问节点设为双向链表的最后一个节点</span><br><span class="line">            head = p;                                                 |</span><br><span class="line">        <span class="keyword">else</span> &#123;                                                        |</span><br><span class="line">            p.before = last;                                          |</span><br><span class="line">            last.after = p;                                           |</span><br><span class="line">        &#125;                                                             |</span><br><span class="line">        tail = p;                                                     |</span><br><span class="line">        ++modCount;                                                   |</span><br><span class="line">    &#125;                                                                 |</span><br><span class="line">&#125;                                                                     |</span><br></pre></td></tr></table></figure>

<p>首先解释 accessOrder 是什么：LinkedHashMap 的双向链表有两种排序方式，一种是按照插入顺序排序，一种是按照访问顺序排序。accessOrder 是一个布尔值，当它为 true 时表示按照访问顺序排序，当它为 false 时表示按照插入顺序排序。默认情况下，accessOrder 为 false，也就是说，默认情况下 LinkedHashMap 的双向链表是按照插入顺序排序的。</p>
<p>afterNodeAccess() 方法的意义是，当 accessOrder 为 true 时（按照访问顺序排序），将最新访问的节点，放到 LinkedHashMap 双向链表的最后一个的位置处。具体的实现的逻辑是，将该节点从原位置处删除掉，并设置为双向链表的最后一个节点。</p>
<h2 id="afterNodeInsertion-方法"><a href="#afterNodeInsertion-方法" class="headerlink" title="afterNodeInsertion() 方法"></a>afterNodeInsertion() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (evict                           <span class="comment">// 参数1</span></span><br><span class="line">        &amp;&amp; (first = head) != <span class="keyword">null</span>       <span class="comment">// 参数2</span></span><br><span class="line">        &amp;&amp; removeEldestEntry(first)) &#123;  <span class="comment">// 参数3</span></span><br><span class="line">        </span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 LinkedHashMap 而言，afterNodeInsertion() 默认是一个无用的方法，执行前后不会发生任何变化。但是如果你自己写一个 LinkedHashMap 的子类，重写某个方法，可以让 afterNodeInsertion() 方法生效。</p>
<p>afterNodeInsertion() 方法的作用是，每当新节点插入时，就把双向链表的最开始的节点删除掉，以保持双向链表的长度在插入前后是不变的。这个方法的意义在于，如果子类想要实现缓存，而缓存的长度是有限的，可以使用该方法来做处理，当缓存的容量满了之后，每插入一个新节点，就删除掉最早插入的旧节点，维持缓存的容量。</p>
<p> afterNodeInsertion() 方法有三个执行逻辑上的参数，只有这三个参数都为 true 时，该方法才会删除双向链表的头节点：</p>
<ul>
<li><p><code>evict</code>  由 HashMap 的 putVal() 方法定义，在插入节点时默认为true，表示可以删除头结点。如果 <code>evict</code> 为 false，表示 map 处于“creation mode”（创造模式，只创造，不删除）。</p>
</li>
<li><p><code>(first = head) != null</code>  双向链表有头结点（否则没得删）</p>
</li>
<li><p><code>removeEldestEntry(first))</code>  默认返回 false，表示不删除之前插入的节点。子类如果想实现缓存，那么需要重写该方法，官方还给了一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存最大100，超过100就返回false，准备删除头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> size() &lt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>

<p>LinkedHashMap 还有很多地方并没有看，这里只简单探究了 LinkedHashMap 插入新元素的逻辑（而且还没关注当链表长度过长转成红黑树是怎么样的）。HashMap 和 LinkedHashMap 的源码实在是有够神奇，我很是服气……</p>
<p>LinkedHashMap 先写到这里了。</p>
<br>

<p>最后安利一篇博文：<a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a>。</p>
<br>

<hr>
<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>跟 ArrayList 和 Vector 的关系几乎完全一样，HashMap 和 Hashtable 也是如此。</p>
<p>在 JDK 1.0 时，Java.util 包中还只有 Vector 和 Hashtable（当然还有别的类，这里是针对于 ArrayList 和 HashMap 而言的），它们两个都通过在方法前加 synchronized 关键字实现线程安全。在 JDK 1.2 时，Java.util 包中新增了 ArrayList 和 HashMap 这两个线程非安全的类，但是可以通过 Collection 类的静态方法将它们转换成线程安全的类，这样就减轻了性能要求。在 JDK 1.5 时，JUC 包中的 CopyOnWriteArrayList 和 ConcurrentHashMap 出现，基本宣告了 Vector 和 Hashtable 的死刑。</p>
<p>但是和 Vector 稍有不同的是，Hashtable 并不是和 HashMap 的各个方法只有 synchronized 关键字的区别，而是在设计上就有所不同。HashMap 和 Hashtable 都基于哈希算法实现，通过数组+链表的基本数据结构构成，但是在算法和数据存储上都略有区别。本次只关注 Hashtable 的 put() 方法。</p>
<p>Hashtable 的 put() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;                    |</span><br><span class="line">                                                               |</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;                                       ■ value不能为<span class="keyword">null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                      |</span><br><span class="line">    &#125;                                                          |</span><br><span class="line">                                                               |</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;                                  ■ 取Hashtable的存储数组</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();                                 ■ 取哈希值（暗中要求key也不能为<span class="keyword">null</span>）</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;              |</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)                             |</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];                 ■ 根据key的哈希值找到数组的桶</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;                |</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;   ■ key相同时替换value，并直接返回</span><br><span class="line">            V old = entry.value;                               |</span><br><span class="line">            entry.value = value;                               |</span><br><span class="line">            <span class="keyword">return</span> old;                                        |</span><br><span class="line">        &#125;                                                      |</span><br><span class="line">    &#125;                                                          |</span><br><span class="line">   ┌------------------------------------┐                      |</span><br><span class="line">   | addEntry(hash, key, value, index); |                      ■ 添加key-value，详见下</span><br><span class="line">   └------------------------------------┘                      |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;       ↙                                       |</span><br><span class="line">&#125;                    ↙                                         |</span><br><span class="line">                   ↙                                           .</span><br><span class="line">                 ↙                                             .</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;   |</span><br><span class="line">    modCount++;                                                |</span><br><span class="line">                                                               |</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;                                  |</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;                                  ■ 如果容量饱和（默认 size &gt;= 数组大小 × <span class="number">0.75</span>）</span><br><span class="line">       ┌-----------┐                                           |</span><br><span class="line">       | rehash(); |                                           ■ 扩大数组容量，并重新装填key-value，详见下</span><br><span class="line">       └-----------┘                                           |</span><br><span class="line">        tab = table;                                           |</span><br><span class="line">        hash = key.hashCode();                                 |</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;              ■ 计算需要插入key-value在新数组中的位置</span><br><span class="line">    &#125;                                                          |</span><br><span class="line">                                                               |</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)                             |</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];                    ■ 在数组中存储key-value，链表头插法</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);             |</span><br><span class="line">    count++;                                                   ■ 此时才增加容量计数，如果容量饱和，下一次再扩容</span><br><span class="line">&#125;                     ↙                                        |</span><br><span class="line">                    ↙                                          .</span><br><span class="line">                  ↙                                            .</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;                                                     |</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;                                           |</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;                                              |</span><br><span class="line">                                                                              |</span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;                                 ■ 数组扩容，扩容算法是<span class="number">2</span>n+<span class="number">1</span>，例如<span class="number">11</span>扩容到<span class="number">23</span></span><br><span class="line">                                                                              | 这样扩容使数组长度尽可能是质数，哈希算法更平均</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;                                   |</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)                                    ■ 数组最大长度是<span class="keyword">int</span>最大值-<span class="number">8</span>，照顾不同的VM情况</span><br><span class="line">            <span class="keyword">return</span>;                                                           |</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;                                         |</span><br><span class="line">    &#125;                                                                         |</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];                        |</span><br><span class="line">                                                                              |</span><br><span class="line">    modCount++;                                                               |</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);  ■ 重算容量饱和值</span><br><span class="line">    table = newMap;                                                           |</span><br><span class="line">                                                                              |</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;                                   ■ 重新装填所有的key-value</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;       |</span><br><span class="line">            Entry&lt;K,V&gt; e = old;                                               |</span><br><span class="line">            old = old.next;                                                   |</span><br><span class="line">                                                                              |</span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;                  ■ 每一个key-value都要重算哈希位置</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];                               |</span><br><span class="line">            newMap[index] = e;                                                |</span><br><span class="line">        &#125;                                                                     |</span><br><span class="line">    &#125;                                                                         |</span><br><span class="line">&#125;                                                                             |</span><br></pre></td></tr></table></figure>

<p>Hashtable 的 put() 方法，总体逻辑上是这样的：</p>
<ul>
<li>内部存储通过<code>数组+链表</code>的数据结构，没有红黑树，数组默认大小11。</li>
<li>每当增加新的 key-value 时，根据哈希值对数组长度取余，计算在数组中的位置，如果 key 存在则替换 value，如果 key 不存在，则在数组的相应位置处采用链表头插法插入。</li>
<li>当容量饱和（默认算法是<code>容量 &gt;= 数组长度 × 0.75</code>）时，扩容数组。数组扩容算法是<code>新数组长度 = 旧数组长度 × 2 + 1</code>，例如初始化数组大小是 11，第一次扩容之后变成了 23。每次扩容时，要将旧数组中的数据迁移到新数组中，每一个数据都要重算哈希位置。</li>
</ul>
<br>

<p>JDK 1.0 的 Hashtable 和 JDK 1.2 HashMap 的实现是不相同的，下面简单列一下不相同的点：</p>
<ul>
<li>HashMap 通过<code>数组+链表+红黑树</code>做底层存储（在 JDK 1.8 之后），而 Hashtable 通过<code>数组+链表</code>做底层存储。</li>
<li>HashMap 的数组大小默认是 16，如果手动指定数组大小或者数组扩容（扩容算法是扩大到两倍），数组大小也只能是 2 的幂（1、2、4、8、16、32……），而 Hashtable 的数组默认大小是 11，扩容算法是 <code>2n + 1</code>，尽可能使数组大小是质数。这个差异跟两种 map 添加 key-value 数据时的算法有关。</li>
<li>HashMap 的 key 和 value 都可以是 null，而 Hashtable 则都不可以，否则会抛出空指针异常。这要分别解释 key 和 value。<ul>
<li>我目前查到的说法，Hashtable 不支持 key 为 null，是因为这个类出现得太早，觉得一切 key 都要有 hashCode，而之后的 HashMap 考虑到了 null 的重要，为它单独做了处理，把所以 key 为 null 的数据存储在数组的第 0 个格子中。</li>
<li>Hashtable 不支持 value 为 null，是线程安全的考虑。如果 value 可以为 null，那么当 Hashtable 执行 put() 方法并且返回值是 null 时，你并不知道，究竟是因为原来没有这个 key，还是因为原来有 key 但它的 value 是null。HashMap 也是如此，但是它可以通过执行 containsKey() 的方法来判断 key 是否存在，这在单线程下是没有问题的，但是在并发状态下，containsKey() 得到的结果是并不可靠的，可能下一秒 key 就被删除掉了。因此多线程环境下，value 必须不能是 null，Hashtable 是这么设计的，ConcurrentHashMap 也是这么设计的。</li>
</ul>
</li>
<li>HashMap 和 Hashtable 在插入元素，哈希计算它在数组中的位置的算法，是不一样的。<ul>
<li>HashMap 的哈希算法一环扣一环，它希望加快计算位置的速度（这是一方面的原因），因此不使用 % 取余算法，而通过更快的按位与运算来计算位置（(n - 1) &amp; hash），这就要求了数组的长度只能是 2 的幂，以保证按位与计算出来的结果和取余计算出来的结果是相同的。而数组长度是 2 的幂，哈希计算出来的数值很容易相同（哈希冲突），那么只能让哈希值更平均一些，因此 HashMap 将哈希值的高位和低位按位与，以降低哈希冲突。</li>
<li>Hashtable 的哈希算法比较简单直接一些，直接将哈希值对数组长度取余。这种算法中数组长度很重要，如果是质数的话，取余结果能够更平均一些，因此 Hashtable 的数组长度默认是 11，而且扩容算法是 <code>2n+1</code>，扩容之后一般也是质数（但是可以手动指定成随便一个数）。尽管 HashMap 对哈希值做了处理，但我查到的资料是，也不如 Hashtable 取余结果平均，但是 Hashtable 会慢。</li>
<li>扩容时，HashMap 和 Hashtable 的实现也是不一样的，HashMap 由于数组是 2 的幂数，所以扩容更简单（具体的我没看），但是 Hashtable 只能一个个重算位置。</li>
</ul>
</li>
<li>HashMap 在 JDK 1.8 之前，在链表中插入元素都是头插法，而在 JDK 1.8 后是尾插法。Hashtable 一直是头插法。HashMap 在 JDK 1.8 之后转用尾插法的原因，是为了防止并发时链表死循环，我对此还不是很理解，一方面 HashMap 又不是线程安全的类，另一方面如果这个问题真的存在，那么前面 7 个 JDK 版本为什么不改……我还是要再积累一点经验再回来看这个问题。</li>
</ul>
<p>我从总体上理解，认为 HashMap 将优化的重心放在数据的维护上，插入慢一点，扩容快，对外兼容好，而 Hashtable 将优化的重心放在数据的插入上，存储时更平均，扩容代价很大。只是感觉而已。</p>
<p>另外我发现，原来 Hashtable 的 table 并不是首字母大写的，原来 hash 和 table 是组合成一个单词的呀。</p>
<br>

<hr>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>ConcurrentHashMap 是 HashMap 的线程安全类，在 JUC 包下，是宣告了 Hashtable 类死刑的类。</p>
<p>说实话，没看懂这个类的实现……我就先放一下 put() 方法的主要逻辑，以后再回来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;                                             |</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                            ■ key和value均不允许<span class="keyword">null</span>，防止并发<span class="keyword">null</span>歧义</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());                                                             ■ hashCode的高位和低位与运算</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;                                                                              ■ binCount:插入位置处的链表节点数</span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt;[] tab = table; ; ) &#123;                                         |</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt; f;                                                            ■ f:插入位置的已有链表节点</span><br><span class="line">        <span class="keyword">int</span> n,                                                                                     ■ n:数组大小</span><br><span class="line">            i,                                                                                     ■ i:坐标，哈希计算出来</span><br><span class="line">            fh;                                                                                    ■ fh:插入位置的已有链表节点的哈希值</span><br><span class="line">                                                                                                   |</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)                                                  ■ 初始化数组（若未存储过）</span><br><span class="line">            tab = initTable();                                                                     |</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;                                   ■ CAS获取数组位置，空则直接添加</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>)))  |</span><br><span class="line">                <span class="keyword">break</span>;                                                                             |</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)                                                         ■ 其他线程正在进行扩容，则帮助一起扩容</span><br><span class="line">            tab = helpTransfer(tab, f);                                                            |</span><br><span class="line">        <span class="keyword">else</span> &#123;                                                                                     ■ 已有其他节点存在该位置上（哈希冲突）</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;                                                                       |</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;                                                                     |</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;                                                          ■ 再次判断取到的节点是否是头节点（考虑并发）</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                                                                 ■ 链表中加新节点</span><br><span class="line">                        binCount = <span class="number">1</span>;                                                              |</span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; e = f; ; ++binCount) &#123;                   |</span><br><span class="line">                            K ek;                                                                  |</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;                                                  |</span><br><span class="line">                                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;     |</span><br><span class="line">                                oldVal = e.val;                                                    |</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)                                                 |</span><br><span class="line">                                    e.val = value;                                                 |</span><br><span class="line">                                <span class="keyword">break</span>;                                                             |</span><br><span class="line">                            &#125;                                                                      |</span><br><span class="line">                            ConcurrentHashMap.Node&lt;K, V&gt; pred = e;                                 |</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;                                            |</span><br><span class="line">                                pred.next = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(hash, key,            |</span><br><span class="line">                                        value, <span class="keyword">null</span>);                                              |</span><br><span class="line">                                <span class="keyword">break</span>;                                                             |</span><br><span class="line">                            &#125;                                                                      |</span><br><span class="line">                        &#125;                                                                          |</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;                           ■ 红黑树中加新节点</span><br><span class="line">                        ConcurrentHashMap.Node&lt;K, V&gt; p;                                            |</span><br><span class="line">                        binCount = <span class="number">2</span>;                                                              |</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((ConcurrentHashMap.TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key,       |</span><br><span class="line">                                value)) != <span class="keyword">null</span>) &#123;                                                 |</span><br><span class="line">                            oldVal = p.val;                                                        |</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)                                                     |</span><br><span class="line">                                p.val = value;                                                     |</span><br><span class="line">                        &#125;                                                                          |</span><br><span class="line">                    &#125;                                                                              |</span><br><span class="line">                &#125;                                                                                  |</span><br><span class="line">            &#125;                                                                                      |</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;                                                                   |</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                                                 ■ 链表转红黑树</span><br><span class="line">                    treeifyBin(tab, i);                                                            |</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)                                                                |</span><br><span class="line">                    <span class="keyword">return</span> oldVal;                                                                 |</span><br><span class="line">                <span class="keyword">break</span>;                                                                             |</span><br><span class="line">            &#125;                                                                                      |</span><br><span class="line">        &#125;                                                                                          |</span><br><span class="line">    &#125;                                                                                              |</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);                                                                        ■ CAS统计数量+<span class="number">1</span>，同时考虑扩容</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;                                                                                   |</span><br><span class="line">&#125;                                                                                                  |</span><br></pre></td></tr></table></figure>

<p>就这样吧……</p>
<br>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>一共查看了三种 list：</p>
<ol>
<li><p>ArrayList 类基于动态数组实现，默认初始容量是 10，容量不够则扩充到 1.5 倍，非线程安全。</p>
<p>这是最常用的类，使用时尽量指定容量大小。</p>
</li>
<li><p>Vector 类是个上古残废类，跟 ArrayList 类几乎一模一样，除了能保证线程安全，笨重。</p>
</li>
<li><p>LinkedList 类基于双向链表实现，增删快，查找慢。</p>
</li>
</ol>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>重点看了两种新的 map，并且对 HashMap 有了更深的理解：</p>
<ol>
<li>LinkedHashMap 重定义了链表节点类，因此在 HashMap 的功能之外，多实现了一条双向链表，可以按照插入/访问顺序存储节点。</li>
<li>HashTable 是上古版本的、在各个方法上加了 synchronized 关键字的 HashMap，能够实现多线程安全。这个类已经是个不被推荐的类了，也就没再修改过。通过这个类，能看看 HashMap 年轻时长什么样。</li>
<li>ConcurrentHashMap 是 JUC 包下的线程安全的 HashMap，没看懂……</li>
</ol>
<br>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
