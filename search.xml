<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2020/04/15/ConcurrentHashMap/</url>
    <content><![CDATA[<br>

<p>本篇着重学习 JDK 8 的ConcurrentHashMap，对于 JKD 7 的设计也顺便学习一下。</p>
<p>学习来源基本上源自博文<a href="https://www.javadoop.com/post/hashmap" target="_blank" rel="noopener">《Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析》</a>，这篇文章已经写得非常不错了，就是无奈道格李的代码太难读了，因此还是要很认真地学习才能看懂。</p>
<hr>
<p>首先简单提一下 JDK 7 时的 ConcurrentHashMap 的设计（下图来自前面提到的博文）。</p>
<p><img src="/assets/3.png" alt="JDK7的表设计"></p>
<p>JDK 7 时 ConcurrentHashMap 采用分段锁的设计，维护一个 Segment 数组，每个 Segment 都是一个锁（继承自 ReentrantLock），该 Segment 内部有一个可扩容数组（同 HashMap 的设计）用于真正存储元素。相比于 Hashtable 对整个方法加 synchronized 锁，ConcurrentHashMap 对 Segment 上锁，相当于降低了锁的颗粒度，提高了性能。</p>
<p>不看源码了，只写一点实现细节吧：</p>
<ol>
<li><p>Segment 数组初始化后不可扩容，默认是 16 个 Segment，可通过构造方法改变初值（初值会自动上抬为 2 的幂数，构造方法与 HashMap 有不同）。</p>
</li>
<li><p>存储元素时分段存储，算法是取 hash 的高位（如果 Segment 数组长度是 16，那么就取 hash 的高 4 位），然后算出存储在哪个 Segment。比如 hash 高 4 位是 1010，那么存储在 Segment[10]，如果 hash 高 4 位是 0011，那么存储在 Segment[3]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当有16个Segment时，hash无符号右移28位（剩下高4位），然后与操作15，得出存储的Segment的位置</span></span><br><span class="line"><span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br></pre></td></tr></table></figure>

<p>（看到这里你应该明白，为什么 Segment 的个数也需要是 2 的幂数了）</p>
</li>
<li><p>Segment 内部由数组+链表组成（跟 HashMap 的原理相同，拉链法），链表采用尾插法。存 entry 前先获取 Segment 的锁，在保证持有锁的前提下存储 entry。</p>
</li>
<li><p>构造方法初始化时，会创建 Segment 数组，并只会创建出第 0 个 Segment：Segment[0]，Segment[0] 内部的数组长度初值为 2，根据负载因子扩容（默认 0.75），这样插入第一个元素不扩容，插入第二个元素才扩容。其他 Segment[i] 会在存储 entry 时再创建，数组长度和负载因子同当时的 Segment[0]（有可能 Segment[0] 扩容过，那么就使用扩容之后 Segment[0] 的长度）。</p>
</li>
<li><p>ConcurrentHashMap 的 get() 方法没有做任何并发处理，主要是依赖于 volatile 关键字配合 UNSAFE 包实现读取时的数据一致（具体原理略）。</p>
</li>
</ol>
<hr>
<p>JDK 8 的 ConcurrentHashMap 放弃了 Segment 分段锁的设计，转而使用跟 HashMap 相同的数据结构，但是实现上考虑并发。</p>
<p><img src="/assets/4.png" alt="JDK8的表设计"></p>
<p>推测一下放弃分段锁的原因：</p>
<p>原先采取 Segment 分段，默认情况下最多分 16 段，而 Segment 是通过继承 ReentrantLock 实现的，这就意味着可能同一时间需要维护 16 个 AQS 队列，对内存的消耗还是比较大的。</p>
<p>如果联想下 HashMap，同一时间不太会有多个线程对同一个数组格子进行编辑，那么可以使用 synchronized 修饰每一个格子，锁的优化让 JVM 去处理。</p>
<br>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;                   |</span><br><span class="line">                                                                         |</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();  ■ key和value均不能为<span class="keyword">null</span>（HashMap可以）</span><br><span class="line">                                                                         |</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());                                   ■ hash:key的哈希值（经过高低位与运算）</span><br><span class="line">                                                                         |</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;                                                    ■ binCount:链表长度</span><br><span class="line">                                                                         |</span><br><span class="line">                                                                         ├---------------------------------</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K, V&gt;[] tab = table; ; ) &#123;                                 |                        （无限循环）</span><br><span class="line">                                                                         |</span><br><span class="line">        Node&lt;K, V&gt; f; <span class="keyword">int</span> n, i, fh;                                      ■ f:新entry  n:数组长度</span><br><span class="line">                                                                         |  i:数组下标  fh:数组下标头节点的哈希值</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;...&#125;                  ■ （若首次）初始化数组</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;...&#125;     ■ 找到数组下标，如果空链表则CAS加</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;...&#125;                           ■ 多线程帮助数组扩容</span><br><span class="line">                                                                         |</span><br><span class="line">        <span class="keyword">else</span> &#123;                                                           ■ （已经找到数组下标）链表非空</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;                                             |  通过<span class="keyword">synchronized</span>阻塞加</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;...&#125;                                       |</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;...&#125;                                     ■ 如果链表长度过长，则转红黑树</span><br><span class="line">        &#125;                                                                |</span><br><span class="line">    &#125;                                                                    |</span><br><span class="line">                                                                         ├---------------------------------</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);                                              |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;                                                         |</span><br><span class="line">&#125;                                                                        |</span><br></pre></td></tr></table></figure>

<p>源码点到为止（真不喜欢看道格李的代码= =），一些实现细节列在下面：</p>
<ol>
<li><p>ConcurrentHashMap 的 key 和 value 都不支持 null 值，这点跟 HashTable 一致，但是 HashMap 是支持的（key 和 value 都支持）。</p>
<p>关于这点我曾在分析 HashTable 的源码时提过，明面上的原因是：如果 value 允许 null，那么当 <code>map.get(...) == null</code> 时，不能知道返回的 null 是代表 value 为 null，还是说根本没有 key，对于 HashMap 单线程可以使用 containsKey() 方法判断，但是多线程并发的 ConcurrentHashMap 和 HashTable 是判断不出来的。还有一层原因是，道格李不希望在 Map 和 Set 容器中支持 null，他认为这是定时炸弹。</p>
<p>有关这个问题可以参考该网站：<a href="http://cs.oswego.edu/pipermail/concurrency-interest/2006-May/002485.html" target="_blank" rel="noopener">道格李对 ConcurrentHashMap 不支持 null 的解释</a></p>
</li>
<li><p>在 JDK8 的代码实现中，ConcurrentHashMap 和 HashMap 是比较像的，放弃了原先分段锁的设计，转而对每一个数组格子加 synchronized 锁。我发现道格李写代码很喜欢写循环，循环进入的每一轮，状态是不同的，进而进到不同的分支中。我们具体看一下 HashMap 和 ConcurrentHashMap 的实现：</p>
<ul>
<li>HashMap 加 entry 时，顺序执行一堆 if-else 的判断，先判断数组是否已被创建，然后判断是否发生哈希碰撞，如果哈希碰撞再判断是否是红黑树节点……</li>
<li>ConcurrentHashMap 加 entry 时，在一个无限循环当中，首次进来创建数组，再次进来判断是否是空链表，如果是空链表就直接 CAS 加入，如果加入失败了没关系，退出去，循环再进来的时候，进入到不是空链表的分支里，用 synchronized 阻塞尾插链表……</li>
</ul>
<p>在实现 AQS 队列的时候，我就觉得道格李用循环用得是炉火纯青了……一方面体现在每次进入循环，执行的代码都不一样，另一方面体现在循环内部的各个 if 条件是有关联的（往回看代码就能看出来，第二个 if 条件获得了数组下标，结果用到了第四个 if 条件中）。</p>
</li>
<li><p>ConcurrentHashMap 同样采用<code>数组+链表+红黑树</code>的设计，但是红黑树稍有区别，HashMap 的转红黑树条件是链表长度超过 8，ConcurrentHashMap 的转红黑树条件，在链表长度超过 8 的基础上，还需要数组长度超过 64。我猜测这跟 synchronized 锁有关，如果数组长度太小了，加锁会比较容易阻塞。</p>
</li>
<li><p>ConcurrentHashMap 数组扩容跟 HashMap 一样，都是两倍，具体实现很复杂，支持多线程一起帮助扩容。在 putVal() 方法中就有判断 hash 值是否是 -1，如果是 -1 就代表着去帮助扩容数组。</p>
</li>
<li><p>JDK7 和 JDK8 的 ConcurrentHashMap 的 get() 方法都没有做并发处理，逻辑比较简单，主要依靠 volatile 关键字和 UNSAFE 包来确保并发安全。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Iterator 迭代器</title>
    <url>/2019/12/01/Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<br>

<p>十二月了，今年要结束了。</p>
<p>这周学习 Java 的迭代器原理，迭代器是各编程语言都会有的设计，这里只关注 Java 的实现。</p>
<hr>
<p>迭代的意思是重复地同一样事，比如写一个 for 循环，每层循环内部执行一些逻辑，就是在迭代。</p>
<p>迭代器，用字面上的意思去理解，就是专注做迭代这件事的工具，即这个工具持续地、专注地做一件重复的事情。</p>
<p>实际上，编程中的迭代器，做的那件重复的事情是有所特指的，专指访问容器中的元素。例如一个列表（list）中有十个元素，使用迭代器可以重复性地逐个访问这十个元素，就跟写一个 for 循环一样。</p>
<p>容器分很多种，array 是容器、list 是容器、set 是容器、map 是容器，如果你的目的是遍历某一种容器，你应该写不一样的 for 循环（而且有些容器你无法通过 for 循环来遍历），但是如果你使用迭代器，你可以用同一种逻辑来遍历任何一种容器。迭代器的好处在于，你可以无视容器的类型，用同样的逻辑来处理它们。</p>
<p>所以我觉得吧，迭代器也可以简单粗暴地称为遍历器。</p>
<p>再体会一下维基百科对于迭代器的解释：</p>
<blockquote>
<p>迭代器（iterator）是可在容器物件（container，例如链表或阵列）上遍访的介面，设计人员无需关心容器物件的内存分配的实现细节。 </p>
</blockquote>
<hr>
<p>Java 的迭代器是 Iterator 类，是一个从 JDK 1.2 起就存在的元老设计。</p>
<p>Iterator 类是一个接口，规范了迭代器的基本规则。它在 1.2 版本时只有三个方法，在 1.5 版本时开始支持泛型，在 1.8 版本时引入函数式编程。不过在学习时，只关注 1.2 版本的最初那三个方法即可。</p>
<p>以下是 Iterator 类的三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>boolean hasNext()：是否有下一个元素（即是不是还没有遍历完容器）</li>
<li>Object next()：取出来下一个元素并返回，可以使用泛型来指定类，当执行完该方法，迭代器将自动挪到下一个元素</li>
<li>void remove()：删除上一个元素（即删除刚刚越过的那个元素）</li>
</ul>
<br>

<p>由于这三个方法非常简单，含义也很清晰，在此只给出一段代码，表个意思。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"list初始值为："</span> + list);</span><br><span class="line"><span class="comment">// list初始值为：[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">Integer next1 = iterator.next();</span><br><span class="line">System.out.println(<span class="string">"第一次执行next()方法："</span> + next1);</span><br><span class="line"><span class="comment">// 第一次执行next()方法：1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer next2 = iterator.next();</span><br><span class="line">System.out.println(<span class="string">"第二次执行next()方法："</span> + next2);</span><br><span class="line"><span class="comment">// 第二次执行next()方法：2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iterator.remove();</span><br><span class="line">System.out.println(<span class="string">"执行完remove()方法后，此时的列表值为："</span> + list);</span><br><span class="line"><span class="comment">// 执行完remove()方法后，此时的列表值为：[1, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasNext1 = iterator.hasNext();</span><br><span class="line">System.out.println(<span class="string">"此时是否有下一个元素："</span> + hasNext1);</span><br><span class="line"><span class="comment">// 此时是否有下一个元素：true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer next3 = iterator.next();</span><br><span class="line"><span class="keyword">boolean</span> hasNext2 = iterator.hasNext();</span><br><span class="line">System.out.println(<span class="string">"此时是否有下一个元素："</span> + hasNext2);</span><br><span class="line"><span class="comment">// 此时是否有下一个元素：false</span></span><br></pre></td></tr></table></figure>

<hr>
<p>这周又是懒得不行，暂且写到这里。下周开始看各容器的迭代器实现源码，进入源码的世界。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeMarker</title>
    <url>/2019/12/29/FreeMarker/</url>
    <content><![CDATA[<br>

<p>十二月的第六周，来学习 FreeMarker。</p>
<p>在我敲出上句话时，我甚至都不知道 FreeMarker 是什么……工作需要，硬头皮写。</p>
<hr>
<p>FreeMarker 是一种模板引擎，通过 Java 语言使用。<a href="http://freemarker.foofun.cn/" target="_blank" rel="noopener">官方</a>是这么解释“模板引擎”的：</p>
<blockquote>
<p> （模板引擎是）一种基于模板和要改变的数据，用来生成输出文本的通用工具。</p>
</blockquote>
<p>又是一个不说人话的解释。</p>
<p>我理解的模板引擎，就是让程序自动使用模板生成结果的工具，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：$&#123;name&#125;</span><br><span class="line">                                            ↓</span><br><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：张三</span><br><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：李四</span><br><span class="line">请假条：昨日偶感风寒，身体抱疾，兹请假一天。请假人：王二麻子</span><br></pre></td></tr></table></figure>

<p>FreeMarker 能够读取模板中的占位符 <code>${...}</code>，并根据外部输入的值，自动替换掉占位符，生成最终的结果。</p>
<p>如此一个替换文本的工具，广泛使用在 web 前端、配置文件、源代码中。它是一种老派的 old school 工具，现在前端都没什么人用了。</p>
<hr>
<p>一会再学习 FreeMarker 的语法，暂且认为 FreeMarker 就是在替换字符串，把 <code>${...}</code> 换成具体的值。</p>
<p>最为基础的使用 FreeMarker 的方式，就是 IO 输入模板文件，然后 FreeMarker 咣咣工作，最终 IO 输出生成文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于处理IO异常太过繁琐，模糊了主干内容，这里忽略处理异常的部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IO输入模板文件</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(Configuration.DEFAULT_INCOMPATIBLE_IMPROVEMENTS);</span><br><span class="line">configuration.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(<span class="string">"C:\\Users\\thinkpad\\Desktop"</span>));</span><br><span class="line">Template template = configuration.getTemplate(<span class="string">"template.ftl"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置替换值</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">map.put(<span class="string">"age"</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO输出结果文件</span></span><br><span class="line">File out = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\thinkpad\\Desktop\\"</span> + <span class="string">"result.txt"</span>);</span><br><span class="line">Writer outWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(out)));</span><br><span class="line">template.process(map, outWriter);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>输入（template.ftl）</th>
<th>输出（result.txt）</th>
</tr>
</thead>
<tbody><tr>
<td>人员信息<br>姓名：${name}<br>年龄：${age}</td>
<td>人员信息<br>姓名：张三<br>年龄：18</td>
</tr>
</tbody></table>
<br>

<p>上面的代码是在做这样一件事：</p>
<ol>
<li>实例化一个 FreeMarker 对象出来（configuration）</li>
<li>配置 FreeMarker 的参数，其中包括输入地址（模板）、输出地址（结果）、FreeMarker 的版本。</li>
<li>给定想替换成的值，让 FreeMarker 去工作（替换）。</li>
</ol>
<br>

<p>顺便提一嘴，模板文件 <code>template.ftl</code> 的后缀名是 <code>ftl</code>，全称是 FreeMarker Template Language，是 FreeMarker 的标准模板文件格式。</p>
<p>上面这种方式，是显式地配置 FreeMarker，手动给定输出输出的文件地址，设定好 FreeMarker 的版本号，然后去使用。除了这种方式之外，还可以以配置文件的方式，在外部去设定好 FreeMarker 的各项参数，然后直接使用。比如在 Spring 框架下，都是外部设定好 FreeMarker 的参数，然后注入到要使用的地方。</p>
<p>但是我看了看，有点复杂……算了，看看语法就行了，佛了。</p>
<hr>
<p>来看 FreeMarker 的语法。</p>
<p>首先推荐<a href="http://freemarker.foofun.cn/dgui_template_overallstructure.html" target="_blank" rel="noopener">官方文档</a>，尽管官方的介绍有一些翻译腔，但是在语法介绍部分，是极尽所能地把用户当小白来教学。</p>
<p><img src="/assets/FreeMarker%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3.png" alt="FreeMarker官方文档"></p>
<p>（你看看这个恳切程度！）</p>
<p>粗略地学习之后发现，FreeMarker 不仅仅是一个替换字符串的工具，而像是一个完整的语言体系，除了基本的替换，还有许多内置函数和逻辑控制，实际上要学习的内容是非常多的。</p>
<p>本周又是摸鱼的一周，仅将常用的替换语法写在下面。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置准备替换的值</span></span><br><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">map.put(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">Map person = <span class="keyword">new</span> HashMap();</span><br><span class="line">person.put(<span class="string">"age"</span>, <span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">"person"</span>, person);</span><br><span class="line">List hobby = Arrays.asList(<span class="string">"唱"</span>, <span class="string">"跳"</span>, <span class="string">"RAP"</span>, <span class="string">"篮球"</span>);</span><br><span class="line">map.put(<span class="string">"hobby"</span>, hobby);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>模板文件</th>
<th>输出文件</th>
</tr>
</thead>
<tbody><tr>
<td>人员信息<br><br>姓名：${name}<br><br>年龄：${person.age}<br><br>&lt;#if (person.age &gt;= 18)&gt;<br>成年<br>&lt;#else&gt;<br>未成年<br>&lt;/#if&gt;<br><br>爱好：&lt;#list hobby as h&gt;${h} &lt;/#list&gt;<br><br>当前时间：${.now?string[“yyyy-MM-dd HH:mm:ss”]}</td>
<td>人员信息<br><br>姓名：张三<br><br>年龄：17<br><br>未成年<br><br>爱好：唱 跳 RAP 篮球 <br><br>当前时间：2019-12-29 09:40:58</td>
</tr>
</tbody></table>
<br>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins</title>
    <url>/2020/01/05/Jenkins/</url>
    <content><![CDATA[<br>

<p>2020 年的第一周，来学习 Jenkins。</p>
<hr>
<p>Jenkins 是一个人名，音译为詹金斯，读起来是一个很英国绅士的声音。</p>
<p>以 Jenkins 命名的这个工具/软件，是一个给编程开发人员当管家的存在，它的作用是自动化各种任务，包括构建、测试和部署软件，总之是给编程人员打下手。以一个英国绅士的名字命名，听起来就像是一个老管家，真的是很贴切。</p>
<p>Jenkins 不光名字起得贴切，连 logo 都设计为一个管家，见图明义。很草的是，Jenkins 可以使用插件扩展功能，插件官网的配图，是管家穿着高达。</p>
<p><img src="/assets/JenkinsLogo.jpg" alt="Jenkins logo"></p>
<p>说回 Jenkins 的作用。如果用术语来解释 Jenkins，它是一款开源 CI&amp;CD 软件。</p>
<p>CI&amp;CD 是编程运维中的概念，CI(Continuous Integration) 指持续集成，CD(Continuous Delivery) 指持续交付。我在阅读相关博文时，发现有两个 CD（Continuous Deployment 持续部署、Continuous Delivery 持续交付），但是一般提到时是指持续交付。</p>
<p>CI&amp;CD 的意义在于解放人力，让集成、打包、部署等流水线式的固定工作，不再需要程序员/运维人员手动去做，而交由工具去做。这在项目快速迭代功能时尤其有必要，以前我每写好一个小功能点，都要手动用 Maven 清掉编译文件，重新打包，提交给发布人员，再由发布人员去更新，整套流程耗时耗心，还有可能犯人类的低级错误。有了 CI&amp;CD 的工具之后，开发人员只需要提代码到 SVN 或者 Git 上就可以了，剩下的部署交由工具完成。</p>
<p>更多有关 CI&amp;CD 的概念可以参看博文<a href="https://linux.cn/article-9926-1.html?pr" target="_blank" rel="noopener">《什么是 CI/CD？》</a>。</p>
<hr>
<p>这周写 Jenkins 是一个非常错误的决定，因为我完全不知道写点什么……Jenkins 使用起来，就跟使用迅雷、QQ 音乐、360 杀毒软件似的，都是软件级别的交互，写起来跟写百度经验似的。而且我本地没有配置自己的 SVN 或 Git，使用 Jenkins 时都没有切身的实操体验。</p>
<p>我暂且想写什么点，就写什么点了，尽可能地学习到东西。</p>
<br>

<p>嗯……果然看了一通，什么都写不了，要不然是接触不到，要不然是水平不足。基本上，Jenkins 的自定义配置都是靠 Shell 脚本语言来实现的，我 Linux 的使用水平实在是捉襟见肘，啧，佛掉了新年第一个周。</p>
<p>下周补基础，看 Java 的容器设计。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB 索引</title>
    <url>/2021/02/04/MySQL-InnoDB-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<br>

<p>二月的第一周，来学习 InnoDB 的索引设计。</p>
<p>本周的学习来源还是《<a href="https://juejin.cn/book/6844733769996304392" target="_blank" rel="noopener">MySQL 是怎样运行的：从根儿上理解 MySQL</a>》，瑞思拜。</p>
<hr>
<p>InnoDB 为每个索引创建一个 B+ 树，每个节点都是一个索引页，其中包含若干 Compact 数据行。</p>
<p><img src="/assets/InnoDB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="InnoDB-B+树"></p>
<p>有两种索引，一种是主键（聚簇索引），一种是其他索引（二级索引）。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>比如一张表有 10000 行记录，用于区分每一行记录的唯一标记，就被叫做聚簇索引。</p>
<ul>
<li>如果这张表有主键，就用主键做聚簇索引</li>
<li>如果这张表没有主键，选一个 Unique 键做聚簇索引</li>
<li>如果连 Unique 键都没有，InnoDB 生成一个隐藏键，做聚簇索引</li>
</ul>
<p>每张表都必有聚簇索引，而且只有一份，通过它可以找到这张表的任意一条记录。</p>
<h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>除了聚簇索引之外，其他索引都是二级索引。</p>
<p>每个二级索引，可以包含一个或多个键（多个键也就是联合索引）。</p>
<h1 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h1><p>索引的作用是快速查找数据，如果没有索引，在数据库中查询一条记录，只能遍历全表（时间复杂度 O(N)），有了索引之后，数据库的存储结构变成一个 B+ 树，查询时类似于二分查找（时间复杂度 O(lgN)），查询速度大大提高。</p>
<p>InnoDB 使用 B+ 树作为索引的数据结构，这棵 B+ 树的作用就是快速查询，因此为了不浪费多余的空间，B+ 树除了叶子节点之外的节点，都不需要存储具体的数据信息，只需要存储“如何找到子节点”的信息（也就是页号）。换句话说，一个数据库可能有多个索引，有多少索引就有多少棵 B+ 树，但是所有的 B+ 树都不需要存储具体数据信息，即使需要，存一份也就够了，不要浪费空间。</p>
<p>具体存储信息如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>非叶子节点</th>
<th>叶子节点</th>
</tr>
</thead>
<tbody><tr>
<td>聚簇索引</td>
<td>主键 + 子节点指针</td>
<td>全部信息</td>
</tr>
<tr>
<td>二级索引（单字段）</td>
<td>索引字段 + 子节点指针</td>
<td>索引字段 + 主键 + 子节点指针</td>
</tr>
<tr>
<td>二级索引（联合索引）</td>
<td>索引字段1 + 索引字段2 + … + 子节点指针</td>
<td>索引字段1 + 索引字段2 + … + 主键 + 子节点指针</td>
</tr>
</tbody></table>
<h1 id="索引查询逻辑"><a href="#索引查询逻辑" class="headerlink" title="索引查询逻辑"></a>索引查询逻辑</h1><p>聚簇索引和二级索引，查询的主逻辑都是相同的，都是从 B+ 树的根节点，一层层查下去，一直查到叶子节点，整体查询效率是 O(lgN)。</p>
<p>以掘金小册中的配图为例（这只是示意图），查询索引值为 6 的记录，从第一层的页 44，查到第二层的页 42，再查到第三层的页 36，发现该记录在页 36 的第二条。</p>
<p><img src="/assets/%E6%8E%98%E9%87%91%E5%B0%8F%E5%86%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="InnoDB小册B+树"></p>
<p>聚簇索引和二级索引的查询稍有不同，体现在最终如何找到完整的数据。</p>
<h2 id="聚簇索引-1"><a href="#聚簇索引-1" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>下图是聚簇索引的查询过程，每一个方框都是一页，里面存放多个索引行。查询主键为某值的记录时，从根节点开始查找，最终找到叶子节点中的记录（这里一共三层）。</p>
<p><img src="/assets/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.jpg" alt="聚簇索引查询过程"></p>
<p>要注意的是，除了最下面一层的叶子节点，包含记录的全部信息之外，其他层的非叶子节点，都是不包含全部信息的，只包含了主键和页号信息（当然还有一些头信息，但这里略过），这样做是既是为了节省查询空间，也是为了节省查询次数。</p>
<p>在 InnoDB 的聚簇索引实现中，叶子节点包含了记录的全部信息，也就是说顺着聚簇索引一直查下去，就直接能查到这条记录的全部信息。还有一些存储引擎不是这么做的，比如 MyISAM 就把记录的全部信息单独存放在另外一片区域，通过聚簇索引查询到最后，还需要通过指针，到另一片存储区域找到记录的全部信息。</p>
<h2 id="二级索引-1"><a href="#二级索引-1" class="headerlink" title="二级索引"></a>二级索引</h2><p>二级索引的查询逻辑，比聚簇索引复杂一点点。</p>
<p>下图是二级索引的查询过程，整体跟聚簇索引基本一样，但查到叶子节点时，只有这条记录的主键值，而没有这条记录的全部信息。还需要再通过主键的值，去聚簇索引那里查到记录的全部信息，这一步被称为 <code>回表</code>。</p>
<p><img src="/assets/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.jpg" alt="二级索引查询过程"></p>
<p>回表是为了省空间，如果一张表有 10 个索引，为每个索引都单独存储一份完整的记录信息，实在是太浪费空间了。聚簇索引通常只有几层而已，查询速度很快，回表并不会增加多少查询时间。</p>
<p>但是当查询数据的数量变多时，例如查询年龄在 18-60 岁之间的人群，可能会查到数万条记录，每条记录都要回表查询，这样查询的代价就大多了。因此查询时不要写 <code>select * from ...</code>，而是写到确切的字段 <code>select age from ...</code>，这样不需要查到全部信息，也就不需要回表，省下了大量的查询时间。</p>
<hr>
<p>记录一些常见的问题。</p>
<h2 id="为什么-InnoDB-使用-B-树"><a href="#为什么-InnoDB-使用-B-树" class="headerlink" title="为什么 InnoDB 使用 B+ 树"></a>为什么 InnoDB 使用 B+ 树</h2><p>通常回答的原因是，因为 B+ 树比 B 树层数少了很多，能够减少查询次数，减少 I/O 操作，此外还支持范围查询。</p>
<p>我自己的看法是，这个问题要放在整个 InnoDB 的设计中来看，InnoDB 的最小单位是页，一页 16 KB，按照页这一存储单位来设计数据结构，好像也只能设计出 B+ 树了，这是很顺理应当的事情。</p>
<h2 id="使用索引有什么规范"><a href="#使用索引有什么规范" class="headerlink" title="使用索引有什么规范"></a>使用索引有什么规范</h2><p>以下内容都来源自《<a href="https://juejin.cn/book/6844733769996304392" target="_blank" rel="noopener">MySQL 是怎样运行的：从根儿上理解 MySQL</a>》</p>
<ol>
<li>B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li>
<li>B+ 树索引适用于下边这些情况：<ul>
<li>全值匹配</li>
<li>匹配左边的列</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>用于排序</li>
<li>用于分组</li>
</ul>
</li>
<li>在使用索引时需要注意下边这些事项：<ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让<code>聚簇索引</code>发生页面分裂和记录移位的情况，建议让主键拥有<code>AUTO_INCREMENT</code>属性。</li>
<li>定位并删除表中的重复和冗余索引</li>
<li>尽量使用<code>覆盖索引</code>进行查询，避免<code>回表</code>带来的性能损耗。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>三层架构和MVC模式</title>
    <url>/2019/08/13/Software%20Architecture/</url>
    <content><![CDATA[<br>

<p>八月的第二周，来整理工作一个多月对于架构、模式的认识。</p>
<p>反思了一下，博客内容应该是自己在学习过程中的总结与思考，而不应该是科普与教学，应当写得更倾诉一些。</p>
<p>今天要整理的内容有两方面，一种是三层架构，另一种是MVC模型。</p>
<hr>
<p>架构，是指设计一个程序的结构，是一个相当宏观的概念。</p>
<p>我觉得要理解架构这个概念，最主要的是去把握<strong>宏观</strong>这个特征。换句话说，当考虑架构的时候，是不去思考软件的应用场景、实现细节这些的，而是站在一个统领全局的角度，去思考一个庞大的程序应该怎么部署的。</p>
<p>一个庞大的程序，应当采用什么样的结构，应当划分成哪几个模块，怎么设计才能实现高效开发，才能让一群码农共同实现进度，这是架构要去解决的问题。所以你看，这真的是一个很宏观的问题，是一个统筹部署的设计问题。</p>
<p>有许多被广泛使用的架构模式，其中最简单、最基础的是三层架构，我们来聊聊这种架构。</p>
<h1 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h1><p>三层架构是指，把一个项目拆成三层：第一层跟用户打交道，第二层处理业务逻辑，第三层处理数据库。</p>
<p>这三层的名字分别叫做表示层（PL）、业务逻辑层（BLL）、数据访问层（DAL）。</p>
<p><img src="/assets/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.jpg" alt="三层架构"></p>
<p>这三层的名字起得相当虎逼，煞有其事的，其实指的是很简单的东西。</p>
<ol>
<li>表示层：给用户看的，给用户操作的。</li>
<li>业务逻辑层：后台处理，干活的。</li>
<li>数据访问层：管数据的。</li>
</ol>
<p>一个项目拆成了  <code>数据 —&gt; 处理 —&gt; 展示</code>  三个部分，竖着看是不是三层。</p>
<p>你稍微一想，就会觉得这么分层是挺有逻辑、挺有道理的。不用说编程，做什么事情不都是这样子吗：首先拿到原材料，然后加工处理，最后展示出去。尽管有很多细节不一样，但是大致的流程就是这样子的。</p>
<p>通过三层架构，把一个项目的全部内容拆成三个层面的事情。最上面一层只跟用户打交道，用户看到什么，用户操作什么，用户输入了什么，全都在这一层；中间一层只跟业务逻辑打交道，拿到数据怎么处理，收到用户信息怎么加工，全在这一层；最底下一层只跟数据打交道，数据存放在哪里，怎么取出来，怎么把新数据存进去，全在这一层。</p>
<p>这种架构能够实现初步的“分而治之”，把大事拆成小块，每一部分做自己的事情，这是为了编程中的“解耦”。解耦就是解除耦合，关联得不要那么密切，这样好开发。</p>
<p>关于三层架构先说到这里。</p>
<hr>
<p>设计模式是针对于某一类场景而言的，是一个<strong>不太宏观</strong>的概念。</p>
<p>当面对着某一类情况，尽管细节上各有不同，但是这类情况有共性之处，有可以解决这类情况的一种方案，这就是设计模式。</p>
<p>你可以感受到，架构和设计模式不是同一高度的，架构非常宏观，设计模式没那么宏观，这是两个纬度的概念。再换个说法，架构面对的是所有情况，设计模式面对的是某一类情况。</p>
<p>我很努力地去表述，架构与设计模式不是同一个纬度的东西，尽管它们都是用来解决泛化场景的，但是层级是的的确确有差异的，设计模式是比架构低一个level的东西。这样去表述的目的，是为了解释清楚一个经常被问到的代码相关问题：三层架构与MVC模式的区别是什么？</p>
<p>现在我先这么回答：</p>
<blockquote>
<p>三层架构是一种架构，MVC模式是一种设计模式，它们解决问题的高度不同：</p>
<p>三层架构是为所有情景设计的，MVC模式是为其中一类情景设计的。</p>
</blockquote>
<p>接着来聊一聊MVC模式。</p>
<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p>MVC是<code>Model-View-Controller</code>的首字母合称，就是说把一个软件项目拆成三个基本部分——模型（Model）、视图（VIew）、控制器（Controller）。</p>
<p>你首先要认识到，MVC模式不是为所有场景设计的，它只是web应用的一种设计模式。为了更好地开发网页，前人设计了一种名叫“MVC模式”的设计模式，它就是为了web应用开发而存在的。</p>
<p>然后我们来仔细说说MVC模式是什么。</p>
<p>MVC模式有三个部分，但是为了说明方便，还要在这三个部分之外加上“人”的角色（也就是用户），来理解人是怎么跟这三个部分打交道的。</p>
<p><img src="/assets/MVC%E6%A8%A1%E5%BC%8F.jpg" alt="MVC模式"></p>
<p>我画了一张图，你能够看到MVC其实就是三个模块，与人直接打交道的是View和Controller模块：人看View模块（例如看静态网页、看网站视频），人操作Controller模块（例如点击鼠标选择）；而Model模块是藏在后面的，是View模块和Controller模块的桥梁。</p>
<p>也就是说：</p>
<ul>
<li>Model（模型）：后台处理逻辑</li>
<li>View（视图）：可视化部分</li>
<li>Controller（控制器）：</li>
</ul>
<br>

<br>

<br>

<br>

<br>

<hr>
<p>听到了一声灾厄。</p>
<p>不想写下去了，这一篇就写到这里吧。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC的引入</title>
    <url>/2019/08/04/SpringIoC/</url>
    <content><![CDATA[<br>

<p>八月的第一周，我们来说IoC</p>
<p>IoC是Spring框架的核心思想其一，原理不算复杂。</p>
<hr>
<p>Spring家族是Java中风光无限的一族，几乎所有Java项目所使用的框架，都跟Spring家族有关。有一些介绍中说，Spring框架是一种全栈式框架（或者是一站式框架），全栈（Full-stack）的意思就是说，编程里能干的所有活，它一家可以全包了，一条龙服务，可以应用于一切场景。</p>
<p>Spring在2004年发布了1.0版本。创建Spring的那哥们叫Rod Johnson，他自己写了本书，说当时的主流框架EJB可以换个思路写代码，后来觉得不痛快，就又写了一本书，说我们干脆换个框架算了，于是就有了Spring。说起来这哥们也是个神人，他本科计算机专业毕业的，然后读了个音乐博士。</p>
<p>Spring现在那么盛行，几乎所有公司都在用Spring框架，倒不是因为技术、架构这些，而是跟思想有关。一说思想这个词，一般事情就变得玄妙了起来，简单点说呢，用Spring这套模式写代码，写起来感觉得心应手，少了很多麻烦，写着写着代码冥冥之中感觉很轻便，这就是因为Spring在思想上很先进。Spring的核心思想有两种，一种是IoC，一种是AOP，我们今天说前面那个IoC。</p>
<hr>
<p>IoC的全称是Inversion of Control，翻译过来叫控制反转。这并不是一个见名知意的名词，首先要解释一下这个概念。</p>
<p>好比我现在要制造一辆汽车，从无到有一步一步地建造。</p>
<p>首先我要先制造出汽车底盘，根据底盘的大小来确定汽车的外壳有多大。如果我建造了一个5米长的底盘，我不可能再建造一个10米长的汽车外壳，装不上去呀。所以你发现了，汽车外壳必须要根据汽车底盘来制造，这也就是汽车外壳依赖于汽车底盘，换句话说，我们造外壳的时候，是被底盘牵着鼻子走的。</p>
<p>对于有设计欲望的汽车制造师来讲，这很让人不爽，明明我要大显身手地去设计汽车外壳，让自己的车外观上十分拉风，结果却要根据汽车底盘来设计，这不行。因此我们找到了一家汽车零件厂，我就先造外壳，造完之后需要多大的底盘，去找汽车零件厂给我提供。让汽车制造师一番折腾，现在可以直接造汽车外壳，然后再管汽车底盘了。汽车底盘反依赖于汽车外壳，也就是说，底盘被外壳牵着鼻子走了。</p>
<p>我们要讨论的IoC控制反转，这里的控制，其实说的就是谁牵着谁鼻子走。按照原先的理解，A是B的底层，A要控制B；现在B先行，A跟着B走，B反而控制A了，这就是控制反转。</p>
<p>你应该感受到了，Ioc并不是什么具体的技术，而是一种思想，或者更确切地说是一种设计模式。</p>
<hr>
<p>我们说了半天控制反转，怎么控制的，怎么反转的，都快绕晕了。其实谁控制谁根本就不重要，不管是A控制B还是B控制A，也没什么区别，反转了又能怎么样嘛。</p>
<p>关键是在于，原来A控制B，那是一点点往上搭积木，A也得搭，B也得搭。控制反转之后，现在B还是要做，但是A怎么来的，我们就不管了。</p>
<p>就像是刚才举的造汽车的例子，原来汽车是怎么造的，先造底盘，再造外壳，一步一步地很是繁琐，约束还多。后来我们只造外壳，那底盘呢，底盘让汽车零件厂造去了，我们不造了。怎么来的我也不管，反正到时候你给我就行了。</p>
<p>你说是不是省很多事？</p>
<p>总结一下，IoC思想有两点好处：</p>
<ul>
<li>其一，再也不用写一大堆的初始化代码了，这些扔给别人去做。</li>
<li>其二（这个更重要），我们把代码松绑了，原本紧密依赖的两部分如今拆开了，用祖师爷的话说就是“降低了耦合度”。</li>
</ul>
<hr>
<p>我们再来聊Spring。</p>
<p>Spring框架实现IoC主要是这样子的，它在A类和B类之外增设了一个管理区，A类写好之后放进管理区里，B类要用A类的时候就去找管理区，管理区自动为B类分配。</p>
<p>知乎上有个哥们挺逗的，他这么形容Spring实现IoC的过程：</p>
<blockquote>
<p>农业社会中，你需要一个对象，你必须亲手把它 new 出来。 </p>
<p>工业社会中，你需要一个对象，可以去工厂那里获取。 </p>
<p>共产主义社会中，你需要一个对象，只需要凭 ID 去对象池里面领。 </p>
<p>这是何等的共产主义精神！</p>
</blockquote>
<p>让Spring这么一处理，对于B类而言，原来是自己主动获取A类，现在是需要的时候管理区自动给我（用术语来说，这一步叫做<code>注入</code>），原来A类相关的代码都是自己管理，现在交给管理区去管理。这就叫做“降低了代码之间的耦合性”。</p>
<p>这个管理区叫做<code>IoC容器</code>，容器（Container）是编程里面装东西的。</p>
<p>好的，我们说的概念已经够多了，就说到这里吧。关于Spring实现IoC的具体过程，我们之后再说吧。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world</title>
    <url>/2019/07/21/helloworld/</url>
    <content><![CDATA[<br>

<p>你好呀。</p>
<p>这里是我写编程相关文章的地方，（尽量）每周更新一篇，来强迫自己学习。</p>
<p>我努力以<font color="#32CD32">说人话</font>为目标来写东西，尽量组织语言到谁都能听懂为止，虽然最终也不会有什么人来看啦。</p>
<p>我不会留任何联系方式的，这样你就没办法骂我写得渣了，嘻。</p>
]]></content>
  </entry>
  <entry>
    <title>(tips) hexo图片加载</title>
    <url>/2019/08/11/hexo%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<br>

<p>hexo搭配typora加载图片时，要设置图片路径。</p>
<p>共分两步走：</p>
<ol>
<li>设置typora的图片根目录</li>
<li>粘贴图片时，图片要放进assets文件夹中</li>
</ol>
<p>具体操作如下：</p>
<br>

<p>首先点击typora工具栏的<code>格式</code>，然后选择<code>图像</code>，再选择<code>设置图片根目录</code>，就会在markdown文件的页首（header）中出现这样一句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typora-root-url: ..</span><br></pre></td></tr></table></figure>

<p>注意冒号后面要设置成 <code>..</code> ，意思是说typora的图片根目录，是文件的上一级文件夹。</p>
<p>（页首header截图如下）</p>
<p><img src="/assets/%E5%9B%BE1.png" alt="图1"></p>
<br>

<p>设置完typora的图片根目录后，就可以粘贴图片了，但是要注意图片要放进<code>assets</code>文件夹当中。</p>
<p>拿刚刚粘贴进来的上张图片来说，在markdown文件中，路径是这么写的：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图1</span>](<span class="link">/assets/图1.png</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/assets/%E5%9B%BE2.png" alt="图2"></p>
<p>这样就可以了。</p>
<br>

<p>目录结构是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _posts</span><br><span class="line">│   └── (tips) hexo图片加载.md</span><br><span class="line">└── assets</span><br><span class="line">    ├── 图1.png</span><br><span class="line">    └── 图2.png</span><br></pre></td></tr></table></figure>

<hr>
<p>每次用hexo写文章，都要被环境配置搞得心态崩溃 = =</p>
<br>]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的反射机制</title>
    <url>/2019/07/25/reflect/</url>
    <content><![CDATA[<br>

<p>七月的第四周，来写反射。</p>
<p>反射是java很有意思的机制，有一点注入灵魂的感觉。</p>
<hr>
<p>写程序可以认为是女娲捏泥人的过程，女娲和了一团稀泥，揉捏出一个小人，放在地上，活了。</p>
<p>你设身处地想象一下，如果你是女娲造的其中一个小人，在落地之前一直都没有活。</p>
<p>那在你还没活的时候，你是不知道外面的世界长什么样子的，也不知道将来会遇到哪些小人。你不知道还有小王、小张、小李一起被造出来，你也不知道他们是什么样子的。</p>
<p>总之你只知道你自己的事情，你对其他的一无所知。</p>
<p>这就是你在活之前的状态。</p>
<hr>
<p>写程序如果按照正常理解，就应该是程序运行，安分守己地完成自己的任务。</p>
<p>如果写了一个名叫 <code>apple</code> 的类，程序运行的时候， <code>apple</code> 就应该安分守己地做 <code>apple</code> 的事情，它不会知道，在程序中还有 <code>banana</code> 、 <code>peach</code> 、 <code>watermelon</code> ，也没有办法知道，除了自己以外的其他类能够做什么。</p>
<p>反射是做什么的呢？</p>
<p>就像是你刚被女娲捏出形状时，女娲对你说：“以后你将遇到一个叫‘小王’的人，记得找他玩。”然后你活了之后，果然找到了小王，愉快地跟他玩了起来。</p>
<p>程序在运行的时候，具有了访问别人的能力，甚至还能用别人的东西，这就是反射。</p>
<hr>
<p>反射（reflect）是一个让人听了一头雾水的名字，但实际上确实也没有别的更好的表述方法，这就是一种比较难以形容的特性。如果暂时忘了这个名字，直接去理解这种特性，隐约理解之后再回来看反射这两个字，会稍微容易一些。</p>
<p>维基百科对于反射的描述，还是大概能看懂的，不然你试着搜搜百度百科的解释，当你精通概念之后回看才能勉强看懂。维基百科是这么说的：</p>
<blockquote>
<p>在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。</p>
</blockquote>
<p>java是一门具有动态性的语言，反射就是动态性的典型代表，这里的动态，说的就是程序正在运行。程序一边运行着，一边去查看自己的状态，然后做出修改，全程不停，就是动态。（但是java只能说有动态性，不能算动态语言）</p>
<hr>
<p>反射的原理是较为复杂的，这里面涉及到java虚拟机相关的内容，我基本也是小白，尽量按照自己的理解写清楚。</p>
<p>打开编程软件之后，我首先创建一个文件，然后在里面写上一段代码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello word!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个文件，它的文件名是<code>Hello.java</code>（就像是新建一个word文件，随便写了句话，保存之后文件名叫做<code>Hello.doc</code>一样），现在这个文件的后缀名是<code>.java</code>，这是我们的源代码文件。</p>
<p>你一定听过编译这个词，编译的意思是说，你写完代码之后，会有一种叫做编译器的东西帮我们把代码变成一堆010101……的二进制数字文件，也就是翻译成机器语言。编译器翻译完，会生成一个<code>Hello.class</code>文件，这时这个文件的后缀名是<code>.class</code>，这是我们的二进制流文件。</p>
<p>现在有了翻译给机器听的<code>Hello.class</code>文件之后，这个文件就要加载进java虚拟机当中，让电脑自己去读程序运行了。java虚拟机读取<code>Hello.class</code>文件的过程，是<font color="#32CD32">类加载过程</font>。</p>
<p>我们今天说的反射，它的原理就是这个<font color="#32CD32">类加载过程</font>。</p>
<p><img src="/assets/%E5%8F%8D%E5%B0%84%E5%89%8D.jpg" alt="反射前"></p>
<p>类加载的具体过程比较复杂，涉及到java虚拟机的很多内容，我们来说简化的过程。</p>
<p>简单来说呢，<code>.java</code>文件里写了很多代码，但是归归类可以分成这么几种：</p>
<ul>
<li>干垃圾</li>
<li>湿垃圾</li>
<li>有害垃圾</li>
<li>可回收垃圾</li>
</ul>
<p>java虚拟机中，也有相对应的区域，来分类存放写好的代码（以二进制数字的形式）：</p>
<ul>
<li>干垃圾桶</li>
<li>湿垃圾桶</li>
<li>有害垃圾桶</li>
<li>可回收垃圾桶</li>
</ul>
<p>类加载就是一一对应，垃圾分类的过程。</p>
<p>反射就是要在垃圾分类之后，问垃圾管理员要垃圾。</p>
<blockquote>
<p>你好，我是收废品的，请问有废易拉罐吗，给我一个。</p>
</blockquote>
<hr>
<p>我们再来重新看一下维基百科对于反射的定义：反射是指计算机程序在运行时可以访问、检测和修改它本身状态或行为的一种能力。</p>
<p>比如我想知道，某一个类，它叫什么，它有哪些成员变量。</p>
<p>java虚拟机会在类加载过程中，生成一个Class类的对象，比如我之前写的那个<code>Hello.java</code>文件，java虚拟机将实例化一个Hello对象，我们之后可用直接用这个对象的各个方法，来进行反射操作（我们终于走到反射了）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class testClass = Hello.class;</span><br><span class="line"><span class="comment">// 获取类的名字</span></span><br><span class="line">testClass.getName();</span><br><span class="line"><span class="comment">// 获取类的成员方法</span></span><br><span class="line">testClass.getDeclaredFields();</span><br></pre></td></tr></table></figure>

<p>所以现在，我们通过反射，可以获知某一个类叫什么名字、父类是什么、限定符是什么、有什么成员变量、有什么构造方法……等等关于这个类的一切，我想知道什么，全都可以知道了。</p>
<p>那么我们现在梳理一下步骤：</p>
<ol>
<li>实例化一个Class类</li>
<li>调用这个Class类的方法，以获取到想要的东西</li>
</ol>
<p>如果Class类的功能，你觉得不够用，或者用起来不顺手，还有别的几种类可以去用，分别是Constructor（构造方法）、Field（成员变量）、Method（成员方法）和其他。</p>
<p>相关的方法列表有人帮忙总结出来了，详见下图。</p>
<p><img src="/assets/%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.png" alt="1564150307754"></p>
<hr>
<p>参考文献：</p>
<p><a href="https://www.imooc.com/article/8021" target="_blank" rel="noopener">https://www.imooc.com/article/8021</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></p>
<p><a href="https://zh.wikipedia.org/wiki/反射_(计算机科学)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)</a></p>
<br>

<p>第一篇怎么写的这么烂呜呜呜……不改了，没时间了，到新的一周了= =</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>没写完的递归</title>
    <url>/2019/09/01/%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>八月和九月交界的一周，来学习递归算法。</p>
<p>真的是被递归给搞怒了，拿出一周来跟它谈谈。</p>
<hr>
<p>递归是一个反复调用自己的过程，<font size="7">A</font> →  <font size="6">A</font> → <font size="4">A</font> → <font size="6">A</font> →  <font size="7">A</font> ，一层层进去，再一层层出来。我觉得自己一直以来对递归感到迷惑，主要是因为只注意到了进去的过程，而忽视了出来的过程。至于什么停止条件的判断，其实倒还在其次。</p>
<p>我隐约感觉，真正理解递归，能够很熟练地凭感觉写递归，应该要去学习函数式编程，但是这周权且只能写写初级认知了。</p>
<p>我认为写递归要搞清楚两个地方：</p>
<ol>
<li>用递归做什么</li>
<li>在乎的是【递归前】还是【递归后】</li>
</ol>
<p>第一个问题，是要清楚为什么需要使用递归，在什么地方使用递归。思考清楚了使用递归的场景，也就顺便思考清楚了递归函数的传参、返回值是什么。</p>
<p>第二个问题，是搞清楚在调用递归时，究竟是关注一步步进去，还是关注一点点出来。</p>
<p><img src="/assets/%E9%80%92%E5%BD%92.jpg" alt="递归"></p>
<p>画了一张简图，把递归的过程比作【下楼梯】再【上楼梯】的过程。</p>
<p>哎鸭，写着写着发现跟自己想的不太一样，好像要推导重来，可是又到了下一周的周一了。</p>
<p>这周每天晚上都在写一封十年的仪式信，周末又赶上搬家和无手机日，时间没有规划好，不写了，呜呜呜。</p>
<p>下一周学习 spring cloud 。</p>
<br>

<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：排序</title>
    <url>/2020/04/26/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<br>

<p>四月的第四周，来整理排序算法，本篇文章基于 CS-Notes 的《算法-排序》，那篇文章的代码写得非常通用，使用泛型并继承 Comparable 接口来进行，本篇只针对数字做排序，重点放在算法而不是兼容上。</p>
<p>算法写完这一篇就暂时不写了，每天细水长流做一做题，多积累一点算法底蕴再抽空回来写。</p>
<hr>
<p>总结写在最前面，方便查看。本篇文章涉及七种排序算法（以及几种亚种），时间和空间复杂度的对比汇总如下：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>稳定性</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>×</td>
<td>N²</td>
<td>1</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>√</td>
<td>N²</td>
<td>1</td>
</tr>
<tr>
<td>插入排序</td>
<td>√</td>
<td>N ~ N²</td>
<td>1</td>
</tr>
<tr>
<td>希尔排序</td>
<td>×</td>
<td>N 的若干倍乘于递增序列的长度</td>
<td>1</td>
</tr>
<tr>
<td>归并排序</td>
<td>√</td>
<td>NlogN</td>
<td>N</td>
</tr>
<tr>
<td>快速排序</td>
<td>×</td>
<td>NlogN</td>
<td>logN</td>
</tr>
<tr>
<td>堆排序</td>
<td>×</td>
<td>NlogN</td>
<td>1</td>
</tr>
</tbody></table>
<p>P.S. 稳定性的意思是，相同项排序前后不能调换位置，例如 1、[2]、(2)、3 排序后不能变成 1、(2)、[2]、3。</p>
<hr>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>遍历最小的交换</p>
<p><img src="/assets/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.gif" alt="选择排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] selectSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// 从第一个开始，执行到倒数第二个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[minIndex] &gt; nums[j]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, i, minIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>相邻比较，最小的升到最前面</p>
<p><img src="/assets/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序">（这个 gif 是反过来的，最大的挪到最后）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 从倒数第一个开始，执行到第i+1个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>每个数字一路往前交换，等效为插入</p>
<p><img src="/assets/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.gif" alt="插入排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] insertSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 从第二个开始，每个数字一路往前交换，直到前面比它小为止</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>改进的插入排序，设置了间隔</p>
<p><img src="/assets/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] shellSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 间隔数量，初始值为[1, 4, 13, 40……]数列中最接近n的那个</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 从第h+1个开始，每个数字一路往前交换（间隔为h），直到前面比它小为止</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j--) &#123;</span><br><span class="line">                swap(nums, j, j - h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h /= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>将数组分成两个子数组，分别排序，再合并</p>
<p><img src="/assets/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="归并排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] helpArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mergeSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    helpArray = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">return</span> doMergeSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] doMergeSort(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        doMergeSort(nums, l, mid);</span><br><span class="line">        doMergeSort(nums, mid + <span class="number">1</span>, h);</span><br><span class="line">        merge(nums, l, h, mid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 技巧：用辅助数组</span></span><br><span class="line">    System.arraycopy(nums, l, helpArray, l, h - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, curr = l;</span><br><span class="line">    <span class="keyword">while</span> (curr &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid &amp;&amp; j &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helpArray[i] &lt;= helpArray[j]) &#123;</span><br><span class="line">                nums[curr++] = helpArray[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[curr++] = helpArray[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">            nums[curr++] = helpArray[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[curr++] = helpArray[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>让某数左边都是小于等于它的数，右边都是大于等于它的数，再二分递归</p>
<p><img src="/assets/%E5%BF%AB%E6%8E%92.png" alt="快排"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    doQuickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doQuickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; h) &#123;</span><br><span class="line">        <span class="comment">// mid左边都是小于等于它的数字，右边都是大于等于它的数字</span></span><br><span class="line">        <span class="keyword">int</span> mid = partition(nums, l, h);</span><br><span class="line">        doQuickSort(nums, l, mid - <span class="number">1</span>);</span><br><span class="line">        doQuickSort(nums, mid + <span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第一个数作为比较基础</span></span><br><span class="line">    <span class="keyword">int</span> target = nums[l];</span><br><span class="line">    <span class="keyword">int</span> i = l, j = h + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="comment">// 左 -&gt; 右  找更大的数</span></span><br><span class="line">        <span class="keyword">while</span> (++i != h &amp;&amp; nums[i] &lt; target) ;</span><br><span class="line">        <span class="comment">// 左 &lt;- 右  找更小的数</span></span><br><span class="line">        <span class="keyword">while</span> (--j != l &amp;&amp; nums[j] &gt; target) ;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时 i&gt;j 要跟坐标小的交换，并返回这个小坐标</span></span><br><span class="line">    swap(nums, l, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>数组中坐标 2k 和 2k+1 的数字，是 k 的叶子</p>
<p><img src="/assets/%E5%A0%86%E6%8E%92%E5%BA%8F.gif" alt="堆排序"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] heapSort(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 从倒数第二层预排一次，大顶堆</span></span><br><span class="line">        sink(nums, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最大的数交换到数组尾，将交换来的数再大顶堆下沉</span></span><br><span class="line">        swap(nums, <span class="number">1</span>, n--);</span><br><span class="line">        sink(nums, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (parent * <span class="number">2</span> &lt;= n) &#123;</span><br><span class="line">        <span class="keyword">int</span> son = parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (son &lt; n &amp;&amp; nums[son] &lt; nums[son + <span class="number">1</span>]) &#123;</span><br><span class="line">            son++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 父亲一定比孩子大，排到某层符合就不用排了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[parent] &gt;= nums[son]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, parent, son);</span><br><span class="line">        parent = son;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>整理完算法，顺便学习一下 Java 默认提供的一些排序 API。</p>
<h1 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable &amp; Comparator"></a>Comparable &amp; Comparator</h1><p>Java 排序相关的内容，最常用到的就是 Comparable 和 Comparator，这两个都是接口类。</p>
<p>Java 对容器、数组进行排序时调用的 sort() 方法（例如 <code>Collections.sort(list)</code>、<code>Arrays.sort(array)</code>）时，要不然让容器内的元素实现 Comparable 接口，要不然自己重写 Comparator 接口说明排序逻辑。知乎文章<a href="https://zhuanlan.zhihu.com/p/55934430" target="_blank" rel="noopener">《Java 中的排序》</a>对此解释得清晰明了：</p>
<blockquote>
<ul>
<li><p>如果一个类实现了 Comparable 接口，那么它“天生”就是可以借助 Collections、Arrays、SortedMap、SortedSet 等类来进行排序。</p>
</li>
<li><p>但是，如果一个类没有实现 Comparable 接口，却也想利用 Collections、Arrays、SortedMap、SortedSet 等来进行排序，就可以通过指定一个自定义的 Comparator 来实现。</p>
</li>
</ul>
</blockquote>
<p>如果觉得两个接口容易记混，可以思忖一下名字，一个叫做 Comparable（可以比较），表明实现该接口的类是可以进行比较的，另一个叫做 Comparator（比较器），表明该接口是用来确定比较大小逻辑的。</p>
<p>具体使用逻辑懒得写了，看看之后有没有写的动力吧……</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>线程入门</title>
    <url>/2019/10/27/%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<br>

<p>十月的第四周，学习多线程。</p>
<p>借着工作需求入门了线程，但是需求并不用考虑并发风险，使用的也是封装好的对象，因此这次入门入得比较浅。</p>
<p>这篇博文偏实用，有关概念解释的部分就略过不提了。</p>
<hr>
<p>原始的创建线程的方法有三种，分别是：</p>
<ol>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口</li>
</ol>
<p>注意，这里说的是创建线程，因此只总结怎么【搭架子】，不总结怎么【使用线程】。</p>
<p>这一部分基本全部参考<a href="http://zhangchangle.com/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e4%ba%8c%e3%80%81%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b" target="_blank" rel="noopener">博客《CS-Notes》</a>对于 Java 并发的梳理，这个博客的内容非常优质（不只是 Java 多线程与并发的部分），十分推荐。</p>
<h1 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h1><p>这是一种最为原始的方式，继承 Thread 类，重写 run 方法以实现线程功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PzThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello,pz."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是指，我创建了一个名为 <code>PzThread</code> 的类，该类由于继承 Thread 类因而是一个线程类，它重写了父类的 run 方法，打印了一句话：【hello,pz.】。</p>
<p>使用时也异常简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> PzThread();</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>首先实例化一个线程出来，然后启动线程，当线程启动之后，控制台上打印了一句话：【hello,pz.】。</p>
<br>

<p>一般情况下不要使用这种方式来创建线程，因为通过继承来实现实在是太臃肿了，很多场景下我们只需要让线程跑起来，实现某个功能（即重写 run 方法），但是继承会实现 Thread 类的全部信息，性能消耗太大。而且 Java 是单继承的，继承了 Thread 类就不能继承其他类了。</p>
<br>

<h1 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h1><p>Runnable 接口是一切线程创建的根源，其实上面【继承 Thread 类】的途径，也是间接使用了本途径来创建线程的。</p>
<br>

<p>比较传统的实现 Runnable 接口的方式是，创建一个类，该类 <code>implements Runnable</code> 来实现 Runnable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PzRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是创建一个类，未免太大张旗鼓了些，还要新建一个类，设置好类名，实现接口，之后再实例化，兴师动众。其实实例化对象并不需要创建一个类出来，实现接口就行，用匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable pzRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，Runnable 接口是一个函数式接口，只定义了 run 方法，可以使用 lambda 表达式的方式来实例化，那就更简单了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable pzRunnable = () -&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面三种实现，都只是写了外壳，里面没有写具体的实现过程，具体的实现是要重写 Runnable 接口的 run 方法的。</p>
<p>我写了三种实现 Runnable 接口的代码，第一种最容易懂，后面两种如果有困惑，看一看 lambda 表达式就能理解了。</p>
<br>

<p>实现了 Runnable 接口之后，把它作为参数，放进 Thread 的构造方法里就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>这样就可以了。</p>
<br>

<p>要不再完整地走一遍？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口，重写 run 方法 （这里使用匿名内部类的方式，即上面的第二种）</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"by runnable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程并开启</span></span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台上会打印出这样一句话：by runnable</span></span><br></pre></td></tr></table></figure>

<br>

<h1 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h1><p>以上两种方式，都没有任何的返回值，线程执行动作，执行完就结束了，无声无息。实现 Callable 接口的目的，就是为了让线程执行完之后，能返回信息。</p>
<p>简单对比一下，Runnable 接口和 Callable 接口，在代码上的区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现 Runnable 接口</span></span><br><span class="line">Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 Callable 接口</span></span><br><span class="line">Callable callable = <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你会发现，实现两个接口都只需要重写一个方法：</p>
<ul>
<li>实现 Runnable 接口需要重写【没有返回值】的 run 方法</li>
<li>实现 Callable 接口需要实现【返回一个对象】的 call 方法。</li>
</ul>
<p>其他的地方，在用法上仿佛没有什么不同。</p>
<p>实际上，Callable 接口还支持泛型，你可以指定返回值的数据类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定返回 String 类型</span></span><br><span class="line">Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<p>传统的线程设计，是没有返回值的概念的，因此没办法用线程类来获得返回值。JUC 包设计了一个新的接口：Future，来接收线程的返回值（和其他的功能）。Future 类是一个接口，无法直接实例化，因此又设计了一个名为 FutureTask 的类，该类实现了Future 接口和 Runnable 接口，打通了【线程功能】和【返回值功能】。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br></pre></td></tr></table></figure>

<p>上面这两行代码，是将刚才写好的 callable 对象，放进 futureTask 中，辗转放进线程中。你可以感受到，FutureTask 类是一个中介，它也支持泛型（不过上面这两行代码没写泛型）。</p>
<p>FutureTask 类有一个 get 方法，用于获取 callable 的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object returnStr = futureTask.get();</span><br></pre></td></tr></table></figure>

<p>（如果指定了 FutureTask 的泛型，上面还可以更确切地指定数据类型，例如把上面代码的 Object 改成 String）</p>
<p>这个 get 方法需要处理两类异常：InterruptedException 和 ExecutionException。</p>
<hr>
<p>需求一不小心写完了……啥都没学到，算了先写到这里叭。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式</title>
    <url>/2019/10/20/Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<br>

<p>十月的第三周，来学习 Lambda 表达式。</p>
<p>这周休息一下，本来呢要学习 Java 8 的函数式编程特性，Lambda 表达式只是其中的一部分，结果为了写之前的博文每周都欠债，这周水一下……</p>
<hr>
<p>先来讨论，lambda 表达式是干什么的。</p>
<p>Java 是一门面向对象的语言，万物皆对象，做什么也都离不开对象。对象内可能有属性，可能有对象，也有可能有方法，就比如说：我，18 岁（属性），有只猫（对象），我喜欢撸猫（方法）。Java 面向对象的体现就在于，我多少岁、有什么、做什么（也就是对象的属性、方法等等），前提都在于“我”的存在。</p>
<p>所以说，Java 里存在着对象，也存在着行为（方法），但是行为一定要有对象作为前提，不存在脱离了对象的行为。就好比说我喜欢撸猫，【喜欢撸猫】这个行为，一定是要有“人存在”作为前提的，不存在着没有执行动作人的行为。</p>
<p>可如果，我只需要行为，不在乎对象是谁呢？</p>
<p>我举一个例子。比如说，有一个列表需要排序，排序是一种行为，但是列表本身没有排序的能力。那么，列表要实现排序这种行为，就要先找一个【排序者】，让它去执行排序这个行为。这是一条很清晰的逻辑线：列表要排序，先找一个【排序人】，让它去排序。这个逻辑看上去很正常，可问题在于，列表根本就不在乎，到底是谁去执行排序这个行为，列表在乎的，只是它需要排序这个行为本身。在这种场景下，我们只需要行为，而不需要去关心拥有行为能力的那个对象是谁。</p>
<p>说得再清晰一些：我们不想传入对象，我们只想传入行为。</p>
<p>这就是 lambda 表达式存在的意义。</p>
<hr>
<p>所有教程介绍 lambda 表达式，上来就是一通劈头盖脸的匿名内部类代码，你想清楚逻辑就知道为什么要这么介绍。我们的目标是什么，是为了传入行为，而不在乎对象是谁。原来怎么解决的，用匿名内部类，虽然为了传入行为还是传入了对象，但是这个对象是一个匿名的对象。理解了吗，为什么用匿名内部类，是为了用一个匿名的对象传入我们想要的行为，对象是谁不重要，行为本身才重要。</p>
<p>Jdk 8 之后，函数式编程出头了，lambda 表达式出现了，既然对象是谁不重要，那么我们也就不用匿名了，干脆只传行为就行了。</p>
<p>你看这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">"按钮被点击了"</span>));</span><br></pre></td></tr></table></figure>

<p>这一行代码的意思是：在小括号内，我传入了一个行为，而且我只传入了一个行为。</p>
<p>我对于 lambda 表达式的解释到此为止，我建议再去看看这篇知乎问答：<a href="https://www.zhihu.com/question/20125256/answer/324121308" target="_blank" rel="noopener">《Lambda 表达式有何用处？如何使用？》</a>，写得行云流水，逻辑上非常舒畅。如果看后面的内容觉得云里雾里，可以再回头看一下这篇回答。</p>
<hr>
<p>当我要开始写 lambda 表达式具体如何使用时，内容分成了两部分：</p>
<ol>
<li>lambda 表达式怎么使用（语法）</li>
<li>lambda 表达式用在哪里</li>
</ol>
<p>实际上，我一直都对 lambda 表达式的语法不存疑惑，它在语法上就已经足够让人看懂了，即使是不会写，但也能大致看懂别人写的代码想做什么。我一直以来不理解的地方在于，lambda 表达式到底要用在哪里，当我写哪些代码的时候，可以使用 lambda 表达式？</p>
<p>所以我们先来看，lambda 表达式要用在哪里，lambda 表达式的类型究竟是什么。</p>
<br>

<p>我们先搞清楚，lambda 表达式的类型是什么。</p>
<p>在 Java 中，lambda 表达式依旧是一个类，它是一个接口的实现类。</p>
<p>我们来举一个例子，一个列表排序的例子。</p>
<ol>
<li><p>一个排序的场景</p>
<p>我们自定义一个 Person 类（代码略），该类有两个属性：姓名、年龄。我们实例化三个 Person 对象，然后把这三个 Person 对象放进一个列表里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">21</span>);</span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">"李四"</span>, <span class="number">20</span>);</span><br><span class="line">Person person3 = <span class="keyword">new</span> Person(<span class="string">"王五"</span>, <span class="number">22</span>);</span><br><span class="line">List&lt;Person&gt; personList = Arrays.asList(person1, person2, person3);</span><br></pre></td></tr></table></figure>

<p>此时这个列表里面有三个对象，它们的排列顺序是往里添加的顺序，也就是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [Person&#123;name='张三', age=21&#125;, Person&#123;name='李四', age=20&#125;, Person&#123;name='王五', age=22&#125;]</span></span><br></pre></td></tr></table></figure>

<p>我们现在希望，这个列表里面的三个 Person 对象，能够按照年龄的大小排序。我们可以通过 lambda 表达式来实现排序（暂且先看着，不要理语法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personList.sort((a, b) -&gt; a.getAge() - b.getAge());</span><br><span class="line"></span><br><span class="line"><span class="comment">// [Person&#123;name='李四', age=20&#125;, Person&#123;name='张三', age=21&#125;, Person&#123;name='王五', age=22&#125;]</span></span><br></pre></td></tr></table></figure>

<p>你看，此时这个列表里面，就按照年龄排序了。</p>
</li>
<li><p>拆解看实现过程</p>
<p>上面通过 lambda 表达式实现了按照年龄排序，只用了一行代码。实际上这是两行代码合了起来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personList.sort((a, b) -&gt; a.getAge() - b.getAge());</span><br><span class="line"><span class="comment">//  ↓↓↓  （实际上，上面这行代码，就是下面这两行代码的组合）</span></span><br><span class="line">Comparator&lt;Person&gt; comparator = (a, b) -&gt; a.getAge() - b.getAge();</span><br><span class="line">personList.sort(comparator);</span><br></pre></td></tr></table></figure>

<p>你观察那句 lambda 表达式，即 <code>(a, b) -&gt; a.getAge() - b.getAge()</code>，它被赋给了 Comparator，而 Comparator 实际上就是一个接口，一个负责排序的接口。</p>
<p>那么这行代码：<code>Comparator&lt;Person&gt; comparator = (a, b) -&gt; a.getAge() - b.getAge();</code>，它的意思是说：</p>
<ul>
<li>我们写了一句 lambda 表达式。</li>
<li>这句 lambda 表达式，实际上是 Comparator 接口的一个实现类。</li>
</ul>
</li>
</ol>
<br>

<p>我们来思考一下，通过 lambda 表达式，到底做了一件什么事情。</p>
<p>在通常情况下，某一个方法需要一个接口的具体实现类的对象，那我们就要自己去写一个类，让该类继承接口，实现接口的方法，从而获得一个实现了接口的类，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（如果觉得这样子很繁琐，也可以通过匿名内部类的方式去实现。）</p>
<p>而通过 lambda 表达式，我们不再需要自己写一个类出来，让这个类去继承接口实现方法，这非常麻烦，而且会模糊掉我们的目的。我们不再新建一个类，而是使用 lambda 表达式，lambda 表达式本身，就是一个接口的实现类。</p>
<p>这样做最大的好处（在我看来），就是我们无视了对象，直视行为本身。</p>
<p>你重新来看这行排序代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">personList.sort((a, b) -&gt; a.getAge() - b.getAge());</span><br></pre></td></tr></table></figure>

<p>你不用管它是什么意思，实现了什么功能，你是不是能非常直观地看出，小括号里面【在做某件事】，括号里面它是一个很清晰可知的行为。我们通过拆解代码能知道，括号里面的这句 lambda 表达式，实际上是一个类，但是在代码的直观性上，它是什么不重要，在这里，它就代表了一个行为。</p>
<p>简洁，直观。</p>
<hr>
<p>我再次把 lambda 表达式的类型表述一遍：</p>
<blockquote>
<p>lambda 表达式是函数式接口的一个实例，但 Lambda 表达式本身不包含它要实现的函数式接口的信息，这要由它所在的上下文推断出来。</p>
</blockquote>
<p>这句话摘自<a href="http://www.lambdafaq.org/what-is-the-type-of-a-lambda-expression/" target="_blank" rel="noopener">《What is the type of a lambda expression?》</a>。这句话表达了两件事：</p>
<ol>
<li>lambda 表达式的类型是一个函数式接口</li>
<li>lambda 表达式本身不含接口信息，接口信息是编译器根据上下文猜出来的。</li>
</ol>
<p>第一条多了一点信息，它说 lambda 表达式的类型不光是接口，还是函数式接口。这个我觉得顺带一提就可以了，函数式接口的意思是，只包含一个抽象方法声明的接口。你设想一下，lambda 表达式的作用是传入行为，一个方法对应一个行为，如果接口中有多个抽象方法，那岂不是就有多个可传入的行为，那一条 lambda 表达式肯定做不到。我们这里是反推了，其实函数式接口的概念应该先于 lambda 表达式。</p>
<p>这第二条，就要说到 lambda 表达式的语法了。</p>
<br>

<p>lambda 表达式的基本样板长这样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(      ) -&gt; </span><br><span class="line">(      ) -&gt; &#123;       &#125;</span><br></pre></td></tr></table></figure>

<p>左边的小括号放参数，右边要不然没有大括号，放表达式；要不然有大括号，放执行语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">()              5</span><br><span class="line">x               2 * x</span><br><span class="line">(x, y)      -&gt;  x + y</span><br><span class="line">(int x)         &#123; return 2 * x; &#125;</span><br><span class="line">(String s)      System.out.println(s)</span><br></pre></td></tr></table></figure>

<p>以上是几个例子，大致观察一下就能看出，lambda 表达式是一种崇尚简洁的表达式，大小括号、参数类型、返回体等等都是能省则省，总之能让编译器分析上下文猜出来的，都尽量不写。如果原接口声明了参数类型，那么就可以不在 lambda 表达式中写清楚数据类型，如果原接口声明了返回值类型，并且比较简单，那么在 lambda 表达式中就可以只写一句表达式，而无需写执行语句，编译器会猜到我们想返回这个表达式。</p>
<p>例如，对于这句 lambda 表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(x, y) -&gt; x + y</span><br></pre></td></tr></table></figure>

<p>你可以写成这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure>

<p>但是当所有的信息（包括很多冗余信息）都写出来时，会让代码丧失掉直观性，你可能无法看一眼就知道这句 lambda 表达式想做什么。因此在编译器能够分析出来的前提下，应当尽量少写，让 lambda 表达式想传入的行为变得尽可能直观。</p>
<p>本篇就写到这里。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL InnoDB 数据存储结构</title>
    <url>/2021/01/19/MySQL-InnoDB-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<br>

<p>新年的第四周，来学习 MySQL 默认存储引擎 InnoDB。</p>
<p>这一周从数据存储结构入门，学习 MySQL 是怎么存储数据的。</p>
<p>我学习 MySQL 基本全部来源自《<a href="https://juejin.cn/book/6844733769996304392/section" target="_blank" rel="noopener">MySQL 是怎样运行的：从根儿上理解 MySQL</a>》，这是本电子书，下面的绝大多数图片、表格、内容都来源自本书，这本书写得非常详尽，是我最近一年读过最好的书。</p>
<hr>
<p>MySQL 数据库，从宏观看到微观，最大的是<strong>表空间</strong>（最大 64TB），表空间中有若干个<strong>组</strong>（256MB），一个组中有 256 个<strong>区</strong>（1MB），一个区中有 64 个<strong>页</strong>（16KB），一个页中有若干<strong>行</strong>，每一行都是一条数据。</p>
<p>行是 MySQL 中最小的单位，代表一条数据，比如下面这个数据库，体现在存储上就是两行数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+----+-----+------+------+</span><br><span class="line">| ID | c1  | c2   | c3   |</span><br><span class="line">+----+-----+------+------+</span><br><span class="line">| 1  | bbb | cc   | d    |</span><br><span class="line">| 2  | fff | NULL | NULL |</span><br><span class="line">+----+-----+------+------+</span><br></pre></td></tr></table></figure>

<p>我们从 MySQL 最小的单位<code>行</code>，一直往大学习，最后学习到<code>表空间</code>。</p>
<hr>
<h1 id="行"><a href="#行" class="headerlink" title="行"></a>行</h1><p>MySQL 表中的一条数据，存储方式被称为<strong>行格式</strong>，MySQL 5.0 之后默认的行格式是 <code>Compact</code>。除了 <code>Compact</code> 行格式外，还有三种，原理大致相同，下面只学习 <code>Compact</code> 行格式。</p>
<p>以两条数据为例，做了一张示意图：</p>
<p><img src="/assets/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F.jpg" alt="compact行格式"></p>
<p>大致可以列出这些注意点：</p>
<ol start="0">
<li><p><code>CHAR(M)</code> 和 <code>VARCHAR(M)</code> 的 M 都是指最大字符长度，<code>CHAR(M)</code> 固定长度，<code>VARCHAR(M)</code> 可变长度。</p>
<ul>
<li><code>CHAR(10)</code> 存储 “aaa” 为 “aaa       （补 7 个空格）”（空格在 ascii 中是 0x20）</li>
<li><code>VARCHAR(10)</code> 存储 “aaa” 为 “aaa”</li>
<li>顺便一提，以 utf-8 为例（1 个字符占 3 个字节），<code>CHAR(10)</code> 在 MySQL 5 之前占用 10 × 3 = 30 字节，在 MySQL 5 之后占用 10 - 30 字节，在节省空间和避免碎片之间做了平衡。</li>
</ul>
</li>
<li><p>变长字段长度列表</p>
<ul>
<li>所有非 NULL 的变长字段，字节长度，倒序排列</li>
<li>每个长度可能占 1 个字节（例如上图），也可能占 2 个字节</li>
</ul>
</li>
<li><p>NULL 列表</p>
<ul>
<li>可以不存在，如果该表的所有字段都不能为 NULL</li>
<li>允许为 NULL 的字段，是否为 NULL，倒序排序成 bitmap，补足整字节</li>
</ul>
</li>
<li><p>头信息</p>
<p>共 5 字节，即 40 bit。</p>
<p><img src="/assets/compact%E8%A1%8C%E5%A4%B4%E4%BF%A1%E6%81%AF.jpg" alt="compact行头信息"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
</li>
<li><p>真实数据</p>
<ul>
<li><code>DB_ROW_ID</code> 不一定存在，如果存在就起到主键的作用。<ol>
<li>有主键就用主键</li>
<li>没有主键就选取一个 <code>Unique</code> 键作为主键</li>
<li>都没有就添加一个隐藏键 <code>DB_ROW_ID</code></li>
</ol>
</li>
<li><code>DB_TRX_ID</code>（事务 ID）和 <code>DB_ROLL_PTR</code>（回滚指针）一定存在，意义后面有机会再说</li>
<li>其他字段，如果非 NULL 才存在</li>
</ul>
</li>
</ol>
<hr>
<h1 id="页"><a href="#页" class="headerlink" title="页"></a>页</h1><p>页的大小是固定的，每一页都是 16KB，页是装载行的容器，一页中有很多行（记录）。</p>
<p>页有很多的类型，比如表头页、日志页等，装载数据行的页是索引页（INDEX），我们以下说的内容都是索引页，下表是它的数据结构：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>File  Header</td>
<td>文件头部</td>
<td>38字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page  Header</td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infimum  + Supremum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>User  Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page  Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中的某些记录的相对位置</td>
</tr>
<tr>
<td>File  Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<p><img src="/assets/MySQL%E5%AD%98%E5%82%A8%E8%A1%8C.jpg" alt="MySQL存储行"></p>
<h2 id="File-Header-amp-File-Trailer"><a href="#File-Header-amp-File-Trailer" class="headerlink" title="File Header &amp; File Trailer"></a>File Header &amp; File Trailer</h2><p>所有类型的页，都有这两个部分的数据，也就是一页最上面的 File Header，以及一页最下面的 File Trailer。</p>
<p>File Header 是一页最开头的部分，它记录了页 ID、校验和、LSN 等内容：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4字节</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4字节</td>
<td>页号</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4字节</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8字节</td>
<td>页面被最后修改时对应的日志序列位置（英文名是：Log  Sequence Number）</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8字节</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<p>File Trailer 是一页最后的部分，它由两部分构成（各 4 字节，共 8 字节），前半部分是校验和，与 File Header 中的校验和相同，避免因磁盘加载问题导致数据错误，后半部分是 LSN，具体作用后面再说。</p>
<h2 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page  Header"></a>Page  Header</h2><p>索引页的 Page Header 部分，存储了本页存储了多少条记录、第一条记录的地址是多少等信息，比较复杂。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2字节</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是Free Space</td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2字节</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2字节</td>
<td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2字节</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2字节</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2字节</td>
<td>记录插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2字节</td>
<td>一个方向连续插入的记录数量</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2字节</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8字节</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2字节</td>
<td>当前页在B+树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8字节</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10字节</td>
<td>B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td>10字节</td>
<td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody></table>
<p>不是很重要，过吧。</p>
<h2 id="Infimum-amp-Supremum"><a href="#Infimum-amp-Supremum" class="headerlink" title="Infimum &amp; Supremum"></a>Infimum &amp; Supremum</h2><p>最小记录和最大记录，具体作用需要理解记录的存储逻辑。</p>
<p>上一节画的行格式示意图，没有画出头信息，现在需要画出来这部分了（这是 Compact 行格式的头信息，其他行格式也差不多）。</p>
<p><img src="/assets/Compact%E5%A4%B4%E4%BF%A1%E6%81%AF.jpg" alt="Compact头信息"></p>
<p>我们接下来要学习，多行数据是怎么逻辑相连的，这部分只跟行格式的头信息有关，因此在示意图上省略了其他信息：</p>
<p><img src="/assets/%E7%B4%A2%E5%BC%95%E9%A1%B5%E4%B8%AD%E8%A1%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91.jpg" alt="索引页中行的数据逻辑"></p>
<p>InnoDB 把多行数据做成链表的形式，创建页时会首先创建出链表头和链表尾，每多加一条数据，都会在链表中插入一条数据。（忽略了很多细节，比如一行数据太大怎么办，某一行怎么删掉，数据行太多一页装不下怎么办）</p>
<p>链表头是最小记录，由 5 字节的头信息和 8 字节的“Infimum”组成，链表尾是最大记录，由 5 字节的头信息和 8 字节的“Supremum”组成（当然，存储的都是二进制数据）。</p>
<p>再重新看一遍头信息的格式（Compact 行格式）：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
<h2 id="User-Records-amp-Free-Space"><a href="#User-Records-amp-Free-Space" class="headerlink" title="User Records &amp; Free Space"></a>User Records &amp; Free Space</h2><p>这部分就是每页存储数据的地方。</p>
<p>已经存储数据行的部分，叫做 User Records，还没使用的部分，叫做 Free Space。结合最开始的页示意图，很容易看懂。</p>
<h2 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page  Directory"></a>Page  Directory</h2><p>一页有 16 KB 的大小，可以放很多很多行数据（具体能放多少条，跟每行数据有多少个字段相关）。</p>
<p>链表的搜索效率的 O(n)，如果数据量很大，那么查询速度会非常慢。因此 InnoDB 又提出了 <code>页目录</code>（Page Directory）的概念，将搜索效率提高到 O(logn)。</p>
<p>逻辑是这样的：</p>
<ol>
<li>链表需要按照主键的大小排序（如果没有主键，就使用 <code>Unique</code> 键，再没有就生成一个隐藏键 <code>DB_ROW_ID</code>）</li>
<li>链表每几个节点分一个组，把每组最后的链表节点的地址，记录在 Page Directory 里（相当于记录在一个数组里）</li>
</ol>
<p>这样就能通过二分检索数组，将搜索效率提高到 O(logn) 了。下图是示意图，最左侧就是 Page Directory：</p>
<p><img src="/assets/%E9%A1%B5%E7%9B%AE%E5%BD%95.jpg" alt="页目录"></p>
<p>补充几个细节：</p>
<ol>
<li>头信息中的 <code>n_owned</code> 字段，代表分组后本组有多少行数据，只有每组最后的一个链表节点有这个数据。</li>
<li>每一组最多 8 行数据（最小记录只有自己 1 行，最大记录允许 1-8 行，其他组 4-8 行）。</li>
</ol>
<p>二分法查找主键的过程不写了。</p>
<hr>
<h1 id="表空间-amp-组-amp-区"><a href="#表空间-amp-组-amp-区" class="headerlink" title="表空间 &amp; 组 &amp; 区"></a>表空间 &amp; 组 &amp; 区</h1><p>这部分的概念非常多，但是感觉偏向具体实现，对理解 InnoDB 帮助没有那么大，因此简略写写就过了。</p>
<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>表空间是 InnoDB 中最大的概念，最大可以 64TB（因为页号最大 2^32，单页 16KB，总共最多 64TB）。</p>
<p>有很多种表空间，比如系统表空间、独立表空间、临时表空间等。在如今的 MySQL 版本中，表数据基本都存储在独立表空间当中（为每一个表建立一个独立表空间）。</p>
<h2 id="组"><a href="#组" class="headerlink" title="组"></a>组</h2><p>表空间由组构成，每个组 256MB（2^14 页）。</p>
<p>表空间的第一个组，头三个页是固定的，其他组的头两个页是固定的。</p>
<p>第一个组的前三个页面分别是 <code>FSP_HDR</code> 页、<code>IBUF_BITMAP</code> 页，<code>INODE</code> 页：</p>
<ul>
<li><code>FSP_HDR</code> 页：这是整个表空间的第一个页，记录了整个表空间的信息，以及本组的区信息（区的概念下面说）</li>
<li><code>IBUF_BITMAP</code> 页：本组关于 <code>INSERT BUFFER</code> 的信息（这个后面的文章说）</li>
<li><code>INODE</code> 页：本组的段信息（段的概念下面说）</li>
</ul>
<p>其他组的前两个页面分别是 <code>XDES</code> 页、<code>IBUF_BITMAP</code> 页：</p>
<ul>
<li><code>XDES</code> 页：本组的区信息</li>
<li><code>IBUF_BITMAP</code> 页：本组关于 <code>INSERT BUFFER</code> 的信息</li>
</ul>
<p>我感觉这些都不是很重要，只需要知道每个组会把一些统计信息单独抽出几个页出来，放在最前面。</p>
<h2 id="区"><a href="#区" class="headerlink" title="区"></a>区</h2><p>由于组还是太大了，管理页不方便，因此还有区（extent）的概念，一个区 1MB（64 页）。</p>
<p>引入区的概念，主要还是增加读写速度。InnoDB 的数据是以链表的形式存储的，链表可以东存一块，西存一块。但是对于存储系统来说，随机读写的速度要远低于顺序读写，如果内存是连续的，读写速度会大幅提升。因此如果把数据存到连续的磁盘区域，能提高很多速度。</p>
<p>因此 InnoDB 一次申请一个区的磁盘空间（1 MB，64 个页），浪费一点空间，但是消除很多随机读写，提高性能。但是如果数据量很小，直接申请一个区的空间显得很浪费，因此有碎片区的概念，不同的表都可以使用同一个碎片区，新插入数据先使用碎片区的页，超过 32 页之后再单独创建区。</p>
<h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>上面所说的都是物理空间，有固定的大小，段（Segment）是逻辑上的空间，没有固定大小。段由一些零散的页面以及一些固定的区构成。</p>
<p>接下来要说的内容是下一篇文章的主题，就是 InnoDB 是怎么存储索引的。每个索引在 InnoDB 中都是一棵 B+ 树，按照索引值的大小排序，因此可以达到 O(logn) 的查询效率。这棵二叉树的叶子节点（最下面一层）和非叶子节点，数据结构是不相同的，查询逻辑也是不相同的，因此把这两部分存储在不同的区域。</p>
<p>存放叶子节点的存储区域，被称为一个段，存放非叶子节点的存储区域，被称为另一个段。也就是说每个索引在存储时，默认会出现两个段，这两个段使用不同的存储区域。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 数据结构</title>
    <url>/2020/11/15/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<br>

<p>十一月的第三周，入门 Redis，从数据结构开始。</p>
<hr>
<p>Redis 是一个基于内存的高性能 key-value 数据库。</p>
<p>Redis 有五种数据结构（准确说应该是数据结构类），分别是 <code>String</code>（字符串）、<code>List</code>（列表）、<code>Hash</code>（哈希表）、<code>Set</code>（集合）、<code>ZSet</code>（有序集合）。这五种对象在 Java 中都有（ZSet 就是 SortedSet），很容易理解。</p>
<p>Redis 是 key-value 型数据库，所谓有五种数据结构，意思是 value 有五种，但 key 始终都是字符串。一个单数据库的 Redis 可以视为一张大的 HashMap，这个 HashMap 的 key 始终都是一个字符串，而 value 可以是 <code>String</code>、<code>List</code>、<code>Hash</code>、<code>Set</code>、<code>ZSet</code>。</p>
<p>对于 Redis 的使用者而言，只会看到五种数据结构，但是 Redis 内部其实还有编码和内部数据结构，比如说 Redis 在存储 <code>&quot;hello world&quot;</code> 和 <code>&quot;helloooooooooooooooooooooooooooooo world&quot;</code> 这两个字符串时，底层的实现是不一样的。Redis 内部有六种数据结构，通过不同的组合方式，对外暴露了五种封装过的数据结构，组合方式如下图所示：</p>
<p><img src="/assets/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="Redis数据结构"></p>
<p>我们分两部分来看，首先看底层的数据结构，然后看封装过的对象。</p>
<hr>
<p>Redis 的底层一共有六种数据结构，除了跳表之外的五种数据结构都很容易理解，Redis 是用 C 写的，因此本来也就写不出什么复杂的东西hhh，下面一个个看吧。</p>
<p>下面的所有内容和图片，基本都来源自《<a href="http://redisbook.com/" target="_blank" rel="noopener">Redis 设计与实现</a>》一书，该书基于 Redis 3.0 编写，好多好多好多内容都已经变了，看个大概吧。</p>
<h1 id="SDS-字符串"><a href="#SDS-字符串" class="headerlink" title="SDS 字符串"></a>SDS 字符串</h1><p>SDS 字符串即<code>简单动态字符串</code>（simple dynamic string, SDS），是一种类似 ArrayList 的数据结构。</p>
<p>SDS 在 Redis 中定义为 sdshdr 类，它有几个内部属性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/SDS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="SDS数据结构"></p>
<p>以上图为例，存储了一个 “Redis” 字符串，len = 5（使用了 5 字节，不算入 ‘\0’ 字符），free = 5（还有 5 字节可用），buf 是一个字符数组。</p>
<p>SDS 字符串长度不足时会进行扩容</p>
<ul>
<li>如果扩容后的 len 小于 1 MB，扩容后预留多一倍的长度（len == free）</li>
<li>如果扩容后的 len 大于等于 1 MB，扩容后将多预留 1 MB 的长度（free == 1MB）</li>
</ul>
<p>SDS 字符串缩短时，不会立即处理，未来有需要时再释放内存。</p>
<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p>跟 LinkedList 的核心设计差不多，没什么可说的，贴一下代码和图片，过了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.jpg" alt="双向链表数据结构"></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典就是 Map，Redis 的实现跟 HashMap 相同。</p>
<p>哈希算法采用 MurmurHash2 算法，处理哈希冲突的方式是拉链法，数据结构跟 HashMap 别无二致，代码和图都不贴了。</p>
<p>扩容要单独说一下。</p>
<p>Redis 的字典扩容时，会创建一个新的数组，新数据插到新数组里，老数据逐步迁过来，当老数组搬空了之后，新数组替代老数组，扩容结束。具体有下面这几个细节：</p>
<ul>
<li><p>扩容后的大小，是大于等于原键值对数量两倍的 2^n，比如原数组的键值对有 100 个，那么扩容后数组的长度是 100 * 2 = 200 -&gt; 256。</p>
</li>
<li><p>扩容不是一次性完成的，而是一点点完成的。</p>
<p>每次进行查询、新增、更新、删除操作时，会把老数组在下标 <code>rehashidx</code> 上的所有键值对，都拷贝到新数组上。<code>rehashidx</code> 从 0 开始，每查询、新增、更新、删除一次，拷贝一次，数值增加 1，直到遍历完老数组的数组长度。</p>
</li>
<li><p>扩容过程中的查询、更新、删除会在两个数组上执行，新增只在新数组上执行。</p>
</li>
<li><p>扩容的条件：</p>
<ul>
<li>服务器没有执行 BGSAVE 或 BGREWRITEAOP 命令时，负载因子 &gt;= 1</li>
<li>服务器没有执行 BGSAVE 或 BGREWRITEAOP 命令时，负载因子 &gt;= 5</li>
</ul>
</li>
</ul>
<p>Redis 的字典也会收缩，在负载因子 &lt; 0.1 时执行收缩，大小是原键值对数量的 2^n，其他跟扩容一样。</p>
<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>跳表是我第一次见的数据结构，查了一下可以近似等效为红黑树，查询、插入、删除的效率都是 O(log n) 。这种数据结构的优势是实现起来简单。</p>
<p>跳表的数据结构大致长这样（下图来源自《<a href="https://lotabout.me/2018/skip-list/" target="_blank" rel="noopener">跳表──没听过但很犀利的数据结构</a>》)：</p>
<p><img src="/assets/%E8%B7%B3%E8%A1%A8.jpg" alt="跳表"></p>
<p>这种数据结构看得我挺头疼的，查了一下只应用在 Redis 和几个我没听说过的工具上使用，暂且放过了。</p>
<p>Redis 使用跳表而不使用红黑树的原因，一是实现简单，二是可以实现区间查询（比如在 [100, 200] 中查询数据，而红黑树实现起来很麻烦），更多的原因可以参考《<a href="https://www.zhihu.com/question/20202931" target="_blank" rel="noopener">为啥 redis 使用跳表(skiplist)而不是使用 red-black？</a>》。</p>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合可以视为一个排序后的 int 数组，长度固定。所以如果要新增或删除元素，就要有 O(n) 的时间复杂度（查询可以用二分查找，时间复杂度 O(log n)）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><img src="/assets/Redis%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84.jpg" alt="Redis整数数组"></p>
<p>整数集合只使用在元素数量较少时（小于 512 个）时的 SET 对象中，因为插入和删除的时间代价有点大，但是很省空间。</p>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表为了省内存而生，底层数据结构就是一块连续的内存空间，插入或删除的时间代价很大，但很省内存。</p>
<p><img src="/assets/Redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg" alt="Redis压缩列表"></p>
<p>压缩列表的每个节点，可以存储一个数字，或者一个字节数组，具体存储的内容由 <code>encoding</code> 字段决定。</p>
<p>压缩列表可以实现正序遍历和倒序遍历，查询效率是 O(n)，新增和删除效率平均 O(n)，最差 O(n^2)（但是很难最差），总之效率是很差，但是很省空间，对于 Redis 这种内存型数据库，空间还是能省一点是一点。</p>
<hr>
<p>看完六种底层数据结构，可以学习对外暴露的五种数据结构了。</p>
<p>Redis 的数据结构对象，有编码（encoding）的概念，同一种数据结构，在不同的情况下，可以有不同的编码，以应对不同的场景。通常数据量小时会选择省内存的编码，数据量大时会选择省时间的编码。</p>
<h1 id="STRING-字符串"><a href="#STRING-字符串" class="headerlink" title="STRING 字符串"></a>STRING 字符串</h1><p>Redis 的字符串对象，跟通常意义上的字符串不太一样，数字在 Redis 也是一个字符串对象。</p>
<p>Redis 的字符串对象有三种（对应三种编码），分别是：</p>
<ul>
<li>数字字符串（编码：int）</li>
<li>短字符串（编码：embstr）</li>
<li>长字符串（编码：raw）</li>
</ul>
<p>int 类编码把数字直接存储在对象中，而 embstr 和 raw 编码都使用 SDS 作为底层的数据结构，不同的是 embstr 字符串比较短，申请 SDS 的空间时和字符串自己的空间一起申请，而 raw 字符串比较长，单独申请 SDS 的空间，再用指针指过去。</p>
<p>raw 和 embstr 的编码区别如下图所示：</p>
<p><img src="/assets/embstr%E5%92%8Craw.jpg" alt="embstr和raw"></p>
<p>当字符串长度小于 39 字节时（由于 SDS 字符串数据结构的改进，现在提升到 44 字节了），会使用 embstr 编码，当字符串长度大于 39 字节时，会使用 raw 编码。</p>
<p>39 字节的来源是这样的，字符串对象本身占 16 字节，SDS 对象 free 和 len 属性各占 4 字节，字符串以 ‘\0’ 字符结尾还要再占 1 字节，加起来一算，16 + 4 + 4 + 1 + 39 = 64，刚好是 CPU 在 64 位机器上一次寻址的字节长度。（如今 free 和 len 可以只占 3 字节，因此多省出来 5 个字节，变成以 44 字节为界，具体可参考《<a href="https://blog.csdn.net/XiyouLinux_Kangyijie/article/details/78045385" target="_blank" rel="noopener">Redis 的 embstr 与 raw 编码方式不再以 39 字节为界了！</a>》）</p>
<p>总结一下：</p>
<ul>
<li>如果存储 long 类型的整数，使用 int 编码</li>
<li>如果存储 39 字节及以内的字符串，使用 embstr 编码，底层是 SDS</li>
<li>如果存储 39 字节以上的字符串，使用 raw 编码，底层是 SDS（如果 embstr 编码的字符串发生改变，即使长度不到 39 字节，也会转为 raw 编码）</li>
</ul>
<h1 id="LIST-列表"><a href="#LIST-列表" class="headerlink" title="LIST 列表"></a>LIST 列表</h1><p>列表对象有两种编码，分别是 ziplist 编码（压缩列表）和 linkedlist 编码（双向链表）。</p>
<p>当列表的长度小于 512，且每个元素的长度小于 64 字节时，使用 ziplist 编码，否则使用 linkedlist 编码。</p>
<h1 id="HASH-哈希"><a href="#HASH-哈希" class="headerlink" title="HASH 哈希"></a>HASH 哈希</h1><p>哈希对象有两种编码，分别是 ziplist 编码（压缩列表）和 hashtable 编码（哈希表）。</p>
<p>使用压缩列表的话，会把 key 和 value 作为两个节点，加入到压缩列表的内部。</p>
<p><img src="/assets/%E5%93%88%E5%B8%8C%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg" alt="哈希压缩列表"></p>
<p>当哈希对象的 key-value 对少于 512 个，且 key 和 value 的长度都小于 64 字节时，使用 ziplist 编码，否则使用 linkedlist 编码。</p>
<h1 id="SET-集合"><a href="#SET-集合" class="headerlink" title="SET 集合"></a>SET 集合</h1><p>集合对象有两种编码，分别是 intset （整数集合）编码和 hashtable 编码（哈希表）。</p>
<p>当集合对象的每个元素都是整数，且个数少于 512 个时，使用 intset 编码，否则使用 hashtable 编码。</p>
<h1 id="ZSET-有序集合"><a href="#ZSET-有序集合" class="headerlink" title="ZSET 有序集合"></a>ZSET 有序集合</h1><p>有序集合有点像 SortedSet，意思是可以给每个元素设定权重，内部按照权重顺序存储，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br></pre></td></tr></table></figure>

<p>有序集合对象有两种编码，分别是 ziplist 编码（压缩列表）和 skiplist 编码（跳表+哈希表）。</p>
<p>使用 ziplist（压缩列表）的话，会把元素和权重值作为两个节点，加入到压缩列表的内部。</p>
<p><img src="/assets/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8.jpg" alt="有序集合压缩列表"></p>
<p>使用 skiplist 的话，底层会同时使用跳表和哈希表这两种数据结构，ZRANK、ZRANGE 这类范围型操作使用跳表（可以保证顺序），根据元素查找权重这类操作使用哈希表（可以保证 O(1) 的时间复杂度）。</p>
<p>当有序集合对象的元素数量小于 128 个，且每个元素的长度小于 64 字节时，使用 ziplist 编码，否则使用 skiplist 编码。</p>
<br>

<p>这周就先看这么点。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN 与 Git</title>
    <url>/2019/11/20/SVN-%E4%B8%8E-Git/</url>
    <content><![CDATA[<br>

<p>十一月的第二周，来学习版本控制系统。</p>
<p>整顿一下，最近写博文总是拖到下一周的周一或者周二才完成，这周一定要努力在周日结束之前发文。</p>
<hr>
<p>版本控制系统是一个初听有点唬人的名字，版本、控制、系统，这三个词都是带几分黑金属性的气质词汇，合在一起颇有架势。它代表的是这样一个概念：我希望有一个文件库，里面不光存放了所有文件，还保留了每一次的修改信息，如果我想查看某个文件三天前是什么样子的，我仍能看到。</p>
<p>当下常见的版本控制系统就两种，一种是 SVN，另一种是 Git。这两种系统从架构上，到功能实现上，再到价值观上，都是不一样的。总体来说，Git 处于鄙视链的上游地位，代表着信仰，SVN 处于备受唾弃可又怎么都淘汰不了的状态中，充满着妥协。（言重了，言重了）</p>
<hr>
<h1 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h1><p>我目前工作中使用的是 SVN，实际上我到写博文之前，都是没有使用过 Git 的。所以只能说基本整理一下 SVN 的使用逻辑与方法，但对于 Git 就是浅尝辄止了。</p>
<p>SVN（Subversion），是阿帕奇（Apache）家出的版本控制系统，这家公司（或者应该叫基金会吧）从 HTTP 起家，贡献了 Maven、Kafka、Tomcat 等一堆开源软件或框架，实乃业界良心大佬。SVN 本是为了取代 CVS（一种上古的版本控制系统）而推出的，应当视作一种特定的软件/框架。但是目前看来，SVN 实在是太过成功，以至于成为了一种标杆的存在，代表着中心式的版本控制系统。</p>
<br>

<p>中心式的意思是，文件集中起来，由一台服务器进行管理，进行版本控制。如果一个团队有 10 个人，这 10 个人如果想提交代码，或是更新代码，则必须和中心服务器连接起来，提交则上传上去，更新则下载下来。除此之外，我认为中心式还有两层表现：</p>
<ol>
<li>中心只维护一套文件，换句话说，使用 SVN 控制的文件，只会有一种表现结果。如果 A 和 B 一起写东西，A 说豆腐脑要吃甜的，B 说豆腐脑要吃咸的，那么上传到中心服务器中的文件，豆腐脑要不然吃甜的，要不然吃咸的，不可以共存。而且，由于只有一套文件，如果文件的内容发生冲突了，提交时必须要自己合并代码，要不然你早点传文件占得先机，要不然就后传文件做冲突处理。</li>
<li>版本的最终解释权和维护权，在中心。如果你和中心断开了连接，最直接的，你将无法提交代码，也无法更新代码；其次，你没有办法查看某个特定版本的文件，因为所有版本是什么样子的，只有中心才知道，如果觉得自己的代码写得有问题想回滚，那么请先连接中心。</li>
</ol>
<p>我们在讨论 SVN 和 Git 之间的区别时，大多数情况下，是在讨论<code>中心式管理</code>和<code>分布式管理</code>之间的区别。SVN 没有本地库，无法断网开发，几乎不搞分支等等，这些背后基本都是因为它中心式的架构。</p>
<br>

<p>SVN 的使用，说实话没什么好写的，因为日常操作实在是太过简单。</p>
<p>平常能够使用 SVN 的地方有两处，一处是 IDE，写代码的时候用到，另一处是 SVN 的客户端 TortoiseSVN（小乌龟），不写代码的时候用到。</p>
<p>使用 SVN，最稀疏平常的两个操作是<code>提交代码</code>和<code>下载（更新）代码</code>，提交代码是 commit，更新代码是 update，这两个操作都可以在 IDE 中通过点击鼠标完成（其他操作基本也都可以通过点鼠标完成）。</p>
<p>除了这两项天天都会用到的操作之外，还有<code>检出代码</code>（checkout），即把最新的代码拷贝出来一份，<code>回滚代码</code>（revert），即把代码还原到上一次的提交状态。<code>对比代码</code>（compare with…），即对比自己写的代码和某个版本的代码，<code>显示版本历史</code>（show history），即查看每次的提交记录，以及最最最让人厌烦的<code>代码合并</code>（merge），这并不是一个 SVN 的功能，而是每次提交/更新代码时，如果你的代码和中心代码同时修改了某一处地方，造成了冲突，你需要手动合并。</p>
<p>SVN 的客户端小乌龟，是在不需要写代码的时候使用到的，例如拷贝出来一份代码，修改配置文件的一点参数等等。</p>
<p>实在话，SVN 的使用凭直觉去使用就可以了。</p>
<br>

<p>最后我们记录一点 SVN 使用背后的事情。</p>
<p>SVN 是基于文件的来进行版本控制与管理的，如果有三个文件进行改动，就把这三个文件的变化内容记录下来，其他文件不变，并为此赋予一个版本号。<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E5%9F%BA%E7%A1%80" target="_blank" rel="noopener">下图</a>是 Git 文档对于 SVN 文件版本的演变示意图。</p>
<p><img src="/assets/SVN%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC.jpg" alt="SVN文件版本"></p>
<p>我认为，浅尝辄止地认识 SVN 存储原理，需要认识到两个方面：</p>
<ol>
<li>SVN 的存储是基于文件的，而且它存储的是文件差异。如果文件内容有变化，记录下来，如果文件内容没有变化，无视。</li>
<li>SVN 的版本号是全局的，它描述的是所有文件。所有人都可以向中心指定一个版本号，来获取一整套完整的文件。</li>
</ol>
<hr>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>惭愧地讲，我至今都没有在 IDE 中使用过 Git，本来想借着这篇博文开始使用，但是用的梯子太不稳定，我连不上高墙之外的 github。</p>
<br>

<p>Git 是 Linux 社区搞出来的东西，因为原先用的版本控制工具不让用了，Linux 内核组的大佬花了俩周捣鼓出来一个分布式版本控制系统，也就是 Git，这可真是大佬的任性与倔强……</p>
<p>Git 是分布式版本控制系统的代表，分布式换个表述就是“去中心化”，这是 Git 的核心。稍一思索就会明白，Git 是一个典型的脱胎自 Linux 的产品，Linux 的开发人员是全球的草莽程序员，代码组起来讲究一个英雄不问出处，你指望一个中心式的版本控制系统是不可能的，Git 的出现就是为了实现分布式版本控制系统，分布式是刻在 Git 骨子里的。</p>
<p>Git 为了实现分布式，在设计上就与 SVN 完全不同，主要体现在这些地方上：</p>
<ol>
<li><p>Git 同样有中心服务器（远程仓库），但是还有本地仓库。在 SVN 中你只能从中心拉取代码，但是在 Git 中你可以向另一个人的本地仓库处拉取代码。</p>
<p>事实上，Git 在文件存储位置上的设计远非如此，它设计了四个区域：工作区、暂存区、本地仓库、远程仓库，写代码时你在工作区内写，写完之后保存在暂存区中，当你觉得应该提交代码了，就可以向本地仓库和远程仓库提交代码。</p>
<p>这种设计造成了两点不同：第一，你可以在暂存区中“攒够”了代码之后再提交，暂存区中的代码可以有好几种版本，你选取一种最好的提交；第二，版本信息不再只保存在中心服务器中，每个人本地也有版本信息，你可以在脱网的情况下查看版本信息（例如对比代码、回滚代码）。</p>
</li>
<li><p>Git 可以随随便便开分支。分支是相对于主线的概念，在 SVN 中大家共用的那套文件一般情况下只会有一条主线，荣也同荣，损也同损，但在 Git 中你可以随便开一个分支，在主线之外处理自己的事情。例如开一个分支实现自己的某个想法，成立则合并进主线，不成立则扔掉这个分支。分支这个概念，使个人能够随便试错，也使团队可以包容多元。</p>
<p>但是在我查资料的时候，发现很多大佬在讨论 merge 和 rebase 命令之间的选择问题，实际上是在讨论如何让共用版本的分支变少，让版本主线变得“清爽”。这个我大概要用到才能真的体会到，在此只是记录下来。</p>
</li>
</ol>
<br>

<p>Git 存储文件的原理，我至今不是很理解，这里记录一下我整理的材料以及认知程度。</p>
<p>每一次提交代码时，Git 将生成一个全部文件的<code>快照</code>。这跟 SVN 的处理方式是完全不同的，SVN 通过记录文件的差异来存储最新的版本内容：我有 A 文件，我有一个文件记录新旧文件的差异，我就可以通过计算得出最新的 A1 文件。你应该注意到，SVN 存储是基于文件的，三个文件改动了就记录下三个差异文件，五个改动就记录五个。但是 Git 每次都是同时记录所有文件，以<code>快照</code>的原理来实现。</p>
<p>我花了好几天，仍不理解快照是什么，我只知道快照不是什么。首先，快照不是文件差异，快照记录下的不光是差异，而是全部信息，有篇博文解释了这件事情：<a href="https://www.optbbs.com/thread-3985923-1-1.html" target="_blank" rel="noopener">《Git 快照与 SVN 文件差异区别》</a>，但是我对它的正确性存疑（因为没有其他相同观点的文章佐证）。其次，快照不是备份，备份相当于把文件拷贝一份保存在另外一个地方，可以独立存在，而快照需要基于原文件才能读取。</p>
<p>使用快照的好处一在快，二在保存全部文件信息。似乎这是一种用空间换时间的技术方法，但我实在是知之甚少，不敢断言。</p>
<br>

<p>记录下两个学习 Git 的公认必备网站，<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">《廖雪峰 Git 教程》</a>、<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">《Pro Git 电子版》</a>。总体感觉上，前者论术，后者论道。论术的那个，语言轻浮且不是我喜欢的那类轻浮，论道的那个，翻译腔重（或者说原文就不适合用中文理解），两个都不是我很喜欢的类型。在此记录一下，日后还是要勤读。</p>
<hr>
<p>就不该开篇立 flag，说什么周日前发文，这篇拖更两周才写完……</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Webflux 入门</title>
    <url>/2020/06/30/Spring-Webflux/</url>
    <content><![CDATA[<br>

<p>真是混沌的一个月呀，不管第几周啦，就当做六月的最后一个周吧。</p>
<p>这个周入门 Spring Webflux，归纳学习响应式编程，但只从两个最常用的两个类：Mono 和 Flux 入手，关注一下基本使用。</p>
<hr>
<p>响应式编程（Reactive programming）是一种不好形容的编程模式，常见的描述语或定义语中会出现：异步、非阻塞、传递变化、支持背压。我觉得自己的理解还不到位，决定本篇不定义或是阐述响应式编程是什么，只入个门，之后回来补这部分功课。</p>
<p>抛开定义，仅从代码的形式上来看，响应式编程跟 JDK 8 中常见的 stream 流，在使用上很接近，例如下面这段响应式代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Mono.just(jsonParam)</span><br><span class="line">        .map(param -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"随便打印点东西：&#123;&#125;"</span>, param);</span><br><span class="line">            <span class="keyword">return</span> param.get(<span class="string">"user"</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .onErrorResume(Mono::error)</span><br><span class="line">        .subscribe();</span><br></pre></td></tr></table></figure>

<br>

<p>我在工作中使用的响应式编程框架是 Spring Webflux，它基于 Reactor 3 实现（由 Spring 母公司 Pivotal 的某团队开发），论辈分可能是第四代，或者是第五代。</p>
<p>响应式编程的历史渊源有点复杂，简单来说，最早是微软一帮人在 2010 年写出了 Rx.NET，运行在 .NET 平台上，后来在各个平台上都做了类似的实现，例如 RxJs、RxJava等（Rx 是 ReactiveX 的缩写），其中 RxJava 就是在 Java 平台上的实现。后来出现了 Project Reactor、Akka-Streams 之类的响应式框架。在 2013 年末，Netflix、Pivotal、Typesafe 等公司开始牵头制定响应式流规范，并在 2015 年正式发布了 Reactive Streams 规范，这个规范直接表现在 JDK 9 JUC 包中的 Flow API。如今的响应式框架基本都实现了 Reactive Streams 规范，业界主流的是 RxJava 2 和 Reactor 3。</p>
<p>响应式编程的历史还可以参考这篇文章《<a href="http://akarnokd.blogspot.com/2016/03/operator-fusion-part-1.html" target="_blank" rel="noopener">Advanced Reactive Java</a>》（偶然搜到的，不知是何方神圣）。</p>
<p>本篇学习的内容是 Reactor 中的 Mono 和 Flux 两个类的使用，我也懒得介绍这两个类了，下面的内容会很干。</p>
<hr>
<h1 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>just</td>
<td>Mono.just(user)…</td>
<td>把元素加入流中</td>
<td>元素不能是null，否则抛空指针</td>
</tr>
<tr>
<td>justOrEmpty</td>
<td>Mono.justOrEmpty(user)…</td>
<td>把元素（可能为null）加入到流中</td>
<td>元素如果是null，返回Mono.empty()</td>
</tr>
<tr>
<td></td>
<td>Mono.justOrEmpty(optional)…</td>
<td>把元素（Optional对象）加入到流中</td>
<td>元素如果是空，返回Mono.empty()</td>
</tr>
<tr>
<td>defer</td>
<td>Mono.defer(() -&gt; Mono.error(new RuntimeException(“懒异常”)))…</td>
<td>把Mono元素加入流中，但是延时加载，直到有subscribe时才会加载元素</td>
<td>可以理解为懒加载，当subscribe时才加载元素（每次subscribe都会重新加载）。<p>例如有一个用法是，当需要定义异常Mono.error()，并不需要每次都创建，而是在出现异常时才加载，可以节省内存</p></td>
</tr>
<tr>
<td>deferWithContext</td>
<td>Mono.deferWithContext(context -&gt; Mono.just(“test”)))…</td>
<td>与defer()方法几乎完全相同，只是接受参数变成了Function，可以拿到流的context</td>
<td>context来自reactor.util.context包，代表流的上下文，用法不明，待后续</td>
</tr>
<tr>
<td>fromCallable</td>
<td>return Mono.fromCallable(() -&gt; {     Thread.sleep(1000 * 3);     return “休眠了三秒”; })…</td>
<td>通过Callable获取元素加入到流中，是支持阻塞的一种实现</td>
<td>有很多类似的fromXXX()方法，例如fromFuture()、fromRunnable()等</td>
</tr>
<tr>
<td>empty</td>
<td>Mono.empty()…</td>
<td>创建流，但流中没有任何元素</td>
<td>后续如果有flatmap()、map()等，都不会执行，但then()等可以执行，可以用于忽略后续数据</td>
</tr>
<tr>
<td>never</td>
<td>Mono.never();</td>
<td>永不停止，不搭理任何数据，就此睡死</td>
<td></td>
</tr>
<tr>
<td>error</td>
<td>Mono.error(new RuntimeException(“失败”))…</td>
<td>将一个异常加入流中，并立即停止后续操作</td>
<td>参数是Throwable对象，error立即加载，无论是否用到</td>
</tr>
<tr>
<td></td>
<td>Mono.error(() -&gt; new RuntimeException(“失败”))</td>
<td>将一个异常加入流中，并立即停止后续操作</td>
<td>参数是Supplier函数，error懒加载</td>
</tr>
<tr>
<td></td>
<td>Mono.delay(Duration.ofSeconds(3))…</td>
<td>上来就延时</td>
<td>延时后返回0</td>
</tr>
</tbody></table>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>flatMap</td>
<td>…flatMap(t -&gt; {<br>     return Mono.just(t); })…</td>
<td>将一个Mono转换成另一个Mono（异步）</td>
<td>参数是一个Function（接收Mono中的值，返回一个新的Mono）</td>
</tr>
<tr>
<td>map</td>
<td>…map(t -&gt; {<br>     return t; })…</td>
<td>将Mono中的内容进行更改</td>
<td>参数是一个Function（接收Mono中的值，返回另一个值）</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cast</td>
<td>Mono.just(map)         .cast(HashMap.class)…</td>
<td>将Mono中的对象，从A类转换成B类</td>
<td>等价于map(clazz::cast)</td>
</tr>
<tr>
<td>sequenceEqual</td>
<td>Mono.sequenceEqual(monoA, monoB)…</td>
<td>比较两个Publisher（Mono、Flux）是否相同</td>
<td>返回的是一个<code>Mono&lt;Boolean&gt;</code></td>
</tr>
<tr>
<td></td>
<td>Mono.sequenceEqual(monoA, monoB, (a, b) -&gt; a.length() == b.length())…</td>
<td>比较两个Publisher（Mono、Flux）是否相同（可以指定条件）</td>
<td></td>
</tr>
<tr>
<td>zip</td>
<td>Mono.zip(mono1, mono2, mono3)…</td>
<td>将多个Mono合并成一个Mono（内部是Tuple对象），可以通过tuple.getT1()等类似方式取出一个个内容</td>
<td>如果其中一个Mono发生异常，逻辑同抛出Mono.error()，如果有多个Mono发生异常，将按顺序取第一个异常</td>
</tr>
<tr>
<td>zipDelayError</td>
<td>Mono.zipDelayError(mono1, mono2, mono3)…</td>
<td>功能上同zip()，但在处理异常的时候逻辑不同</td>
<td>如果多个Mono发生异常，将组合成一个新的异常</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>retry</td>
<td>Mono.just(10/0).retry(10)…</td>
<td>遇到异常重试</td>
<td>从头执行，而不是只执行上一步<br>有很多变种，参数总体与异常类型和重试次数有关</td>
</tr>
<tr>
<td>repeat</td>
<td>Mono.just(“.”).repeat(10)…</td>
<td>重复（在非异常情况下），会从Mono变成重复元素的Flux</td>
<td>有很多变种，并且跟retry一样，都不算最开始的一次</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><p>跟 Mono 相同的就不写了，下面的内容全都是 Flux 独有的</p>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>fromIterable</td>
<td>Flux.fromIterable(list)…</td>
<td>从一个迭代器对象（实现Iterable接口的对象）中，把所有元素加入Flux中</td>
<td>类似的还有fromArray、fromStream</td>
</tr>
<tr>
<td>range</td>
<td>Flux.range(20, 5)…</td>
<td>把一系列数字加入Flux中，这些数字间距为1</td>
<td>例如示例中加入Flux中的数字是20、21、22、23、24，从20开始，一共5个</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="转换-1"><a href="#转换-1" class="headerlink" title="转换"></a>转换</h2><table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>index</td>
<td>Flux.fromIterable(list).index()…</td>
<td>给Flux内的多个元素加下标</td>
<td>例如从[“a”,”b”,”c”]变成[{0:”a”},{1:”b”},{2:”c”}]，转换后每个<strong>T</strong>变成一个二元元祖Tuple2&lt;Long, <strong>T</strong>&gt;</td>
</tr>
<tr>
<td>startWith</td>
<td>.startWith(list)…</td>
<td>将某些内容塞到Flux的最前面</td>
<td>比如原Flux里有[1,2,3]，新插入[8,9]，然后Flux变成[8,9,1,2,3]</td>
</tr>
<tr>
<td></td>
<td>.startWith(mono)…</td>
<td></td>
<td>同上，接收一个Publisher对象</td>
</tr>
<tr>
<td></td>
<td>.startWith(t1, t2, t3)…</td>
<td></td>
<td>同上，接收若干个和Flux中其他元素相同的对象</td>
</tr>
<tr>
<td>concatWith</td>
<td>.concatWith(mono)…</td>
<td>将某些内容塞到Flux的最后面</td>
<td>与startWith的左右相反，但只接收Publisher对象</td>
</tr>
<tr>
<td>take</td>
<td>Flux.fromIterable(list).take(10)…</td>
<td>只取前面几个元素，后面的舍弃</td>
<td>有很多种变种，例如前N个、某段时间之前、某条件没改变之前等</td>
</tr>
<tr>
<td>collect</td>
<td>Flux.fromIterable(list).collect(Collectors.toList())…</td>
<td>把Flux中的多个元素封装成一个Mono集合</td>
<td>使用起来跟JDK 8的Stream一个逻辑，例如<br>list.stream().filter(num -&gt; num &gt; 10).collect(Collectors.toList());</td>
</tr>
<tr>
<td>collectList</td>
<td>Flux.fromIterable(list).collectList()…</td>
<td>把Flux中的多个元素封装成一个Mono列表</td>
<td>例如从<code>Flux&lt;String&gt;</code>转变成<code>Mono&lt;List&lt;String&gt;&gt;</code>，还有很多类似的collect()方法</td>
</tr>
<tr>
<td>window</td>
<td>Flux.just(1,2,3,4,5,6,7,8,9).window(3)…</td>
<td>把一个Flux拆成多个Flux，拆后的Flux的元素个数是window内的个数</td>
<td>例如左边示例代码，会把[1,2,3,4,5,6,7,8,9]转换成[1,2,3]、[4,5,6]、[7,8,9]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>我发现 Mono 和 Flux 的 Api 实在是太多太多了……我都已经整理三周了，还是没有整理完，不能再拖下去了hhh</p>
<p>本篇文章先写到这里，之后用到哪个新的 Api 就回来接着补充。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal</title>
    <url>/2020/07/04/ThreadLocal/</url>
    <content><![CDATA[<br>

<p>七月的第一周，来学习 ThreadLocal。</p>
<p>半年前我完全看不懂这个类，现在已经能看懂了。这几天刚开始看源码时，觉得这是个很精巧的小设计，后来又找资料，发现里面的知识很深，没我想的那么简单。</p>
<p>我在学习 ThreadLocal 时，看到两个很好视频，安利一下。一个是《<a href="https://www.bilibili.com/video/av82079309" target="_blank" rel="noopener">【java】什么是<em>ThreadLocal</em>？</a>》（短小紧凑，科普向，但是结尾有关弱引用的结论是错的，瑕不掩瑜，记得看评论区），另一个是《<a href="https://www.bilibili.com/video/av327891068" target="_blank" rel="noopener">只有马士兵老师能把ThreadLocal底层原理、内存泄漏分析的这么测透</a>》（马士兵老师讲的，比较长，但是非常出色，看得我很 high）。</p>
<hr>
<p>ThreadLocal 类与<code>线程局部存储</code>（Thread Local Storage, TLS）的概念有关，意思是说对象是线程独有的：</p>
<blockquote>
<p>维基：对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。</p>
</blockquote>
<p>可以把 ThreadLocal 视为一个普通变量，他与普通的变量之间的区别在于，ThreadLocal 变量只属于某个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String word1;</span><br><span class="line">ThreadLocal&lt;String&gt; word2 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">word1 = <span class="string">"pz"</span>;</span><br><span class="line">word2.set(<span class="string">"pz"</span>);</span><br></pre></td></tr></table></figure>

<p>例如上面的代码，声明了两个变量 word1 和 word2。这两个变量在使用时都是字符串，也都声明成是”pz”，但是前者 word1 在任何情况下都能获得，后者只有为它赋值的线程能获得，其他的线程都不能获得：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于刚才赋值的线程而言，s是"pz"，对于其他线程，s是null</span></span><br><span class="line">String s = word2.get();</span><br></pre></td></tr></table></figure>

<p>线程局部存储，可以让某些信息在同一个线程中，实现上下文数据共享，比如一个线程先后执行多个方法，每个方法都需要 User 信息，那么可以定义一个 <code>ThreadLocal&lt;User&gt;</code>，每个线程都能获取到各自的 User。</p>
<p>再举一个应对面试的 Spring 应用实例，在事务管理时（@Transactional），Spring 会把数据库连接或者 hibernate session 存储在 ThreadLocal 中，这样就可以在各个方法查询各张表时实现事务控制。</p>
<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>ThreadLocal 的实现原理，是让每个线程自己维护一张 map，key 是 threadLocal 对象，value 是实际想存储的内容。</p>
<p>每个线程拿着 ThreadLocal 对象，把它作为 key，去自己独有的 map 里找到 key 对应的 value，由此实现了线程局部存储。</p>
<p><img src="/assets/ThreadLocal.jpg" alt="ThreadLocal"></p>
<p>直接来看 get() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据当前线程，获取map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="comment">// 如果map不为空，去map里面找</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据this（也就是本ThreadLocal对象），去map里面找到对应的entry</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果map为空，初始化map，并返回null</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本逻辑很简单，获取当前线程，根据当前线程获取 map，在 map 里根据 ThreadLocal 对象找 entry，返回 entry 的 value。</p>
<p>在这个主要流程里，我们还需要去扒：</p>
<ol>
<li>怎么根据当前线程获取 map</li>
<li>怎么在 map 里根据 ThreadLocal 找到 entry</li>
</ol>
<p>第一个问题特别简单，map 就是 Thread 的一个成员变量，直接返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再去看Thread类的源码，可以看到有一条成员变量：</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>第二个问题有点难，涉及到 map 的数据结构。</p>
<p>先提一下 map 具体是什么，这里的 map 实际上就是一个数组（没有链表），这个数组里的每一个元素都是一个 Entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个table就是map背后的数组：存放entry的数组</span></span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这就是数组中一个个的元素</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry 涉及到弱引用，这个后面再提，先看怎么从 map 中找到 entry：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据ThreadLocal对象（即key）计算出数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 如果数组下标内存的key能对上，那么就是</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="comment">// 如果key对不上，线性探测往后找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从整体上讲，这个 map 采用开放定址法，而不是拉链法，来解决哈希碰撞问题。</p>
<p>这种算法的大致原理是，计算出哈希值，然后存入数组里相应的位置，如果这个位置已经存在元素了（哈希碰撞），那么查看下一个数组格子是否是空的，一直找，直到找到一个空的位置，然后存进去。取的时候也是一样，先计算出哈希值，然后找相应数组下标内的元素，如果 key 对上了就是，如果对不上，找下一个。</p>
<p>关于使用开放定址法，存在两个疑问：为什么要使用它，而不是使用像 HashMap 一样的拉链法？使用这种需要优化什么？</p>
<p>第一个问题涉及到弱引用，这个后面再提。</p>
<p>第二个问题其实是在思考开放定址法的问题：如果每次计算出来的数组下标，距离靠得很近，那如果发生哈希碰撞，这个不对，找下一个，还不对，再找下一个，岂不是要找死？所以要让计算出来的数组下标，要分布尽可能地均匀。</p>
<h1 id="特殊的-hash-算法"><a href="#特殊的-hash-算法" class="headerlink" title="特殊的 hash 算法"></a>特殊的 hash 算法</h1><p>ThreadLocal 计算数组，是通过内部的一个数字计算的，这个数字很奇特，每个 ThreadLocal 的数字都不一样，但是它们都是一个公共数字 <code>HASH_INCREMENT</code> 的整数倍（会溢出，但是无所谓）。在程序启动之后，出现的第一个 ThreadLocal 对象内部的数字是 <code>HASH_INCREMENT</code>  的一倍，第二个 ThreadLocal 对象内部的数字是 <code>HASH_INCREMENT</code>  的两倍，以此类推，第 n 个 ThreadLocal 对象内部的数字是 <code>HASH_INCREMENT</code>  的 n 倍。</p>
<p>每个 ThreadLocal 对象内部的那个数字是 <code>threadLocalHashCode</code>（见名知意，就是 hash 值），而以 <code>HASH_INCREMENT</code> 为基的这个数字，大小初看很奇怪：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure>

<p>这个数字用十进制表示是 1640531527，它是 2^32 的黄金分割数，也就是 (2^32)/0.618。使用这个数字的整数倍，能计算得出很均匀的 map 下标（前提 map 的长度是 2 的幂）。具体的计算步骤是，获取 ThreadLocal 内部的那个数字（<code>threadLocalHashCode</code>），然后对 map 的长度 -1 取模，计算出一个不超过 map 长度的数字，这个数字就是数组的下标。</p>
<p>举个例子，0 - 31 这 32 个数字分别与 <code>0x61c88647</code> 相乘，然后再对 31 （0b11111）取模，依旧能获得 32 个不同的数字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    System.out.print((i * HASH_INCREMENT &amp; <span class="number">0b11111</span>) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台打印结果：0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25</span></span><br></pre></td></tr></table></figure>

<p>当数组长度是 2 的幂时，都可以做到如此均匀，虽然我不知道为什么（试着找了一些文章，但是看不懂hhh），但是觉得好牛x啊。</p>
<p>下图来源自文章<a href="https://web.archive.org/web/20161121124236/http://brpreiss.com/books/opus4/html/page214.html" target="_blank" rel="noopener">《Fibonacci Hashing》</a>，感受一下分布均匀度。</p>
<p><img src="/assets/image-20200704140058476.png" alt="连续分布"></p>
<p>有关 ThreadLocal 的 hash 算法就写到这里，然后我们来看 map 中的每一个元素：Entry。</p>
<h1 id="Entry-与弱引用"><a href="#Entry-与弱引用" class="headerlink" title="Entry 与弱引用"></a>Entry 与弱引用</h1><p>这是 Entry 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实际上就是 key-value 键值对，跟其他任何 map 里的设计都是一样的，有 key，也有 value。</p>
<p>它的 key，是 ThreadLocal 对象（尽管看源码有点懵），它的 value，就是线程局部存储的值，例如下面这两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">threadLocal.set(<span class="string">"pz"</span>);</span><br></pre></td></tr></table></figure>

<p>执行 set 方法的那个线程，它内部的 map 里的某一个格子，就是一个 Entry，这个 Entry 的 key 就是 threadlocal 对象，它的 value 是 “pz”。</p>
<p>Entry 源码里面看到了 value，但是没有看到 key，key 是通过 WeakReference（弱引用）来实现的。</p>
<p>弱引用是 JDK 1.2 出现的，这个概念跟 Java 虚拟机有关。弱引用是引用的一种，引用总共有四种，，我简单列一下：</p>
<ul>
<li>强引用（Strong Reference）：正常引用，根据垃圾回收算法，当这个引用存在时，就无法对引用对象进行 GC（如果根可达的话）</li>
<li>软引用（Soft Reference）：能够获取到引用对象，当发生 FGC 时，会回收引用对象，应用在缓存等。</li>
<li>弱引用（Weak Reference）：能够获取到引用对象，当发生 GC 时，会回收引用对象，应用在 ThreadLocal 等。</li>
<li>虚引用（Phantom Reference）：不能获取到引用对象，作用是当引用对象被 GC 时，虚引用会获得一个系统通知，应用场景跟一般的代码无关。</li>
</ul>
<p>上面写的引用，我只是简单一写，想理解的话去看《深入理解 Java 虚拟机》讲垃圾回收的部分，或是最开始提到的马士兵老师的视频，都讲得很好。</p>
<p>话说回来，继续看弱引用，看下面这两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;String&gt; r = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="string">"pz"</span>);</span><br><span class="line">r.get();</span><br></pre></td></tr></table></figure>

<p>上面创建了一个弱引用 WeakReference 对象 r，它引用到了一个字符串 “pz”，如果没有发生垃圾回收，那么可以通过 <code>r.get()</code> 方法获取到 “pz”，但如果发生了垃圾回收，这个虚引用并不会影响到字符串 “pz” 的回收，如果它真被回收了，那么执行 <code>r.get()</code> 方法将会获得 null。</p>
<p>因此再回去看 Entry 源码，发现 Entry 继承自 WeakReference，它可以通过虚引用获取到 ThreadLocal 对象，比如创建一个 Entry 对象（当然由于 private，下面的代码是实现不了的hh）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entry entry = <span class="keyword">new</span> Entry(threadLocal, <span class="string">"pz"</span>);</span><br><span class="line">entry.get(); <span class="comment">// ---&gt; 能拿到threadLocal，即key</span></span><br><span class="line">entry.value; <span class="comment">// ---&gt; 能拿到"pz"，即value</span></span><br></pre></td></tr></table></figure>

<p>如此可以看出，Entry 实际上就是 key-value 键值对，从 hash 开放定址法上来说，应该是没问题了，逻辑闭环了，但是有另一个问题：为什么要使用弱引用？</p>
<p>这主要与垃圾回收有关：如果 Entry 通过正常的引用关联 ThreadLocal 对象，那么如果线程不死，map 不清，由于强引用关系，ThreadLocal 对象就永远也不能被垃圾回收，这样即使某些 ThreadLocal 用不上了，它仍然不会被清理掉，造成内存泄漏。</p>
<p>（这里我还是有点疑惑，真的有这种内存泄漏的场景吗）</p>
<br>

<p>本来还想学点数据库事务的 ThreadLocal 原理的，但是写了这么多字懒了，告辞。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>java IO</title>
    <url>/2019/08/15/javaIO/</url>
    <content><![CDATA[<br>

<p>八月的第三周，来学习java IO系统。</p>
<p>IO是Input（输入）和Output（输出）的简称，合在一起就是<code>输入输出</code>。我们这里说的输入输出，都是相对于java程序而言的，我把硬盘中的文件读到java程序里，这是输入；我把java程序中的图片上传到博客里，这是输出。了解输入输出的第一件事，就是搞清楚<font color="#32CD32"><strong>入</strong></font>和<font color="#32CD32"><strong>出</strong></font>的方向是什么。</p>
<p>IO系统是一个超级庞大的系统，不论是方法（函数）还是设计模式，光从数量上就令人望而生畏。这周尽量多学，学到哪里算哪里吧。</p>
<hr>
<p>任何有关java IO的学习，永远是从5个基础的类开始的。</p>
<p><img src="/assets/IO%E5%9F%BA%E7%A1%80%E7%B1%BB.PNG" alt="IO基础类"></p>
<p>其中最为基础的是前三个：File类、InputStream类、OutputStream类，它们分别代表着<code>文件</code>、<code>输入</code>、<code>输出</code>。</p>
<p>举一个简单的例子：我把<code>文件</code>读取到java程序中，这里就是在<code>输入</code>，而我保存数据到<code>文件</code>中去，这里就是在<code>输出</code>。</p>
<p>下面两个类：Reader类、Writer类，同样是输入和输出，区别在于这两个传输的单位是字符，而前面那两个，传输的是字节。</p>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>File者，文件也。</p>
<p>但是File类实际上可以表示两方面：文件、文件夹（目录）。</p>
<p>File类是一个盘古开天辟地时的类，从JDK1.0就存在了。最常见的实例化方式是把<code>文件路径</code>输入进去，就像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src/test.txt"</span>);</span><br></pre></td></tr></table></figure>

<p>路径就是文件在计算机中的位置，有绝对路径和相对路径之分，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">绝对路径：<span class="string">"C:/JavaProgram/javaIO/src/test.txt"</span></span><br><span class="line">相对路径：                      <span class="string">"src/test.txt</span></span><br></pre></td></tr></table></figure>

<p><font color="#32CD32">相对</font>的意思就是，已经默认在某一个文件夹中了，前面那些路径就不用写了。</p>
<p>小总结一下：写清楚路径，通过路径拿到一个文件。</p>
<p>我认为对File类认识到这个地步就足够了。</p>
<h1 id="InputStream类、OutputStream类"><a href="#InputStream类、OutputStream类" class="headerlink" title="InputStream类、OutputStream类"></a>InputStream类、OutputStream类</h1><p>InputStream类、OutputStream类，这两个类是输入类和输出类，in是输入，out是输出，很明显。</p>
<p>这两个类也是盘古开天辟地时候的类，在JDK1.0就存在了。</p>
<p>（刚才忘了说，JDK是java开发的工具包，JDK1.0就是第一代开发工具包的意思，现在主流的开发包处在第7、8代，最新的已经到第12代了。）</p>
<p>我认为要了解清楚这两个类，需要搞清楚三件事情。</p>
<h2 id="1-传输的是什么东西？"><a href="#1-传输的是什么东西？" class="headerlink" title="1. 传输的是什么东西？"></a>1. 传输的是什么东西？</h2><p>上古类就该有上古类的样子，这两个类在输入输出时，传输的东西那都是最最最基本的单位：字节（就是1010……那串数字）。</p>
<p>因此InputStream的名字其实不是<code>输入</code>，而是<code>字节输入流</code>，OutputStream也不是<code>输出</code>，而是<code>字节输出流</code>。</p>
<h2 id="2-流是什么？"><a href="#2-流是什么？" class="headerlink" title="2. 流是什么？"></a>2. 流是什么？</h2><p>流（stream），这个概念基本就是java IO系统的核心了。</p>
<p>InputStream就是Input流，OutputStream就是Output流，想搞清楚这两个类是怎么工作的，最重要的就是理解“流”是什么。</p>
<p>我认为，“流”是一条中介管道，是连通java程序与外部存储的管道。它根本就没有流动，它是静态的，是装载着数据的一条中介管道。</p>
<p><img src="/assets/%E6%B5%81.png" alt="流"></p>
<p>如图，我要把数据，从<code>java程序</code>传输到<code>存储硬盘</code>中，中途就会经过一条漫长的<code>管道</code>。这条管道有一个一个的小格子，每一个格子里面都放着一字节的数据。这整条管道，就叫做流。如果是一条输出管道，那就是输出流，如果是一条输入管道，那就是输入流。</p>
<p>我觉得“流”这个名字很具有迷惑性，让人感觉好像是数据在流动一样，但是我看了几天之后觉得并没有，这就是一条静态的、被分隔为很多很多小格子的，管道，每一个格子里面装着一字节的数据。（但是底层应该不是这么实现的，我是做等效看待了）</p>
<ul>
<li>如果是输入流，那么把文件扔进管道，管道自动地将文件中的数据，按顺序一字节一字节地填充到管道的一个个小格子当中，每一格都是一字节的数据。数据并不会自动流过去，而是java程序自己顺着格子，拿走自己想要的数据。</li>
<li>如果是输出流，那么把java程序数据扔进管道，管道自动地将想要输出出去的数据，按顺序一字节一字节地填充到管道的一个个小格子当中，每一格都是一字节的数据。同样，数据也不会自动流到硬盘当中，而是有专门的函数，把这些数据顺着格子拷贝到硬盘里。</li>
</ul>
<p>说了这么多虚的，该看看具体的代码了。</p>
<h2 id="3-这两个类怎么用？"><a href="#3-这两个类怎么用？" class="headerlink" title="3.  这两个类怎么用？"></a>3.  这两个类怎么用？</h2><p>我们用InputStream类入手，看一个简单的例子。</p>
<p>我现在写入两行代码，将文件放进输入流当中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src/test.txt"</span>);</span><br><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure>

<p>这两行代码，可以理解为干了这么件事：</p>
<p>现在有一个txt文件，里面就写了一句英文，“Hello,pz.”，然后把这个文件扔进输入流中，输入流作为一条管道，分出了9个格子，每个格子放进去一个字母或是标点符号，就像是下面这张图一样。</p>
<p><img src="/assets/1566051405465.png" alt="1566051405465"></p>
<p>（数据是以010101……这种二进制数来表示的，比如字母H的二进制表示是01001000，转换成十进制后就是72，也就是上图管道中的第一个格子）</p>
<p>现在流已经存在了，要开始读取数据了。</p>
<p>InputStream类有一个方法read()，专门用来读取数据。但是由于java多态的特性，这一个read方法有三种使用方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">inputStream.read();</span><br><span class="line">inputStream.read(<span class="keyword">byte</span>[] b);</span><br><span class="line">inputStream.read(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>空参read()方法：</p>
<p>每次读一个格子的数据（读取一字节），并且返回这个数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">i = inputStream.read();</span><br></pre></td></tr></table></figure>

<p>以上面两行代码为例，我首先声明了<code>i</code>是一个整型数，然后去读取输入流的read()方法，第一次会读到72（字母H），然后如果你再执行一遍read()方法，就能读到下一个格子里的101（字母e），再执行一遍read()方法，就能读到108（字母l）……一直读到最后一个格子里的46（标点符号.），再读的话就没有东西了，就会返回-1。</p>
<p>通过空参read()方法，能够每次读取一字节的数据，当读完时会返回-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次读取一个字节，然后在控制台打印出来这个字节，直到读空为止</span></span><br><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> ((i = inputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">	System.out.print((<span class="keyword">char</span>) i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数是一个数组的read()方法：</p>
<p>每次读取数组长度的数据，返回读取的长度，同时把数据存放在数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">i = inputStream.read(b);</span><br></pre></td></tr></table></figure>

<p>请注意，这里非常有迷惑性。</p>
<p>我们刚才使用的read()方法，用<code>i</code>去读取，<code>i</code>里面直接存放数据。</p>
<p>但是，我们现在把一个数组当做参数，扔进read()方法里，还是用<code>i</code>去读取，但是现在<code>i</code>里面存放的，是读取的长度。</p>
<p>比如说上面写的这三行代码，依旧是声明了<code>i</code>是一个整型数，同时声明了<code>b</code>是一个长度为10的字节数组。现在我们去使用read()方法，<code>i</code>的值不再是72（字母H）了，而是9，因为输出流的长度是9（“Hello,pz.”一共九个字节)，我们用一个长度是10的数组去读取它，一口气把这9个字节全读完了。现在数据不装在<code>i</code>里面了，而是直接装在数组<code>b</code>里面。</p>
<p>也就是说，现在<code>i == 9</code>，<code>b == {72, 101, 108, 108, 111, 44, 112, 122, 46, 0}</code>，<code>b</code>这个数组，长度为10，前面9个全都存放着字节数据，最后一位没赋值所以是0。</p>
</li>
<li><p>参数是一个数组、两个整型数的read()方法：</p>
<p>依旧是把数据放在数组里面，但是只用数组的一部分，返回值依旧是读取的长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">i = inputStream.read(b, <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>跟第二种read()方法比，现在前两行的声明过程不变，第三行读取的时候，要求从数组<code>b</code>的下标为2（因为第1个数下标是0，下标为2也就是第3个数）的地方开始存放数据，一直放5个数据。</p>
<p>对比一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = inputStream.read(b);        <span class="comment">// b : &#123;72, 101, 108, 108, 111, 44 , 112, 122, 46, 0&#125;</span></span><br><span class="line">i = inputStream.read(b, <span class="number">2</span>, <span class="number">5</span>);	<span class="comment">// b : &#123;0,  0,   72,  101, 108, 108, 111, 0,   0,  0&#125;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>输入流，说完了。</p>
<p>(我知道我说得很烂，但是我不想重写了= =)</p>
<p>那么我们快速过一遍输出流。</p>
<p>OutputStream输出流同样输出的是字节，输出时用到的方法叫做write()，它同样有三种表现方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outputStream.write(<span class="keyword">int</span> b);                       <span class="comment">// 一次写入一个字节</span></span><br><span class="line">outputStream.write(<span class="keyword">byte</span>[] b);                    <span class="comment">// 一次写入一个数组的字节</span></span><br><span class="line">outputStream.write(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len);  <span class="comment">// 一次写入数组中从off位置开始的len个字节</span></span><br></pre></td></tr></table></figure>

<p>使用起来和输入流没什么区别，只不过一个是读取，一个是写入。</p>
<h1 id="Reader类、Writer类"><a href="#Reader类、Writer类" class="headerlink" title="Reader类、Writer类"></a>Reader类、Writer类</h1><p>Reader类、Writer类，这两个类也是输入和输出类，read读，是输入，write写，是输出，也很明显。</p>
<p>这两个类不是盘古开天辟地时期的类，而是女娲造人时候的类，因为它们两个是JDK1.1出现的。</p>
<p>跟InputStream类、OutputStream类相比，区别在于，前面两个是输入输出字节，这两个是输入输出字符。</p>
<br>

<p>我们来谈一下字节和字符。</p>
<p>我认为可以这么理解，字节是计算机认识的文字，字符是人类认识的文字。比如计算机一看01001000这八个二进制数字，就知道这是一个字节，而我们人类一看到H，就知道这是一个字母（也就是一个字符）。</p>
<p>字节和字符之间，是存在着对应关系的（术语叫做映射），一个字符就应该对应着一个（或几个）字节，比如字符H，对应的就是01001000这8个二进制数所组成的一个字节。这种对应关系我们叫编码和解码，其实就是“翻译翻译”，<code>字节 → 字符 ：解码</code>，<code>字符 → 字节 ：编码</code>，也就是<code>人话</code>和<code>机话</code>互相翻译，要不然人类说一个字母H，计算机怎么存下来呢？</p>
<p>一个字节有8个二进制位，你算一算，2的8次方也就256，也就是说一个字节最多也就只有256种不同的情况，字符有数十万个，对应不过来啦，所以一个字符一般是对应两三个字节。（如果是英文，那一个字节256种情况倒也是够用了）</p>
<p>有许多不同标准的字符集，比如中国字字符集、英文字符集、欧洲字符集等等，我把相关信息列在表格中：</p>
<table>
<thead>
<tr>
<th>编码类型</th>
<th>解释</th>
<th>1个字符占几个字节</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td>最基础的字符集，有字母和符号等</td>
<td>1</td>
</tr>
<tr>
<td>GBK</td>
<td>中国字字符集（GB就是国标）</td>
<td>中文字符占 2 个字节，英文字符占 1 个字节</td>
</tr>
<tr>
<td>ISO-8859-1</td>
<td>大部分的欧美字符</td>
<td>1</td>
</tr>
<tr>
<td>UTF-8</td>
<td>Unicode编码的一种<br>最为常用，比如字符串转byte[]时就是</td>
<td>变长编码，1-6个字节都有<br>中文字符占 3 个字节，英文字符占 1 个字节</td>
</tr>
<tr>
<td>UTF-16</td>
<td>Unicode编码的一种<br>有UTF-16be和UTF-16le两种<br>be就是Big Endian（大端）<br>le就是Little Endian（小端）</td>
<td>变长编码（2或4），但是多数是2<br>java内存编码使用UTF-16be编码<br>因为char类型使用UTF-16be编码<br>中文字符和英文字符都占两个字节</td>
</tr>
</tbody></table>
<p>我不打算写太多关于字符与字节的东西，只是简单记录一下。</p>
<br>

<p>好了我们说回输入输出。</p>
<ul>
<li>InputStream：字节输入流</li>
<li>OutputStream：字节输出流</li>
<li>Reader：字符输入流</li>
<li>Writer：字符输出流</li>
</ul>
<p>InputStream类、OutputStream类输入输出的是<code>byte</code>。</p>
<p>Reader类、Writer类输入输出的是<code>char</code>。</p>
<p>就这点区别，没啥别的了。</p>
<p>好吧我们还是惯例看看使用的方法：</p>
<ul>
<li><p>Reader类的read()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">reader.read();</span><br><span class="line">reader.read(<span class="keyword">char</span>[] cbuf);</span><br><span class="line">reader.read(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br><span class="line">reader.read(CharBuffer target);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Writer类的write()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">writer.write();</span><br><span class="line">writer.write(<span class="keyword">char</span>[] cbuf);</span><br><span class="line">writer.write(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br><span class="line">writer.write(String str);</span><br><span class="line">writer.write(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>好吧，看起来多了几个方法。</p>
<p>但说实话，我觉得本质上没什么区别，无非就是又包装了一下，用起来更顺手一些。流的使用上，是没有区别的。</p>
<p>所以这两个类，我们就不再说了。</p>
<br>

<br>











<p>让我们重看一遍一开始的那张图，这五个最为基础的类，可以再分成三类，一类跟文件打交道，一类跟字节打交道，一类跟字符打交道。</p>
<p><img src="/assets/IO%E5%9F%BA%E7%A1%80%E7%B1%BB%EF%BC%88%E5%88%86%E7%B1%BB%EF%BC%89.jpg" alt="IO基础类分类"></p>
<hr>
<p>在表述逻辑无比混乱地写完java IO基础的五个类之后，我们来学习装饰者模式。（啊真的想重写，可是又没力气）</p>
<h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>装饰者模式是这样的，我现在有一个类，但是我发现这个类的功能有限，我想给这个类增加几个功能，那么我就在这个类的外面，再套上一层，这么包装完之后呢，这个“被装饰过”的类，不单具有原先的功能，还有了一些新的功能。</p>
<p>装饰者模式的主要动作就是，有了一个类，给它套上一层装饰，变成了一个新的类，这个类增加了功能。</p>
<p>我们拿<code>字节输入流</code>举例子。</p>
<p>我们在使用InputStream类时，java程序是一字节一字节地读取数据的，这一个个读，其实是很慢的。如果java程序能加一层缓存，每一次多读一点数据，就会快一些。</p>
<p>我们现在希望实现的功能是：在原先InputStream类的基础之上，增加一个缓存的功能，因此我们是这么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">BufferedInputStream bs = <span class="keyword">new</span> BufferedInputStream(is);</span><br></pre></td></tr></table></figure>

<p>首先还是先实例化了一个InputStream对象<code>is</code>，接着我们装饰了这个<code>is</code>，让它变成一个BufferedInputStream对象<code>bs</code>（就是一个buffer过的InputStream）。那么现在，我们不再去操作<code>is</code>，而是去操作<code>bs</code>了，<code>bs</code>是一个具有缓存功能的<code>is</code>，是一个更强大的<code>is</code>。</p>
<p>（BufferedInputStream类具体强大在哪里呢？它也没多加什么新方法，它就是运行速度更快，快很多很多，读大文件的时候很明显。）</p>
<p>java IO系统中，装饰者模式比比皆是，全都是拿到一个输入/输出类，然后装饰一下变成一个新的类，去操作这个新的类，去实现更多的功能。</p>
<p>装饰者模式是一种设计模式，它的好处在于，如果我想给某些类实现一个新的功能，可以不通过继承，而是通过一个中间类去装饰一下即可。</p>
<p>比如现在有一个<code>运动类</code>，运动类下面有很多子类：<code>跑步类</code>、<code>打球类</code>、<code>跳绳类</code>……我现在希望每一个运动类的子类，这么多类，都去实现<code>运动完之后拉伸</code>的方法。按照原来的思路，我要把所有子类全部都继承一遍，每一个新继承的类都多加上这么一个<code>运动完之后拉伸</code>的方法，那不是累死了吗。通过装饰者模式，我可以创建一个<code>运动后拉伸类</code>，这个类读取一个运动类，随便哪个子类都可以，在这一装饰之下，就新增了拉伸的方法。这样做动静很小。</p>
<p>java IO系统这么青睐装饰者模式，主要是也是因为，特喵的java的IO相关类，实在是太多了……</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>WebFlux 中使用 Swagger</title>
    <url>/2020/07/27/webflux-%E4%B8%AD%E4%BD%BF%E7%94%A8-swagger/</url>
    <content><![CDATA[<br>

<p>因为工作需要，重新调研了 Swagger。WebFlux 使用 Swagger 和之前有一些不同，而且我发现网络上基本没有这方面的中文资料，因此写篇文章记录一下。</p>
<hr>
<p>Swagger 是非常常用的 API 文档工具，就我观察，好像所有需要写接口文档的 Java 项目都在使用它。从某种程度上讲，Swagger 可以代表接口文档，因为它实在是太主流了，而且它提出的规范也变成了行规，更何况它还在积极向前迭代。</p>
<p>网上对于 Swagger 和行业规范 OpenAPI 的描述有点混乱，我试着整理了一下：</p>
<ul>
<li>Swagger 在 2011 年出现，目前（2020.7）的版本是 2.X</li>
<li>Swagger 将自己的规范捐献给 Linux 基金会，改名为 OpenAPI Specification（OAS），目前的版本是 3</li>
<li>网络上普遍将 Swagger 1.X 称为 2.0，而将 2.X 称为 3.0，具体原因不明，因此搜索最新的 Swagger 时，你需要搜索 Swagger 3.0（或者放弃用中文搜索）</li>
<li>Swagger 1.X 和 2.X 在逻辑上是一致的，在使用上注解名都换了，在规范上做了更新（但是用户感受不到）</li>
</ul>
<br>

<p>大家使用 Swagger 基本都是在 Spring 项目中使用的，但是 Spring 官方并没有集成 Swagger，因此目前大家使用的都是开源世界的第三方轮子。有两个比较常见的依赖库：</p>
<ul>
<li>SpringFox，最常见，但是至今它还没有支持 Spring 5，因此如果想在 WebFlux 中使用 Swagger，你还不能选择这个。</li>
<li>SpringDoc，支持 WebFlux，本篇文章就是在说怎么使用 SpringDoc。</li>
</ul>
<hr>
<p>SpringDoc 有一大堆的 Swagger 实现，适配了诸如 Spring MVC、Spring WebFlux、Swagger-UI 等等一堆的内容，官方给的 demo 里面就有接近十个不同的项目，我也没太看明白，在反复尝试之后，得出一组在 WebFlux 上能够使用的 Maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-webflux-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-webflux-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（具体的官方文档可以点击 <a href="https://springdoc.org/" target="_blank" rel="noopener">SpringDoc</a>）</p>
<p>理论上引入 Maven 依赖之后就可以直接使用了，启动地址是 …/swagger-ui.html（在我们的项目里是 …/webjars/swagger-ui/index.html?configUrl=/v3/api-docs/swagger-config#/，不太明白原因）。</p>
<p>SpringDoc 的各项参数基本都可以在 <code>application.properties</code> 中进行配置，就比如上面的地址，默认配置就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">springdoc.swagger-ui.path=/swagger-ui.html</span><br></pre></td></tr></table></figure>

<p>更多的配置信息可以参考官方文档<a href="https://springdoc.org/springdoc-properties.html" target="_blank" rel="noopener">《Configuration of springdoc-openapi》</a>。</p>
<hr>
<p>Swagger 2.X 使用的注解全都变了，尽管使用逻辑没变，但是名字都不一样了。</p>
<p>如果你对原来的 Swagger 很熟悉，那么可以参考<a href="https://springdoc.org/migrating-from-springfox.html" target="_blank" rel="noopener">《Migrating from SpringFox》</a>，这是 SpringDoc 官方整理的一份文档，描述了怎么从 SpringFox 迁移过来（因为 SpringFox 使用旧的 Swagger 1.X，这文档整理得可以说是杀人诛心了233）</p>
<p>如果你对原来的 Swagger 不是很熟悉，或者印象不深了，可以参考 Swagger 2.X 在 github 上的官方使用文档<a href="https://github.com/swagger-api/swagger-core/wiki/Swagger-2.X---Annotations" target="_blank" rel="noopener">《Swagger 2.X Annotations》</a>。</p>
<p>国内使用 Swagger 2.X 的导读文章还比较少，唯一一篇我觉得有价值的是<a href="https://www.jianshu.com/p/b6f31966c5e1" target="_blank" rel="noopener">《springboot 集成 springdoc-openapi-ui》</a>。</p>
<br>

<p>下面我简单整理几个常用的注解：</p>
<h2 id="Tag"><a href="#Tag" class="headerlink" title="@Tag"></a>@Tag</h2><p>可用在类或方法前（一般是类前），用于给多个接口归类（某些接口在同一组内），相当于 Swagger2 的 <code>@Api</code>。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>数据类型</th>
<th>备注</th>
<th>是否必填</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>名称</td>
<td>String</td>
<td>如果多个 <code>@Tag</code> 使用相同的 <code>name</code>，那么将归到同一个组中</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>description</td>
<td>描述</td>
<td>String</td>
<td>如果多个 <code>@Tag</code> 的 <code>name</code> 相同归到同一个组，仅能使用一个 <code>description</code>，否则会发生覆盖</td>
<td>×</td>
<td>“”</td>
</tr>
<tr>
<td>externalDocs</td>
<td>额外说明文档</td>
<td>ExternalDocumentation（注解）</td>
<td>一般用不到，可以附文字、网址进行补充说明，内容详见下文 <code>@ExternalDocumentation</code> 注解</td>
<td>×</td>
<td><code>@ExternalDocumentation()</code></td>
</tr>
<tr>
<td>Extension</td>
<td></td>
<td></td>
<td>没用</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Tag</span>(name = <span class="string">"本Controller的名字"</span>, description = <span class="string">"这里是一些描述"</span>,</span><br><span class="line">        externalDocs = <span class="meta">@ExternalDocumentation</span>(description = <span class="string">"外部文档"</span>, url = <span class="string">"https://www.baidu.com"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Operation"><a href="#Operation" class="headerlink" title="@Operation"></a>@Operation</h2><p>可用在方法前，主要用于描述接口，相当于 Swagger 的 <code>@ApiOperation</code>。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>数据类型</th>
<th>备注</th>
<th>是否必填</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>summary</td>
<td>摘要（实际代表着名字的作用）</td>
<td>String</td>
<td>在 Swagger 中，展示在接口 URL 旁边，建议必写</td>
<td>×</td>
<td>“”</td>
</tr>
<tr>
<td>description</td>
<td>描述</td>
<td>String</td>
<td>在 Swagger 中，点击接口详情可看到</td>
<td>×</td>
<td>“”</td>
</tr>
<tr>
<td>requestBody</td>
<td>请求体</td>
<td>RequestBody（注解）</td>
<td>使用比较繁冗，建议不使用</td>
<td>×</td>
<td>@RequestBody()</td>
</tr>
<tr>
<td>responses</td>
<td>返回体</td>
<td>ApiResponse[]（注解数组）</td>
<td>使用比较繁冗，建议不使用</td>
<td>×</td>
<td>{}</td>
</tr>
<tr>
<td>externalDocs</td>
<td></td>
<td></td>
<td>一般用不上，用法同 <code>@Tag</code> 内的使用方法</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tags</td>
<td></td>
<td></td>
<td>建议不用，当类没有 <code>@Tag</code> 注解时，将使用此处的 tags 属性分成指定的多组，使用上容易出错</td>
<td></td>
<td></td>
</tr>
<tr>
<td>method</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
<tr>
<td>operationId</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
<tr>
<td>deprecated</td>
<td></td>
<td></td>
<td>用不上，完全可以用 Java 自己的 <code>@Deprecated</code> 注解代替</td>
<td></td>
<td></td>
</tr>
<tr>
<td>ignoreJsonView</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
<tr>
<td>extensions</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
<tr>
<td>parameters</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
<tr>
<td>security</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
<tr>
<td>servers</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
<tr>
<td>hidden</td>
<td></td>
<td></td>
<td>用不上</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果采用自定义的VO类，来接收和返回值，那么代码将很紧凑</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"example/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@Operation</span>(summary = <span class="string">"本方法的摘要/简介"</span>, description = <span class="string">"本方法的具体描述"</span>)</span><br><span class="line">Mono&lt;ResponseBean&lt;ResponseVo&gt;&gt; get(<span class="meta">@PathVariable</span> Long id) &#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> ResponseBean&lt;&gt;(HttpStatus.SC_OK, Boolean.TRUE, <span class="string">"success"</span>, <span class="keyword">new</span> ResponseVo()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Schema"><a href="#Schema" class="headerlink" title="@Schema"></a>@Schema</h2><p>主要用于描述实体类和变量（也可应用在其他注解之中，但代码冗余，不建议）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>数据类型</th>
<th>备注</th>
<th>是否必填</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>替换原名</td>
<td>String</td>
<td><strong>不要使用</strong>，它会替换掉原字段名称，例如变量名 <code>userId</code> 注 <code>name = &quot;用户ID&quot;</code>，变量名在前端的展示将不再是 <code>userId</code>，而是<code>用户ID</code></td>
<td>×</td>
<td>“”</td>
</tr>
<tr>
<td>description</td>
<td>描述</td>
<td>String</td>
<td>最常使用，请在每处都使用它</td>
<td>×</td>
<td>“”</td>
</tr>
<tr>
<td>example</td>
<td>样例</td>
<td>String</td>
<td>示例，建议使用</td>
<td>×</td>
<td>“”</td>
</tr>
<tr>
<td>required</td>
<td>是否必填</td>
<td>boolean</td>
<td></td>
<td>×</td>
<td>false</td>
</tr>
<tr>
<td>其他（好多）</td>
<td></td>
<td></td>
<td>建议不使用，可自行斟酌</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema</span>(description = <span class="string">"用户类"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Schema</span>(description = <span class="string">"用户ID"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema</span>(description = <span class="string">"用户名"</span>, required = <span class="keyword">true</span>, example = <span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>写一个简单的小 demo：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————————————————— 定义两个类，用于接收和返回 —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema</span>(name = <span class="string">"请求对象"</span>, description = <span class="string">"用于接收请求的内容"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestDto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema</span>(description = <span class="string">"ID"</span>, example = <span class="string">"20200711001"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema</span>(description = <span class="string">"名字"</span>, example = <span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema</span>(name = <span class="string">"返回对象"</span>, description = <span class="string">"用于封装返回的内容"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDto</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema</span>(description = <span class="string">"ID"</span>, example = <span class="string">"20200711002"</span>, required = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema</span>(description = <span class="string">"名字"</span>, example = <span class="string">"李四"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— 下面是Controller层的使用 —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"swagger"</span>)</span><br><span class="line"><span class="meta">@Tag</span>(name = <span class="string">"swagger api"</span>, description = <span class="string">"swagger样例代码"</span>, externalDocs = <span class="meta">@ExternalDocumentation</span>(</span><br><span class="line">        description = <span class="string">"swagger-core 参考网站"</span>,</span><br><span class="line">        url = <span class="string">"https://github.com/swagger-api/swagger-core/wiki/Swagger-2.X---Annotations"</span></span><br><span class="line">))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">controller</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ———————————————————————— 以下是推荐用法 ———————————————————————— */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"example1/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@Operation</span>(summary = <span class="string">"GET 请求示例1"</span>, description = <span class="string">"推荐用法（RESTful风格）"</span>)</span><br><span class="line">    <span class="function">Mono&lt;ResponseDto&gt; <span class="title">get1</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> ResponseDto());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"example2"</span>)</span><br><span class="line">    <span class="meta">@Operation</span>(summary = <span class="string">"GET 请求示例2"</span>, description = <span class="string">"推荐用法（用params接收参数）"</span>)</span><br><span class="line">    <span class="function">Mono&lt;ResponseDto&gt; <span class="title">get2</span><span class="params">(@RequestParam Long userId, @RequestParam String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> ResponseDto());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* —————————————————— 以下是不推荐用法（勉强实现效果） —————————————————— */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"example3"</span>)</span><br><span class="line">    <span class="meta">@Operation</span>(</span><br><span class="line">            summary = <span class="string">"POST 请求示例1"</span>, description = <span class="string">"不推荐用法（手动指定类型）"</span>,</span><br><span class="line">            requestBody = <span class="meta">@io</span>.swagger.v3.oas.annotations.parameters.RequestBody(</span><br><span class="line">                    content = <span class="meta">@Content</span>(schema = <span class="meta">@Schema</span>(implementation = RequestDto.class))</span><br><span class="line">            ),</span><br><span class="line">            responses = &#123;<span class="meta">@ApiResponse</span>(</span><br><span class="line">                    content = <span class="meta">@Content</span>(schema = <span class="meta">@Schema</span>(implementation = ResponseDto.class))</span><br><span class="line">            )&#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function">Mono&lt;JSONObject&gt; <span class="title">save2</span><span class="params">(@RequestBody JSONObject request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mono.just(<span class="keyword">new</span> JSONObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Swagger 的配置文件（Config.java）是可有可无的，因为大多数的配置，都可以使用上文提到的 <code>application.properties</code> 中配置，这跟在 Spring Boot 中使用其他依赖工具的方式是一样的。</p>
<p>如果你还是想用一个 Java 文件单独配置的话，可以参考下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@OpenAPIDefinition</span>(info = <span class="meta">@Info</span>(</span><br><span class="line">        title = <span class="string">"pz的Swagger网站"</span>, version = <span class="string">"1.0"</span>, description = <span class="string">"后端管理系统接口文档"</span>),</span><br><span class="line">        externalDocs = <span class="meta">@ExternalDocumentation</span>(description = <span class="string">"官方使用文档"</span>, url = <span class="string">"https://github.com/swagger-api/swagger-core/wiki/Swagger-2.X---Annotations"</span>))</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以下是在配置鉴权 authorization</span></span><br><span class="line"><span class="comment">     * 在使用时，在想鉴权的类上配置注解 <span class="doctag">@SecurityRequirement</span>(name = "authorization")</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OpenAPI <span class="title">customOpenAPI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OpenAPI()</span><br><span class="line">                .components(<span class="keyword">new</span> Components()</span><br><span class="line">                        .addSecuritySchemes(<span class="string">"authorization"</span>,</span><br><span class="line">                                <span class="keyword">new</span> SecurityScheme()</span><br><span class="line">                                        .name(<span class="string">"Authorization"</span>)</span><br><span class="line">                                        .in(SecurityScheme.In.HEADER)</span><br><span class="line">                                        .type(SecurityScheme.Type.APIKEY)</span><br><span class="line">                                        .scheme(<span class="string">"bearer"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它实现了两个配置：</p>
<ol>
<li>Swagger 可视化网站的名称等配置。</li>
<li>配置了鉴权（请求参数中携带 Authorization 作为 token）</li>
</ol>
<p>值得一提的是，上面这两个配置，一个使用注解，一个使用方法，其实是可以互换的，也就是说每一种配置都是可以使用注解或方法来配置的，看个人喜好。</p>
<p>最终的效果如下图所示：</p>
<p><img src="/assets/Swagger.png" alt="Swagger"></p>
<br>

<p>研究 Swagger 配置鉴权花了不少时间，主要也是因为自己没有做过鉴权相关的东西。</p>
<p>总体的思路是，在配置文件中事先配置好，并给这个部分起一个名字（因为可以有多个鉴权）。在想使用的 Controller 层或者方法层上，加上一行注解，指定想要使用的鉴权的名字，就可以使用啦。</p>
<p>比如针对上面的配置文件（名字叫做 <code>authorization</code>），就可以在 Controller 上面加上这么一行注解，这样在 Swagger 中调用方法时，这个 Controller 里面的所有方法都会在请求参数里带上 <code>Authorization</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SecurityRequirement</span>(name = <span class="string">"authorization"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">controller</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>就整理这么多吧。</p>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>java 异常</title>
    <url>/2019/08/22/java-exception/</url>
    <content><![CDATA[<p>八月的第四周，来学习 Java 的异常处理机制。</p>
<p>异常就是不正常，程序不能正常执行，中途遇到了的问题就是异常。这次来写异常分哪些情况，以及怎么处理异常。</p>
<hr>
<p>首先需要厘清的是，几乎所有介绍异常的总结贴，以及面试时对异常的提问，基本上说的都不光是异常，而是整个异常体系。</p>
<p><img src="/assets/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%EF%BC%88%E7%AE%80%E7%95%A5%EF%BC%89.png" alt="异常体系（简略）"></p>
<p>看一下简图就很明白了：父类 Throwable 有两个子类，一个是 Error （错误），另一个才是 Exception （异常）。也就是说，异常体系说的不光是异常，还把他爸和他哥一起介绍了，一家包圆了。</p>
<p>光从词语的表达上就能感受到，Error 和 Exception 的严重程度是不同的，Error （错误）是非常严重的事情，而 Exception （异常）是可以商量的事情。</p>
<ul>
<li>Error ：错误，指的是程序中很严重的问题，严重到 Java 虚拟机都无法处理，只能停止程序改bug。</li>
<li>Exception ：异常，指的是程序中的轻度问题，程序运行时遇到了之后，处理一下还可以继续执行下去（当然了，一定要处理，不能随便放任不管）。</li>
</ul>
<p>上面那张图只是一张表示 Error 和 Exception 之间关系的图，实际上的异常体系还是比较庞大的，我找到了一张稍微全一些的体系图（<a href="https://juejin.im/post/5c863f48e51d45192c4a701f" target="_blank" rel="noopener">图片来源</a>）。</p>
<p><img src="/assets/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.jpg" alt="异常体系"></p>
<p>现在你要注意到，上图中的所有东西，比如 <code>Error</code> ，比如 <code>Exception</code> ，比如 <code>Exception</code> 里的 <code>NullPointerException</code> ，不论是错误也好异常也罢，以上的所有东西，统统都是类。Java 作为一门面向对象的语言，已经连错误、异常这些东西，都封装起来看作是一种类了。上图中的所有东西都是类，都有继承关系，都有方法，都是当做一个个的封装起来的对象来处理的。</p>
<h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>Error （错误）不是这周学习的重点，事实上其内容需要好几年 Java 实战的积累才能逐渐掌握，因为里面涉及到的具体情况都是偏硬件、偏底层的东西，比如 <code>OutOfMemoryError</code> （内存溢出错误类）。</p>
<p>我们目前只需要知道，Java 虚拟机并不会处理 Error 类，也就是说编译器不会检查 Error 类，我们在做程序设计的时候，也不应该去尝试捕获 Error 类。</p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>Exception （异常）是这周关注的重点。</p>
<p>Exception 有许许多多的子类，其中一类 <code>RuntimeException</code> 即<code>运行时异常</code>，这个子类和其他子类有所不同，怎么不同的一会再说。总之 Exception 可以分成两类，一类叫做<code>运行时异常</code>，另一类叫做<code>非运行时异常</code>。</p>
<p>怎么不同的呢？</p>
<ul>
<li><code>RuntimeException</code> 运行时异常，就是程序真的运行起来了，才能发现的异常。</li>
<li>非运行时异常，意思是说，程序即使不运行，编译器都知道将会有异常发生。也就是说，你不处理这个异常，你就别想让程序运行起来。</li>
</ul>
<p>这两类异常的主要区别在于，一种程序可以先运行起来（遇到了再报错），一种程序上来就无法运行（不用遇到了，直接报错）。</p>
<p>再换句话说，一种可以通过编译器的检查，一种无法通过编译器的检查。</p>
<p>如果从编译器检查的角度来看这两类异常，那么运行时异常（ RuntimeException ），因为可以逃避编译器的检查，因此可以被称为非检查性异常；而其他异常（也就是非运行时异常）逃不过编译器的检查，因此可以被称为检查性异常。</p>
<p>所以异常可以换一种分类方式：<code>检查性异常</code>、<code>非检查性异常</code>。这一种分类方式是更被普遍提到的，虽然它所指的其实就是运行时和非运行时，只是看待的角度不同。（现在建议你再去看一看上面的图，再理解一下分类）</p>
<ol>
<li><p>非检查性异常/运行时异常</p>
<p>属于这一类的异常中，较为常见的有：</p>
<ul>
<li><code>NullPointerException</code> 空指针异常</li>
<li><code>ArithmeticException</code> 算术异常（比如 5 除以 0 ）</li>
<li><code>ClassCastException</code>  类型转换异常</li>
<li><code>IndexOutOfBoundsException</code> 数组越界异常</li>
<li><code>ArrayStoreException</code> 数据存储异常（数组存储时数据类型不一致）</li>
</ul>
</li>
<li><p>检查性异常/非运行时异常</p>
<p>属于这一类异常中，较为常见的有：</p>
<ul>
<li><code>IOException</code> 输入输出异常</li>
<li><code>FileNotFoundException</code> 文件不存在异常（继承自 <code>IOException</code> ）</li>
<li><code>SQLException</code> SQL 语句异常</li>
<li><code>InterruptedException</code> 中断异常</li>
</ul>
</li>
</ol>
<hr>
<p>现在来学习，如果遇到了异常（ Exception ），怎么处理异常。</p>
<p>准确的说应该是，我怀疑某个地方要出现异常，我怎么提前处理这个地方，让它在程序运行之后真的遇到了异常时，仍然能在处理之后继续运行程序。</p>
<p>要注意的是，检查性异常是一定要进行处理的，不处理程序都无法运行（因为编译器直接报错），而非检查性异常和没有异常的地方（比如合理怀疑某段代码有问题），也是可以进行异常处理的。异常处理并不是只针对于异常的，而是在一切场景之下，只要我怀疑存在异常，都可以去做异常处理（大不了没碰上呗）。</p>
<p>Java 有两种异常处理方案，分别是<code>就地解决</code>（ try / catch / finally 语句）和<code>异地正法</code>（ throws ）。</p>
<h1 id="就地解决"><a href="#就地解决" class="headerlink" title="就地解决"></a>就地解决</h1><p>现在我遇到一段可能存在异常的代码，打算当场解决掉它。</p>
<p>下面这几行代码就是就地解决异常的处理方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能存在异常</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 如果遇到了异常，那就执行这段代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 不论有没有遇到异常，都执行这段代码</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有三个关键字：</p>
<ul>
<li><code>try</code> 大括号里放【可能存在异常的代码】，表示“这段代码可能有异常，我们来试试看”。</li>
<li><code>catch</code> 小括号里放【异常的类型】，大括号里放【处理异常的代码】，表示“我发现了XX异常，我要这么去处理它”。</li>
<li><code>finally</code> 大括号里放【不论如何都会执行的代码】，表示“我管你遇不遇得到异常，全都给我执行这段代码”。</li>
</ul>
<p>还是举一个具体的例子吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">"发现了算术异常"</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"不论如何，都给我执行这段代码"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会在控制台上打印两句话：</span></span><br><span class="line"><span class="comment">// 发现了算术异常</span></span><br><span class="line"><span class="comment">// 不论如何，都给我执行这段代码</span></span><br></pre></td></tr></table></figure>

<ol>
<li>程序进入 <code>try{}</code> 语句块中，执行了 <code>int number = 1/0;</code> 这行代码，因为 0 不能作为被除数，所以出现了异常。</li>
<li>通过 <code>catch(){}</code> 语句块捕捉到了 <code>ArithmeticException</code> （算术异常），你应该注意到了，小括号里放的就是这一异常的类型，如果放的是别的异常的话，那么会捕捉不到的。大括号里表示，捕捉到这一异常之后，要执行的操作，在这里是在控制台打印了一句话：“发现了算术异常”。</li>
<li><code>finally{}</code> 语句块是程序无论如何都会执行的部分，即使是没有异常也会执行。在这里发生了算数异常，打印了一句话：“不论如何，都给我执行这段代码”。其实如果没有发生异常的话，也会把这句话打印出来的。</li>
</ol>
<h1 id="异地正法"><a href="#异地正法" class="headerlink" title="异地正法"></a>异地正法</h1><p>有时我们并不想在异常出现的地方就去处理它，那么可以把异常<code>抛出去</code>。</p>
<p>抛出去（throw）又是一个翻译过来的词，在英文环境中这个词很生动，但是在汉语环境中就并不如此。我们经常听到<code>抛异常</code>这三个字，意思就是把异常给“抛”出去，不立即处理，而是在其他地方去处理。</p>
<p>比如现在有<code>方法 A</code>，<code>方法 A</code> 调用了<code>方法 B</code> ，<code>方法 B</code> 的内部出现了异常，现在就有两种解决方案：</p>
<ol>
<li><code>方法 B</code> 自己处理异常，也就是刚才说的“就地正法”。</li>
<li><code>方法 B</code> 不去解决，而是“抛”给<code>方法 A</code> 去解决。</li>
</ol>
<p>为什么不当场解决，而是抛出去让其他地方去解决，原因可能有很多，比如另一个地方拿到异常对象能做更多事情，比如程序员懒想拖到其他地方再说，等等。</p>
<p><code>抛异常</code>的动作很简单，只需要在方法名的后面（注意，不是在异常发生的原地，而是在异常发生所在的方法，那个方法的名字的位置处），加上 <code>throws XXXException</code> 就可以了。</p>
<p>举个栗子吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义了一个只有两行代码的方法（方法名叫 <code>test</code>），第一行是让 <code>number = 1/0</code> （很明显出现了算术异常），第二行返回 <code>number</code> 。我并没有在异常出现的原地去处理，而是在方法名的后面，加上了 <code>throws ArithmeticException</code> ，表示抛出去了一个算术异常。之后哪里调用了这个方法，就必须去处理这个异常（或者继续抛出去）。</p>
<p>你注意，这里说的抛异常，是我们遇到了异常之后，把遇到的这个异常抛出去，而且是在方法名旁边去抛的，意思是说“每当你调用这个方法的时候，都要注意，这个方法里面有个异常要处理”。但是还有一种抛异常的方法，就是可以在随便一个地方，手动地抛出去一个异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br></pre></td></tr></table></figure>

<p>比如这个样子，我手动地把一个新实例化出来的算术异常抛出去了。</p>
<p>在方法名旁边写的那个，是 <code>throws</code> ，而手动在随便一个地方抛出去的，是 <code>throw</code> 。</p>
<hr>
<p>剩下的部分太过零碎，我就分条写，写到哪里算哪里好了。</p>
<h1 id="1-finally-语句块"><a href="#1-finally-语句块" class="headerlink" title="1.finally 语句块"></a>1.<code>finally</code> 语句块</h1><p>在捕获异常当场解决的地方，我们使用了 try / catch / finally 语句，其中 <code>finally{}</code> 语句块是“无论如何都会执行的代码”。</p>
<p>这里的无论如何，真的就是无论如何，它保证了程序一定会执行这部分代码，不管发不发生异常都会执行，而且不管 <code>try{}</code> 语句块中写了什么，也都会执行。</p>
<p>注意：即使是 <code>try{}</code> 语句块中写了返回语句 <code>return xxx;</code> ，你感觉程序走到这里就停止了，其实并不是，这样也都会去执行 <code>finally{}</code> 语句块。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"finally 语句块执行了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终会在控制台上打印两行：</span></span><br><span class="line"><span class="comment">// finally 语句块执行了</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>通过反编译可以发现，Java 在处理 <code>finally{}</code> 语句块时，是把它复制成两份，分别在 <code>try{}</code> 语句块和 <code>catch{}</code> 语句块后面去执行一次的。</p>
<p>而且如果 <code>finally{}</code> 语句块中写了返回语句 <code>return xxx;</code> ，将会执行这个返回语句，程序到此结束。</p>
<h1 id="2-异常链"><a href="#2-异常链" class="headerlink" title="2.异常链"></a>2.异常链</h1><p>维基百科对于异常链的解释真是太令人舒服了，一眼看懂：</p>
<blockquote>
<p>异常链是一种面向对象编程技术，指将捕获的异常包装进一个新的异常中并重新抛出的异常处理方式。原异常被保存为新异常的一个属性（比如cause）。这个想法是指一个方法应该抛出定义在相同的抽象层次上的异常，但不会丢弃更低层次的信息。</p>
</blockquote>
<p>还是举一个例子吧：</p>
<p><code>main</code> 方法调用 <code>test1</code> 方法，<code>test1</code> 方法调用 <code>test2</code> 方法。</p>
<p>其中 <code>test2</code> 方法中抛一个异常， <code>test1</code> 方法会接到 <code>test2</code> 方法抛出的异常，包裹起来再抛一个新的异常。</p>
<p>这样 <code>main</code> 方法中就会出现一个异常，这个异常里面还有一个异常（也就是接到一个包裹着异常的异常）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 test1 方法</span></span><br><span class="line">        <span class="keyword">int</span> num = test1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 test2 方法，抛一个新的异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num = test2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"这里是test1的异常"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// test2 方法中抛一个异常</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"这里是test2的异常"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台的打印信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Exception: 这里是test2的异常</span><br><span class="line">	at testCode.Test.test2(Test.java:<span class="number">21</span>)</span><br><span class="line">	at testCode.Test.test1(Test.java:<span class="number">12</span>)</span><br><span class="line">	at testCode.Test.main(Test.java:<span class="number">6</span>)</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.RuntimeException: 这里是test1的异常</span><br><span class="line">	at testCode.Test.test1(Test.java:<span class="number">15</span>)</span><br><span class="line">	at testCode.Test.main(Test.java:<span class="number">6</span>)</span><br><span class="line">Caused by: java.lang.Exception: 这里是test2的异常</span><br><span class="line">	at testCode.Test.test2(Test.java:<span class="number">21</span>)</span><br><span class="line">	at testCode.Test.test1(Test.java:<span class="number">12</span>)</span><br><span class="line">	... <span class="number">1</span> more</span><br></pre></td></tr></table></figure>

<p>这里就看到了异常链。</p>
<h1 id="3-一个catch子句捕获多个异常"><a href="#3-一个catch子句捕获多个异常" class="headerlink" title="3.一个catch子句捕获多个异常"></a>3.一个catch子句捕获多个异常</h1><p><code>JDK1.7</code> 改进了 catch 子句的语法，允许在其中指定多种异常，每个异常类型之间使用“|”来分隔。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//..............</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExceptionA | ExceptionB ab) &#123; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExceptionC c) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-异常抑制"><a href="#4-异常抑制" class="headerlink" title="4.异常抑制"></a>4.异常抑制</h1><p><code>JDK1.7</code> 中为 <code>Throwable类</code> 增加 <code>addSuppressed方法</code>和 <code>getSuppressed方法</code>。</p>
<p>当一个异常被抛出的时候，可能有其他异常因为该异常而被抑制住，从而无法正常抛出。这时可以通过 <code>addSuppressed方法</code> 把这些被抑制的方法记录下来，被抑制的异常会出现在抛出的异常的堆栈信息中，可以通过 <code>getSuppressed方法</code> 获取到被抑制的异常。</p>
<p>个人觉得没啥用，懒得写了。</p>
<h1 id="5-try-with-resources"><a href="#5-try-with-resources" class="headerlink" title="5. try - with - resources"></a>5. try - with - resources</h1><p>同样还是 <code>JDK1.7</code> 增加的新特性。</p>
<p>以前使用 <code>try / catch / finally</code> 语句块处理资源的时候，如果要关闭资源，需要在 <code>finally{}</code> 语句块中关闭，使用 <code>try - with - resources</code> 方式可以在 <code>try()</code> 的小括号里声明，Java 会自动关闭资源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(inputString);</span><br><span class="line"><span class="keyword">try</span> (BufferedReader br1 = br) &#123;</span><br><span class="line">    <span class="keyword">return</span> br1.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JDK1.9</code> 更进一步， <code>try()</code> 的小括号里不需要声明了，声明过程在外面也可以。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(inputString);</span><br><span class="line"><span class="keyword">try</span> (br) &#123;</span><br><span class="line">    <span class="keyword">return</span> br.readLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>try 后面小括号内的东西即为 resources ，resources 必须是实现 <code>java.lang.AutoCloseable</code> 或者 <code>java.io.Closeable</code> 接口的类（需要手动 close() 释放资源的）。</p>
<h1 id="6-IDEA-的快捷操作"><a href="#6-IDEA-的快捷操作" class="headerlink" title="6.IDEA 的快捷操作"></a>6.IDEA 的快捷操作</h1><p>要是使用的Java开发工具是 IDEA 的话，那么如果想对某一句代码进行异常处理，可以在这句代码写完之后，敲上“ <code>.try</code> “这四个字符，再敲回车，就可以自动为这行代码加上 try / catch 语句了。</p>
<p>例如这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>/<span class="number">0</span>;.<span class="keyword">try</span></span><br></pre></td></tr></table></figure>

<p>写完之后敲击回车，自动变成如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手与四次挥手</title>
    <url>/2020/12/27/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<br>

<p>十二月的第四周，来完整学习 TCP 的三次握手和四次挥手。</p>
<p>本来学习完 Redis 后想先学 MySQL 的，但 MySQL 的学习曲线比想象的陡。工作时用到了 Wireshark，配合掘金小册《<a href="https://juejin.cn/book/6844733788681928712" target="_blank" rel="noopener">深入理解 TCP 协议：从原理到实战</a>》重学了一遍 TCP/IP 协议（这本书写得是真的好），这周先学习 TCP 建立连接与释放连接。</p>
<p>本文的配图基本都来源自《<a href="https://juejin.cn/book/6844733788681928712" target="_blank" rel="noopener">深入理解 TCP 协议：从原理到实战</a>》。</p>
<hr>
<h1 id="抓包工具-Wireshark"><a href="#抓包工具-Wireshark" class="headerlink" title="抓包工具 Wireshark"></a>抓包工具 Wireshark</h1><p>首先介绍一下 Wireshark，这是一个开源的网络数据包分析软件（抓包工具）。</p>
<p>工作中需要抓包分析，使用了 Fiddler 和 Wireshark 两款软件。</p>
<ul>
<li><p>Fiddler 是一个用于 HTTP 调试的抓包工具，它能捕获 HTTP 和 HTTPS 请求。</p>
<p>Fiddler 的工作原理是代理。Fiddler 在启动时会自动设置好代理地址，客户端发送 HTTP 请求时，会首先发送给代理（Fiddler），再由代理转发送达服务端，反之也是如此。</p>
</li>
<li><p>Wireshark 是一个用于抓取一切网络数据包的工具，它抓取的是 0101 的二进制比特流，并基于七层网络协议解析成 IP、TCP、UDP、HTTP 等各种网络协议。由于开源，众多代码贡献者基本让 Wireshark 支持所有的网络协议。</p>
<p>Wireshark 的工作原理是绑定网关，所有网络请求都要流经网关，也就都被 Wireshark 捕获到。</p>
</li>
</ul>
<p>我们今天只学习功能更强大的 Wireshark。</p>
<p>Wireshark 的界面如下图所示：</p>
<p><img src="/assets/Wireshark%E7%95%8C%E9%9D%A2.jpg" alt="Wireshark界面"></p>
<p>上半部分是所有网络数据包（包含时间、发送方 IP 地址、接收方 IP 地址、网络协议），下半部分是单个网络数据包的具体内容（点击哪个就展示哪个），它按照七层网络协议展示。</p>
<p>我们今天基本只会看运输层（TCP 所在的那一层），下图是 Wireshark 中查看网络层和运输层的界面。</p>
<p><img src="/assets/wireshark%E7%BD%91%E7%BB%9C%E5%B1%82%E5%92%8C%E8%BF%90%E8%BE%93%E5%B1%82.jpg" alt="wireshark网络层和运输层"></p>
<p>网络层提供 IP 地址，运输层提供端口号，源 IP、源端口、目标 IP、目标端口构成了 TCP 连接的「四元组」。</p>
<br>

<p>我们以访问百度为例，进行一次抓包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -v www.baidu.com</span><br></pre></td></tr></table></figure>

<p>该访问的抓包文件可以在 github 下载：<a href="https://github.com/arthur-zhang/tcp_ebook/blob/master/tcp_header/curl_baidu.pcapng" target="_blank" rel="noopener">curl_baidu.pcapng</a></p>
<hr>
<p>首先把 TCP 报文首部示意图贴出来，这是 TCP 协议的基石，我们接下来会反复看它。</p>
<p><img src="/assets/TCP%E5%A4%B4%E9%83%A8.jpg" alt="TCP头部"></p>
<h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><p>三次握手在 Wireshark 中是这样的：</p>
<p><img src="/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p>
<p>本地（192.168.31.240）向百度服务器（14.215.177.38）发送建立 TCP 连接的请求，百度服务器回复本地，本地再回复百度服务器，这三次请求被称为三次握手。</p>
<br>

<p>以第一次握手为例，讲解 TCP 报文包含什么信息：</p>
<p><img src="/assets/TCP%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="TCP第一次握手"></p>
<h2 id="源端口号（Source-Port）、目标端口号（Destination-Port）"><a href="#源端口号（Source-Port）、目标端口号（Destination-Port）" class="headerlink" title="源端口号（Source Port）、目标端口号（Destination Port）"></a>源端口号（Source Port）、目标端口号（Destination Port）</h2><p>源端口号是 61024，这就是我们本机的端口号</p>
<p>目标端口号是 80，这是百度服务器的端口号（HTTP 的默认端口号）</p>
<p>每个端口号占 2 字节（16 bit），因此端口号最大也只有 65535，熟知的端口号有：</p>
<ul>
<li>80：HTTP</li>
<li>443：HTTPS</li>
<li>22：SSH</li>
</ul>
<h2 id="序列号（Sequence-Number）"><a href="#序列号（Sequence-Number）" class="headerlink" title="序列号（Sequence Number）"></a>序列号（Sequence Number）</h2><p>序列号是一个 32 位的无符号整数，达到 2^32 - 1 后循环到 0。</p>
<p>序列号是用来排序的，排发送 TCP 包的顺序。因为网络层（IP 层）不保证包的顺序，因此发送方依次发送 1、2、3、4 四个 TCP 包，接收方接到时可能是 2、4、3、1。为了解决网络包乱序、重复的问题，TCP 头部引入序列号的概念。</p>
<p>序列号是按照报文段的长度累加的（不算头部的长度），比如发送方发送某个 TCP 包的序列号是 10，该包的报文长度是 78，那么发送方下一次发送时，序列号就是 10 + 78 = 88。</p>
<p><img src="/assets/TCP%E5%BA%8F%E5%88%97%E5%8F%B7.jpg" alt="TCP序列号"></p>
<p>三次握手的首次握手，初始的序列号（ISN）不是从 0 开始的，也不是某个固定的数字，而是随时间而变化。将 ISN 设置成固定值会有两个问题：</p>
<ol>
<li>安全问题，如果知道了连接的 ISN，很容易伪造一个 RST 包，将连接强制关闭。如果采用动态 ISN，伪造一个在对方窗口内的序列号就会相对困难。</li>
<li>开启 SO_REUSEADDR 以后端口允许重用，这样收到一个包，并不知道是新连接还是因为网络原因姗姗来迟的旧连接。</li>
</ol>
<p>三次握手发送序列号的过程如下图所示（第二次握手拆成两步）。</p>
<p><img src="/assets/TCP%E5%BA%8F%E5%88%97%E5%8F%B7%E5%8F%91%E9%80%81.jpg" alt="TCP序列号发送"></p>
<p>还有一个有关序列号的细节，那就是 SYN 报文（SYN 是 TCP flags，在后文有写）不携带数据，但是它占用一个序号，下次发送数据序列号要加一，但是 ACK 报文不会占用序列号。这个细节可以从这个角度来理解：消耗序列号的 TCP 报文段，一定需要对方确认，SYN 报文需要 ACK 报文确认，但是 ACK 报文并不需要。如果消耗序列号的 TCP 报文段没有收到确认，会一直重传（有重试次数上限）。</p>
<h2 id="确认号（Acknowledgment-Number）"><a href="#确认号（Acknowledgment-Number）" class="headerlink" title="确认号（Acknowledgment Number）"></a>确认号（Acknowledgment Number）</h2><p>TCP 使用确认号（Acknowledgment number, ACK）来告知对方下一个期望接收的序列号，小于此确认号的所有字节都已经收到。</p>
<p><img src="/assets/TCP%E7%A1%AE%E8%AE%A4%E5%8F%B7.jpg" alt="TCP确认号"></p>
<p>不是所有包都需要确认，例如 ACK 包就不需要（不然就死循环了）。</p>
<h2 id="TCP-Flags"><a href="#TCP-Flags" class="headerlink" title="TCP Flags"></a>TCP Flags</h2><p>TCP 有很多标记，比如三次握手就使用了 SYN 和 ACK 标记。</p>
<p>TCP Flags 是一个 8 bit 的 bitmap，每位代表一个状态，0 代表关闭，1 代表开启。</p>
<p>如图是第一次握手时，TCP Flags 部分的示意图，只有 SYN 标记置 1，其他标记都是 0。</p>
<p><img src="/assets/TCPFlags.jpg" alt="TCP Flags"></p>
<p>TCP 三次握手使用到了两个标记，SYN 和 ACK。SYN（Synchronize Sequence Numbers）代表同步序列号的意思，也就是要发起连接了；ACK（Acknowledge）代表确认。</p>
<p>常用的 TCP 标记的意义如下：</p>
<ul>
<li>SYN（Synchronize）：用于发起连接数据包同步双方的初始序列号</li>
<li>ACK（Acknowledge）：确认数据包</li>
<li>RST（Reset）：这个标记用来强制断开连接，通常是之前建立的连接已经不在了、包不合法、或者实在无能为力处理</li>
<li>FIN（Finish）：通知对方我发完了所有数据，准备断开连接，后面我不会再发数据包给你了。</li>
<li>PSH（Push）：告知对方这些数据包收到以后应该马上交给上层应用，不能缓存起来</li>
</ul>
<h2 id="窗口大小（Window-Size）"><a href="#窗口大小（Window-Size）" class="headerlink" title="窗口大小（Window Size）"></a>窗口大小（Window Size）</h2><p>TCP 使用滑动窗口的概念进行流量控制，如果发送端发送 TCP 包很快，接收端处理不过来，接收端就会先将 TCP 包缓存起来。接收方发送 ACK 响应时，会告诉发送方下一次自己能接收多少数据，这个值就是<strong>窗口大小</strong>。</p>
<p>窗口大小占 16 bit，最大能代表 65535 个字节（64 KB），这个值在 TCP 协议创建时很大，但如今就显得很小了。为了解决这个问题，TCP 引入了<code>窗口缩放</code>的概念，最多能够放大 2^14 倍。如下图所示，缩放因子为 7，则真正的窗口大小为 1050 * 128 = 134400。</p>
<p><img src="/assets/TCP%E7%AA%97%E5%8F%A3%E7%BC%A9%E6%94%BE.jpg" alt="TCP窗口缩放"></p>
<p>窗口缩放因子在三次握手时指定，在 TCP 头部信息的可选项中指定（可选项下面就会说）。</p>
<p>如果 Wireshark 没有抓到首次握手，也就不知道窗口缩放因子，是不知道真正的窗口缩放值是多少的。</p>
<h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><p><img src="/assets/TCP%E5%8F%AF%E9%80%89%E9%A1%B9.jpg" alt="TCP可选项"></p>
<p>可选项的格式如下图所示：</p>
<p><img src="/assets/TCP%E5%8F%AF%E9%80%89%E9%A1%B9%E6%A0%BC%E5%BC%8F.jpg" alt="TCP可选项格式"></p>
<p>以窗口缩放因子 Window scale 为例，kind=3，length=3，value=6</p>
<p><img src="/assets/TCP%E5%8F%AF%E9%80%89%E9%A1%B9%E7%A4%BA%E4%BE%8B.jpg" alt="TCP可选项示例"></p>
<p>常用的选项有以下几个：</p>
<ul>
<li>MSS：最大段大小选项，是 TCP 允许的从对方接收的最大报文段</li>
<li>SACK：选择确认选项</li>
<li>Window Scale：窗口缩放选项</li>
</ul>
<br>

<p>至此我们看完了 TCP 头部字段，接下来快速理顺一遍三次握手。</p>
<p><img src="/assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" alt="三次握手"></p>
<p>第一次握手：客户端给服务端发一个 TCP 报文，将 TCP Flags 中 SYN 标志置 1，并指明客户端的初始化序列号 ISN。</p>
<p>第二次握手：服务端给客户端发一个 TCP 报文，将 TCP Flags 中 SYN 标志置 1，指定服务端的初始化序列号 ISN，并将 TCP Flags 中 ACK 标志也置 1，确认序列号设置成第一次握手传来的客户端 ISN + 1，表示接收到第一次握手。</p>
<p>第三次握手：客户端给服务端发一个 TCP 报文，将 TCP Flags 中 ACK 标志置 1，确认序列号设置成第二次握手传来的服务端 ISN + 1，表示接收到第二次握手。</p>
<p>有一篇拓展阅读：《<a href="https://www.zhihu.com/question/271701044/answer/398114686" target="_blank" rel="noopener">关于三次握手和四次挥手，面试官想听到怎样的回答？</a>》。</p>
<hr>
<h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP 建立连接需要三次，但是断开连接需要四次，这是 TCP 的<code>半关闭</code>造成的。半关闭是指，不能发送，但还可以接收，保证自己不再发送 TCP 包，但是不确定对方是否也是，因此还可以一直接收对方的 TCP 包。</p>
<p>鉴于三次握手已经把 TCP 头部信息说明得比较清楚了，这里写四次挥手就简单过一下。</p>
<p><img src="/assets/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" alt="四次挥手"></p>
<p>第一次挥手：客户端给服务端发送一个 TCP 包，指定 TCP Flags 中的 FIN 标志为 1，该包消耗一个序列号。在此之后，客户端将不能给服务端发送 TCP 包（FIN 包重发不算）。</p>
<p>第二次挥手：服务端给客户端发送一个 TCP 包，指定 TCP Flags 中的 ACK 标志为 1，确认号是接收第一次挥手的 FIN 包的序列号 + 1。</p>
<p>服务端继续发送还没发送完的 TCP 包，发送完之后再第三次挥手。</p>
<p>第三次挥手：服务端给客户端发送一个 TCP 包，指定 TCP Flags 中的 FIN 标志为 1，该包消耗一个序列号。在此之后，服务端将不能给客户端发送 TCP 包（FIN 包重发不算）。</p>
<p>第四次挥手：客户端给服务端发送一个 TCP 包，指定 TCP Flags 中的 ACK 标志为 1，确认号是接收第三次挥手的 FIN 包的序列号 + 1。客户端等待 2 个 MSL 后关闭。</p>
<br>

<p>接下来回答几个细节问题：</p>
<h2 id="四次而不是三次"><a href="#四次而不是三次" class="headerlink" title="四次而不是三次"></a>四次而不是三次</h2><p>为什么一定需要四次握手，三次不行吗？</p>
<p>如果把四次缩减成三次，那就是把第二次挥手和第三次挥手合并（第一次、第四次是不能砍掉的），也就是服务端得知客户端要断开连接时，发送一个 TCP 包，同时携带 ACK（确认收到第一次挥手）和 FIN（告知服务端也要关闭了）信息。</p>
<p>但是服务端不一定立即就能发送 FIN 包，因为服务端可能还有 TCP 包没发送完。服务端要一直等到自己发送完了所有的 TCP 包，才能发送 FIN 包，如果把第二次和第三次挥手合并，就会导致 ACK（确认收到第一次挥手）可能发送得特别迟。从客户端角度观察就是，我这边发送了 FIN 包申请断开连接，结果迟迟没有收到回复，那只好不停地重发。</p>
<p>因此把四次挥手缩减成三次也不是不行，但是会有不停重发的代价，没有必要。</p>
<p>顺便提一下，建立连接时只需要三次握手，是因为服务端刚刚收到 SYN 包时，并没有任何还没发送的信息需要发送，因此不需要先确认收到，再申请建立连接。</p>
<h2 id="FIN-也需要占用一个序列号"><a href="#FIN-也需要占用一个序列号" class="headerlink" title="FIN 也需要占用一个序列号"></a>FIN 也需要占用一个序列号</h2><p>除了 ACK 之外，其他 TCP 包都需要占用序列号。</p>
<p>对于 FIN 而言，这是因为 FIN 也是需要确认的。如果 FIN 不占用序列号，客户端先发送了一个 TCP 包，再发送一个申请关闭连接的 FIN 包，那么接到 ACK 回复时，客户端并不知道这是确认哪一个 TCP 包的，有可能是确认最后发送消息的那个 TCP 包，也可能是确认 FIN 包的。</p>
<p>需要得到回复的 TCP 包，都需要占用序列号。</p>
<h2 id="标记-FIN-时其实也标记了-ACK"><a href="#标记-FIN-时其实也标记了-ACK" class="headerlink" title="标记 FIN 时其实也标记了 ACK"></a>标记 FIN 时其实也标记了 ACK</h2><p>第一次挥手和第三次挥手，发送的是 FIN 包，即 TCP Flags 中的 FIN 标志置为 1。</p>
<p>但如果用 wireshark 抓包的话，会发现在标记 FIN 为 1 时，也将 ACK 置为了 1：</p>
<p><img src="/assets/FIN%E5%92%8CACK%E5%90%8C%E6%97%B6%E6%A0%87%E8%AE%B0.jpg" alt="FIN和ACK同时标记"></p>
<p>查阅资料后发现：RFC793 明确规定，除了第一个握手报文 SYN 除外，其它所有报文必须将 ACK = 1。</p>
<p>因为 TCP 是通过确认机制，来保证消息可靠传输的。只有当 ACK = 1 时，TCP 头部的确认号才有效。但是这块区域是固定的，是省不掉一定会有的，空着也是空着，不如一直使用，每一次 TCP 报文都携带确认信息。</p>
<h2 id="等待-2-个-MSL"><a href="#等待-2-个-MSL" class="headerlink" title="等待 2 个 MSL"></a>等待 2 个 MSL</h2><p>MSL（Max Segment Lifetime）报文最大存活时间，是指 TCP 报文在网络中最大的生存时间。</p>
<p>这个概念还跟网络层（IP 层）有点关系，比如网络包从一个路由器到另一个，兜兜转转，一直都到不了目的地，为了避免资源浪费，引入了 TTL 和 MSL 的概念，总之代表的含义是一个报文最久能在网络中待多久。</p>
<p>换个角度看待这个概念：如果发送了一个网络包，那么过了一个 MSL 的时间之后，网络中必然不存在这个包，要不然已到达目的地，要不然就被消灭了。</p>
<p>第四次握手之后，客户端会等待 2 个 MSL 的时间，在这段时间之内客户端处于 TIME_WAIT 状态，还可以接收服务端发送来的信息，但是超过这个时间之后，连接就彻底断开了，再也不处理任何发送来的 TCP 包了。</p>
<p>等待 2 个 MSL 的时间有两个原因：</p>
<ol>
<li><p>以防第四次挥手 ACK 包没发送成功</p>
<p>如果客户端第四次挥手发送的 ACK 包没有发送成功，多等 2 个 MSL 的时间还能抢救一下：</p>
<p><img src="/assets/MSL%E9%87%8D%E4%BC%A0%E4%BD%9C%E7%94%A8.jpg" alt="MSL重传作用"></p>
</li>
<li><p>避免两次连接串了</p>
<p>如果没有多等 2 个 MSL 的过程，可能使两次连接的时间相隔很近，第二次连接接收到了第一次连接的 TCP 包。</p>
<p><img src="/assets/MSL%E4%B8%A4%E6%AC%A1%E8%BF%9E%E6%8E%A5%E4%B8%B2%E6%89%B0.jpg" alt="MSL两次连接串扰"></p>
</li>
</ol>
<hr>
<p>这篇文章就总结到这里。</p>
<p>写的过程中一直觉得自己写得不好，概括能力和表达能力都不行，还是学习来源《<a href="https://juejin.cn/book/6844733788681928712" target="_blank" rel="noopener">深入理解 TCP 协议：从原理到实战</a>》厉害，强烈推荐，写得真好。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>再探 AQS</title>
    <url>/2020/07/12/%E5%86%8D%E6%8E%A2-AQS/</url>
    <content><![CDATA[<br>

<p>七月的第二周，来学习 AQS，上次学习 AQS 是在四月份，这个月我们把它啃掉。</p>
<hr>
<p>复习一下 AQS 的基础，只简单地粘上来一些代码，具体的原理与设计可以回看四月份写的《从 lock 到 AQS 再到 ReentrantLock》。</p>
<p>AQS 中很重要的是数据结构和状态的设计，这一部分会反复地回来看，直到背过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 阻塞队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 阻塞队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 阻塞队列状态</span></span><br><span class="line">    <span class="comment">// 0：无节点  1：有节点持锁  &gt;1：有节点持重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AQS 阻塞队持有锁的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 的组成元素：节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以下是节点的四种状态：</span></span><br><span class="line">        <span class="comment">// 1(取消)、-1(可以唤醒后继节点)、-2(在 condition 队列中)、4(暂时略过)</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点状态</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="comment">// 在 AQS 阻塞队列中的前置节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="comment">// 在 AQS 阻塞队列中的后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 本节点本尊：线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="comment">// 在 condition 条件队列中的后一个节点</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来可以通过 ReentrantLock 来看 AQS 的基本框架了。</p>
<br>

<p>ReentrantLock 公平锁的上锁过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————————————————— 前戏 —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请一个公平锁</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FairSync lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— 申请锁的入口 —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS acquire</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 试着申请一下锁          没成功，加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        <span class="comment">// 本线程阻塞</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— tryAcquire —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FairSync 尝试获取锁</span></span><br><span class="line"><span class="comment"> * true:</span></span><br><span class="line"><span class="comment"> * - 1.AQS队列空，自己请求到了锁</span></span><br><span class="line"><span class="comment"> * - 2.锁重入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取【当前线程】和【AQS队列的状态】</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// state==0 -&gt; 没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 在AQS没有节点在等待的前提下（公平），尝试修改state，试图占有AQS</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 设置AQS锁的线程是自己</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// state!=0 且 当前线程就是AQS持有锁的线程 -&gt; 锁重入</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// 锁重入太多次，溢出了</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 锁重入次数 +1</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 判断队列中是否有节点在等待</span></span><br><span class="line"><span class="comment"> * true:</span></span><br><span class="line"><span class="comment"> * - 有头结点持锁，且队列中有节点在等，且队列最前面的节点不是自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 AQS 的 head 和 tail，并自定义一个节点</span></span><br><span class="line">    Node h = head, t = tail, s;</span><br><span class="line">    <span class="comment">// 头尾不同，且队列中有节点，而且队列中的最前面的那个节点不是自己</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— addWaiter —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 加入阻塞队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装成 AQS 的 Node，此时的 mode 是独占模式（Node.EXCLUSIVE）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 如果 tail 不为空，尝试把自己设成新的 tail</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS 将自己设为新的 tail，如果成功了，将旧的tail的后继节点设为自己</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果tail为null，或者CAS将自己设为新tail失败了</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS Node 构造方法其一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node(Thread thread, Node mode) &#123;</span><br><span class="line">    <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">    <span class="keyword">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 更新尾结点(CAS)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 常量 tailOffset</span></span><br><span class="line"><span class="comment"> * 由下面的AQS静态代码块可以看出，tailOffset是 tail 属性在 AQS 对象中的内存偏移量</span></span><br><span class="line"><span class="comment"> * 如果这个偏移量发生了改变，就说明 tail 发生了改变</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line">        headOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">        <span class="comment">// tailOffset看这里，这是查资料发现，是取内存偏移量</span></span><br><span class="line">        tailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">        waitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">"waitStatus"</span>));</span><br><span class="line">        nextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 加入AQS队列（尾插）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 采用CAS加入队列，不加进去不罢休</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 进入此方法有两种可能：tail为null(即AQS队列空) 或 曾经试过一次CAS设新tail</span></span><br><span class="line">        <span class="comment">// tail为空 -&gt; AQS队列为空 -&gt; 试着抢head</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// AQS中只有一个节点时，头就是尾</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// tail不为空 -&gt; AQS队列不为空 -&gt; 试着把自己设为新tail</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————— acquireQueued ———————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 判断是否需要阻塞线程</span></span><br><span class="line"><span class="comment"> * 所有没抢到线程的，全都汇聚于此</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取node的前驱节点（如果没有，空指针异常）</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是head，试着获取一次AQS锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 在此返回false，外层方法就会直接返回，不会阻塞当前线程</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前面这个方法：判断是否应该挂起线程              后面这个方法：挂起线程（唤醒也会在这里起来）</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 判断是否应当挂起线程（在没有抢到head的情况下）</span></span><br><span class="line"><span class="comment"> * 第一个参数是前驱节点，第二个参数是自己</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取前驱节点的state</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱节点的state是 -1，说明本节点之后会被唤醒，可以等了，直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 如果前驱节点的state&gt;0，说明前驱节点放弃了，使劲往前找，直到找到一个没有放弃的前驱结点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里很有趣</span></span><br><span class="line">        <span class="comment">// 我们从来没有为state赋值，因此前驱节点的state是0，我们为它设置为-1，让它好了后叫我们</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不应该挂起线程，出去，在外层方法继续CAS获取头节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 挂起线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 挂起线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 返回线程是否阻塞</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————————— */</span></span><br></pre></td></tr></table></figure>

<br>

<p>ReentrantLock 公平锁的解锁过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————————————————— 前戏 —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 申请一个公平锁</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock unlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— release —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS release 解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试解锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 解锁成功</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤起后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— tryRelease —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sync tryRelease 尝试解锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AQS state -1 即解锁后的 AQS state</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 非当前线程不能解锁</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 解锁后 state 是 0 则解锁成功，否则重入锁-1</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————— unparkSuccessor —————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 解锁成功后（非重入），唤起后继节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node的waitStatus，&gt;0 取消等待，0没有后继，&lt;0在ReentrantLock中代表需要唤醒后继</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 需要唤醒后继节点时，将本节点状态设为0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 后继节点如果不存在，或者存在但取消等待了</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 如果后继节点取消等待，那么从尾往前找，一路找到排在最前面正在等待的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时的节点，不是null，就是排在最前的非取消等待的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br></pre></td></tr></table></figure>

<br>

<p>道格李老爷子的代码，看起来确实有点吃力，我自己测试起了两个线程，debug 多遍，整理出下面这张图：</p>
<p><img src="/assets/AQS_ReentrantLock.jpg" alt="AQS_ReentrantLock"></p>
<p>这里只考虑了最简单的情况，没考虑抢锁、取消锁等情况（不过我觉得总体理解上还可以）。测试了多遍之后，觉得 AQS 类中的 acquireQueued() 方法很有趣，设计上非常精巧，循环运用得非常道格李。</p>
<p>下周我们来看 Condition 等类，争取下周把 AQS 框架看完。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>多机 Redis 的实现</title>
    <url>/2020/12/06/%E5%A4%9A%E6%9C%BA-Redis-%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<br>

<p>十二月的第一周，学习多机 Redis 的实现。</p>
<p>主要学习三个方面：复制、哨兵、集群，基本还是以《Redis 设计与实现》为来源学习，图片也来源于该书。</p>
<hr>
<p>多个 Redis 协同运行，最基础的内容是复制。</p>
<p>复制是指主从复制：一个主服务器，一个从服务器，从服务器的数据是主服务器复制过来的。使用 Redis 的 SLAVEOF 命令，就可以使一个服务器变成另一个服务器的从属服务器，不断从主服务器复制数据，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:12345&gt; SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<p>Redis 的复制有两部分：刚开始复制的全量复制（sync），以及在此之后不断的增量复制（command propagate）。</p>
<p>当从服务器发送 SLAVEOF 命令给主服务器后，首先会复制主服务器的全部数据，然后主服务每修改一条数据，都会将修改命令传播给从服务器，使从服务器不断地跟主服务器保持一致。</p>
<p>刚开始的全量复制，由从服务器发送 SYNC 命令发起，主服务器收到命令之后执行 BGSAVE 命令，在后台生成 RDB 文件，并发送给从服务器。这种方式有个问题，如果把 RDB 文件传送给从服务器中途断了，需要重来一遍，为此又有了 PSYNC 命令。</p>
<p>感觉这部分没什么意思，抄个复制的全流程，过了：</p>
<ol>
<li>从服务器设置主服务器的地址和端口</li>
<li>建立 socket 连接</li>
<li>从服务器 PING 主服务器</li>
<li>身份验证（主从要不然都验证，要不然都不验证）</li>
<li>从服务器发送端口信息，让主服务器可以发送信息</li>
<li>全量复制</li>
<li>增量复制（命令传播）</li>
</ol>
<hr>
<p>哨兵（Sentinel）是 Redis 的高可用解决方案之一，在 Redis 复制的基础上实现了自动化的故障恢复，可以参考博文《<a href="https://juejin.cn/post/6844903663362637832#heading-3" target="_blank" rel="noopener">深入剖析Redis系列(二) - Redis哨兵模式与高可用集群</a>》。</p>
<p>Redis 哨兵的最小配置是一主一从，执行期间会不断检查主服务器和从服务器是否正常运行，如果主服务器挂了，能够自动将一个从服务器升级为新的主服务器，并让其他从服务器指向它。</p>
<p><img src="/assets/Redis%E5%93%A8%E5%85%B5.jpg" alt="Redis哨兵"></p>
<h1 id="哨兵实例"><a href="#哨兵实例" class="headerlink" title="哨兵实例"></a>哨兵实例</h1><p>Redis 的哨兵系统中可以有一个或多个哨兵实例，每一个哨兵本质上是一个特殊的 Redis 服务器。</p>
<p>启动一个哨兵，最开始会创建一个 Redis 服务器，然后将代码替换成哨兵的专用代码，并根据配置文件初始化哨兵。</p>
<p>哨兵的配置文件，将设置哨兵监控的主服务器（可多个），哨兵初始化完成之后，将与主服务器建立连接，开始监控。</p>
<h1 id="哨兵监控"><a href="#哨兵监控" class="headerlink" title="哨兵监控"></a>哨兵监控</h1><p>在哨兵的配置文件中，只设置了主服务器的地址信息，没有设置从服务器的，例如（在 <code>sentinel.conf</code> 文件中配置）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel monitor master1 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>

<p>哨兵通过配置，首先监控主服务器，并获取到每个主服务器的从服务器，然后监控这些从服务器。</p>
<p>哨兵跟每个服务器之间都将建立两个连接：命令连接、订阅连接。</p>
<ul>
<li>命令连接是哨兵专门用来向主服务器发送命令、接收命令回复的连接，例如哨兵向服务器发送 <code>INFO</code>、<code>PING</code> 命令。</li>
<li>订阅连接是哨兵专门用于订阅主服务器的 <code>__sentinel__:hello</code>  频道的连接，例如当一个哨兵向服务器的  <code>__sentinel__:hello</code>  频道发送了一条消息，所有订阅了该频道的哨兵，都将收到这条消息。</li>
</ul>
<p>正常情况下，哨兵与服务器建立两种连接之后，会不停向服务器发送三种命令：</p>
<ul>
<li><code>INFO</code> 命令，十秒一次，用于获知服务器的信息</li>
<li><code>PING</code> 命令，一秒一次，用于心跳检测服务器是否存活</li>
<li><code>PUBLISH __sentinel_:hello ...</code> 命令，两秒一次，用于告知服务器和其他哨兵自己的存在（哨兵之间只建立命令连接，不建立订阅连接，哨兵之间通过 <code>__sentinel__:hello</code> 频道互相知道存在）</li>
</ul>
<h1 id="监控服务器故障恢复"><a href="#监控服务器故障恢复" class="headerlink" title="监控服务器故障恢复"></a>监控服务器故障恢复</h1><p>哨兵每秒 PING 一次服务器，以此为心跳监控服务器是否存活，如果一段时间 PING 不通服务器，会认为服务器出了故障（服务器下线）。</p>
<p>哨兵眼中有两种服务器下线，一种是主观下线，一种是客观下线：</p>
<ul>
<li><code>主观下线</code>：连续一段时间都 PING 不通服务器（超时时间在配置文件中配置），将服务器标记为<code>主观下线</code>。</li>
<li><code>客观下线</code>：如果认定<strong>主服务器</strong><code>主观下线</code>，为了确认它是否真的下线，会跟其他监视该服务器的哨兵通信，看其他哨兵是否也认为这个主服务器<code>主观下线</code>。如果有一定数量的哨兵（该数量也在配置文件中配置）都认定该主服务器<code>主观下线</code>，那么就可以认定这个主服务器真的下线了，即<code>客观下线</code>。</li>
</ul>
<p>当一个主服务器被判断为客观下线后，会着手选一个新的主服务器：</p>
<ol>
<li><p>从所有监视原来主服务器的哨兵中，选举出一个领头哨兵。</p>
<p>选举方式采用 Raft 协议，这是一个分布式协议，有个做得特别好的科普 Raft 的网站分享一下：《<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">Raft Understandable Distributed Consensus</a>》。</p>
</li>
<li><p>由领头哨兵从所有从服务器中，挑选出来一个从服务器（挑选算法有点麻烦，略），并将其转换为主服务器（发送 SLAVEOF no one 命令）。</p>
</li>
<li><p>向其他从服务器发送 SLAVEOF 命令，让它们复制新的主服务器。</p>
</li>
</ol>
<hr>
<p>Redis 哨兵实现了自动故障恢复，但无法实现读写的负载均衡。如果有多台 Redis 服务器，如何让 key-value 均衡地存储进多台服务器里，兼顾高可用和高性能，是 Redis 集群（Redis Cluster）关注的问题。</p>
<p>一个 Redis 集群由多个 Redis 服务器组成，每个 Redis 服务器被称为一个节点（Cluster Node），也就是多个节点构成一个集群。集群内部采用哈希槽的方式存放数据，例如整个集群预设 16384 个槽位，由 A、B、C 三个节点分占：</p>
<ul>
<li>节点 A 占用第 0 到第 5000 个槽位</li>
<li>节点 B 占用第 5001 到第 10000 个槽位</li>
<li>节点 C 占用第 10001 到第 16383 个槽位</li>
</ul>
<p>每个 key 通过 CRC16 校验后对 16384 取模，根据数值决定存放在哪个槽位中。例如 “msg” 经过 CRC16 校验后取模算出来 6257，最终会存储在第 6257 个槽位里，也就是在节点 B 中。</p>
<h1 id="每个节点的数据结构"><a href="#每个节点的数据结构" class="headerlink" title="每个节点的数据结构"></a>每个节点的数据结构</h1><p>有三个类：</p>
<ul>
<li>clusterNode：节点类</li>
<li>clusterLink：连接节点类</li>
<li>clusterState：集群状态类</li>
</ul>
<p>启动一个 Redis 服务器，如果配置开启集群模式（在 conf 文件中配置 cluster-enabled yes），那么这个 Redis 服务器在启动时就会成为一个集群节点（尽管此时只有它自己一个）。</p>
<p>这个节点在创建时，会实例化一个 clusterNode 对象，也就是它自己：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的名字，由40 个十六进制字符组成</span></span><br><span class="line">    <span class="comment">//例如68eef66df23420a5862208ef5b1a7005b806f2ff</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line">    <span class="comment">//使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span></span><br><span class="line">    <span class="comment">//以及节点目前所处的状态（比如在线或者下线）。</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的IP 地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它还会实例化一个 clusterLink 对象，用来保存和其他节点连接时的所需信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">//连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//输出缓冲区，保存着等待发送给其他节点的消息（message ）。</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有的话就为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">    </span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>

<p>该节点还会实例化一个 clusterState 对象，用于记录集群的整体信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群当前的状态：是在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群节点名单（包括myself 节点）</span></span><br><span class="line">    <span class="comment">//字典的键为节点的名字，字典的值为节点对应的clusterNode 结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>

<p>Redis 集群是分布式而非中心式的，并没有一个统一的中心管理器，而是在每个节点中，都存储着集群信息和其他节点信息。</p>
<p>如果节点 A 和节点 B 合并入同一个集群，节点 A 内部会创建一个 clusterNode 对象用来记录节点 B，同样节点 B 也会创建一个 clusterNode 对象用来记录节点 A，两个节点也都会各自更新 clusterState 对象（更新集群信息）。</p>
<p>通过任意一个节点，都可以获知整个集群的工作状况，以及其他联系到节点。</p>
<h1 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h1><p>如何把数据分布到集群中的多个节点，做到读写的负载均衡，是一个分布式系统的常见问题。数据分布有很多方案，例如顺序分布、哈希分布、一致性哈希、虚拟槽分区等，Redis 集群采用虚拟槽分区，也就是哈希槽。</p>
<p>哈希槽（槽 slot）中的槽位，是一个虚拟的概念，比如划分了 10000 个槽位，4 个节点各自分得 1000、2000、3000、4000 个槽位，之后通过计算哈希值在哪个槽里，就能知道数据应该存储在哪个节点里，这个过程不是真的需要槽位，槽只是个虚拟概念。</p>
<br>

<p>Redis 集群共设置了 16384 个槽位，不管有多少个节点，都是分这 16384 个槽。（16384 即 2^14，是 Redis 作者觉得合适的大小，跟数据传输和压缩比有关，具体原因自行谷歌）</p>
<p>当这 16384 个槽位没有被分完时，集群处于下线状态，只有当所有的槽都被分完，集群才能上线。</p>
<p>通过向节点发送 CLUSTER ADDSLOTS 命令，可以将一个或多个槽位指派给节点负责，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000</span><br></pre></td></tr></table></figure>

<p>节点处理好后，还会同步给集群内的其他节点，每个节点都会知道，哪个槽位由哪个节点负责。</p>
<ul>
<li>在 clusterNode 结构中，会存储本节点负责处理哪些槽（以位数组 bit array 的数据结构存储，省空间）。</li>
<li>在 clusterState 结构中，会存储每个槽位由哪个节点负责（长度为 16384 的节点数组，<code>clusterNode *slots[16384]</code>）。</li>
</ul>
<p>也就是说，每个节点同时存储了【自己负责的槽位】和【所有槽位由谁负责】。当查询 key 时可以直接查到负责的节点，当需要获取本节点负责哪些槽位时（例如槽重新分片）也可以直接返回。</p>
<br>

<p>计算 key 存储在哪个槽里，哈希算法是首先计算 key 的 CRC-16 校验和，然后再用该校验和对 16384 取模，计算出一个介于 0 至 16383 之间的数值，也就是槽位。这个哈希算法一行代码就可以实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CRC16(key) &amp; <span class="number">16384</span></span><br></pre></td></tr></table></figure>

<p>当读写一条 Redis 数据时，可以向任何一个节点发出命令，接到命令的节点将首先计算出槽位 <code>i</code>，再读取 clusterState 中存储的 <code>slots[i]</code>，得知该槽位由哪个节点负责。如果是自己负责，直接处理，如果是别的节点负责，返回 MOVED 错误，让客户端进行节点转向，转到正确的节点上重新执行命令（MOVED 错误是暗中进行的）。</p>
<br>

<p>哈希槽还可以由一个节点转给另一个节点，这被称为重新分片。这个过程是由 Redis 集群管理软件 redis-trib 来负责的，大致逻辑是找到每个槽的负责节点，一个槽一个槽地迁移。没意思，略了。</p>
<p>这周就写到这里吧。</p>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>单机 Redis 的实现</title>
    <url>/2020/11/19/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84-Redis-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<br>

<p>十一月的第四周，学习单机数据库下的 Redis 实现。</p>
<p>本文的主要内容和部分图片来源自《Redis 设计与实现》，该书的 Redis 版本是 3.0，粗浅学习一下。</p>
<hr>
<h1 id="Redis-数据库设计"><a href="#Redis-数据库设计" class="headerlink" title="Redis 数据库设计"></a>Redis 数据库设计</h1><p>Redis 服务器的属性都保存在 redisServer 类中，其中就包含数据库。</p>
<p>Redis 默认会创建 16 个数据库，以数组的形式保存在 RedisServer 中，数组的每一个元素都是一个 redisDb 对象，里面有 dict 属性，包含着所有键值对。</p>
<p><img src="/assets/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1605759405645.jpg" alt="Redis数据结构"></p>
<p>每一个 Redis 客户端都有自己的目标数据库，默认情况下会选择 0 号数据库，对数据的增删查改全部都在这一个数据库内进行。</p>
<p>客户端命令新增一条数据时，会在数据库（redisDb 类）中的 dict 字典中增加一个 key-value。</p>
<p>如果客户端需要设置键的过期时间，除了在 dict 字典中增加键值对，还会同时在 expires 字典中增加一个 key-value，value 是毫秒精度的 UNIX 时间戳，也就是过期时间。（Redis 过期时间在底层存储时，都是绝对时间）</p>
<hr>
<h1 id="Redis-的客户端和服务端"><a href="#Redis-的客户端和服务端" class="headerlink" title="Redis 的客户端和服务端"></a>Redis 的客户端和服务端</h1><p>Redis 是一对多服务器程序，即一个服务器可以与多个客户端建立网络连接。</p>
<p>服务端基于 I/O 多路复用，能够同时接受多个客户端的请求，然后将 socket 连接加入到队列当中，逐个处理，单线程单进程处理命令请求。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端以 redisClient 类的形式存在于 Redis 中，其中包括 name、fd 等通用属性，以及执行事务所需的 mstate 等特定功能属性。</p>
<p>所有客户端（redisClient 类对象）以链表的形式，存储在 redisServer 的 clients 属性中，即服务端可以获取到所有客户端。</p>
<p>通过 <code>client list</code> 命令可以获取到所有客户端信息（属性）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">id=6 addr=127.0.0.1:59038 fd=7 name= age=5 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=18446744073709537584 events=r cmd=client</span><br></pre></td></tr></table></figure>

<p>重要的客户端属性如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性作用</th>
</tr>
</thead>
<tbody><tr>
<td>fd</td>
<td>socket 文件描述符（-1 代表伪客户端，例如 AOF 文件还原）</td>
</tr>
<tr>
<td>name</td>
<td>名称，默认没有</td>
</tr>
<tr>
<td>flags</td>
<td>标志，记录客户端的角色和状态，可多个（如 REDIS_MULTI 代表客户端正在执行事务）</td>
</tr>
<tr>
<td>querybuf</td>
<td>输入缓冲区，记录所有客户端发来的所有命令（类型 SDS）</td>
</tr>
<tr>
<td>argv</td>
<td>最新一条命令的输入参数，数组（如 [“SET”, “key”, “value”]）</td>
</tr>
<tr>
<td>argc</td>
<td>argv 数组的长度</td>
</tr>
<tr>
<td>cmd</td>
<td>命令的实现函数（类型 redisCommand）</td>
</tr>
<tr>
<td>buf</td>
<td>输出缓冲区</td>
</tr>
<tr>
<td>bufpos</td>
<td>buf 已使用的字节数量</td>
</tr>
<tr>
<td>authenticated</td>
<td>身份验证（0 未通过，1 通过）</td>
</tr>
<tr>
<td>ctime</td>
<td>创建客户端的时间</td>
</tr>
<tr>
<td>lastinteraction</td>
<td>客户端与服务端最后一次互动的时间</td>
</tr>
<tr>
<td>obuf_soft_limit_reached_time</td>
<td>输出缓冲区第一次到达软性限制的时间</td>
</tr>
</tbody></table>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端在启动时，会依次执行如下内容：</p>
<ol>
<li>初始化服务器的状态结构，如 ID、运行频率、默认端口号等</li>
<li>载入 conf 配置文件</li>
<li>初始化服务器数据结构，如 db 数组</li>
<li>还原数据库持久化数据，开启 AOF 则使用 AOF 文件还原，没有则使用 RDB 文件还原</li>
<li>执行事件循环（loop），由事件驱动程序运行</li>
</ol>
<br>

<p>当一条命令请求，从客户端传送到服务端，整个过程可以概括如下：</p>
<ol>
<li><p>客户端发送请求，经编码后发送给服务器。</p>
<p>如发送 <code>SET key value</code> ，编码成 <code>*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$3\r\nvalue\r\n</code> 送达服务端。</p>
</li>
<li><p>服务端检测到 socket 可读，包装成事件交给命令请求处理器（这段过程详情参考下一节）</p>
</li>
<li><p>读取命令，处理后写入到 redisClient 属性中</p>
</li>
<li><p>查找命令函数（例如查找 SET 函数的实现）</p>
</li>
<li><p>调用命令函数</p>
</li>
<li><p>执行后续工作（例如写 AOF 缓冲区）</p>
</li>
<li><p>将命令回复发送给客户端</p>
</li>
</ol>
<hr>
<h1 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h1><p>Redis 服务器是一个事件驱动程序，来一个事件，处理一个事件，并且是单线程处理的。</p>
<p>Redis 有两类时间：文件事件、时间事件。</p>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>服务器通过 socket 与客户端连接，文件事件就是服务器对 socket 操作的抽象。</p>
<p>多个客户端与同一个服务端建立连接，会使用不同的 socket，服务端通过 I/O 多路复用器，将多个 socket 放到一个队列里面，有序、同步、逐个地向文件事件分派器传送 socket，这可以保证 Redis 以单线程处理网络请求。</p>
<p><img src="/assets/%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6.jpg" alt="文件事件"></p>
<p>最常见的事件是 AE_READABLE 事件（可读事件）和 AE_WRITABLE 事件（可写事件），例如客户端连接服务端，或对 socket 执行 write 操作时，就会触发可读事件，而客户端对 socket 执行 read 操作时，就会触发可写事件。</p>
<p>事件处理器有很多种，最常用的是连接应答处理器、命令请求处理器、命令回复处理器。</p>
<p>这些操作跟 netty 等网络框架的概念差不多，不详述了。</p>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><p>时间事件是 Redis 服务端对定时操作的抽象。</p>
<p>Redis 有两种时间事件：定时事件、周期性事件，在 Redis 3.0 版本时还没有使用定时事件。</p>
<p>Redis 服务器将所有的时间事件都放在一个链表当中，每个链表节点代表一个时间事件，记录着 id、when（执行时间，UNIX 时间戳）、timeProc（执行函数）。周期性事件会在执行时间事件之后，更新 when 时间戳。</p>
<p><img src="/assets/Redis%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6.jpg" alt="Redis时间事件"></p>
<p>一个典型的时间事件是 serverCron 函数，它会更新时间、内存占用，清理过期键、失效客户端等等。</p>
<p>时间事件并不一定会准确地在 when 时间戳执行，因为 Redis 主程序会先处理文件事件，再处理时间事件，因此时间事件的实际执行时间通常会比设定的执行时间稍晚一点。</p>
<hr>
<h1 id="Redis-的持久化"><a href="#Redis-的持久化" class="headerlink" title="Redis 的持久化"></a>Redis 的持久化</h1><p>Redis 有两种持久化机制，都可以将内存数据保存到硬盘中，并且能在重启后加载回内存。两种持久化机制分别是 RDB 和 AOF。</p>
<p>RDB 持久化是 Redis 的默认方式，它定期执行，将所有内存数据（键值对）保存成二进制文件。AOF 持久化会将 Redis 执行的写命令存储起来，重启 Redis 后执行所有命令来还原数据。</p>
<h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p>RDB（Redis Database）持久化会将 Redis 中的全部数据，以一定的数据结构，存储成一个二进制文件（RDB 文件）。</p>
<p>有两个 RDB 持久化的命令：<code>SAVE</code> 和 <code>BGSAVE</code> </p>
<ul>
<li><code>SAVE</code> 会阻塞 Redis 服务器进程，执行时 Redis 服务器会阻塞所有客户端发送的命令</li>
<li><code>BGSAVE</code> 执行时仍可继续处理客户端的命令，但会拒绝客户端 <code>SAVE</code> 和 <code>BGSAVE</code> 的命令，延迟 <code>BGREWRITEAOF</code> 命令。</li>
</ul>
<p>RDB 的存储过程是定期执行的（也可以手动触发），默认情况下有三种定时条件触发 <code>BGSAVE</code> 命令，配置在 conf 文件中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务器在 900 秒内，对数据库进行了至少 1 次修改</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 服务器在 300 秒内，对数据库进行了至少 10 次修改</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 服务器在 60 秒内，对数据库进行了至少 10000 次修改</span></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>上次 RDB 持久化的时间，以及又修改了多少次，都存储在 RedisServer 类对象的 lastsave 属性（UNIX 时间戳）和 dirty 属性（long long 类型的计数器）中。</p>
<p>由于 RDB 持久化是有时间间隔的，因此可能发生数据丢失，如果服务端宕机，上次 RDB 之后的命令都会丢失。</p>
<br>

<p>持久化后的 RDB 文件是一种以 <code>.rdb</code> 为后缀的二进制文件，默认命名 <code>dump.rdb</code> 储存在 Redis 根目录里。</p>
<p>RDB 文件有特定的数据结构，可以将所有数据库的所有键值对都存储下来，具体可以参考官方文档《<a href="https://github.com/sripathikrishnan/redis-rdb-tools/wiki/Redis-RDB-Dump-File-Format" target="_blank" rel="noopener">RDB 文件结构</a>》和《<a href="https://github.com/sripathikrishnan/redis-rdb-tools/blob/master/docs/RDB_Version_History.textile" target="_blank" rel="noopener">RDB 历代更新说明</a>》。</p>
<p><img src="/assets/RDB%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="RDB数据结构"></p>
<h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p>AOF（Append Only File）持久化会将 Redis 的所有写命令保存下来，默认不开启，如果开启，Redis 在重启后会优先选用 AOF 恢复。</p>
<p>AOF 默认命名 <code>appendonly.aof</code> 储存在 Redis 根目录里，内容是纯文本格式的，可以直接阅读。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SET msg <span class="string">"hello"</span></span><br><span class="line">SADD fruits <span class="string">"apple"</span> <span class="string">"banana"</span> <span class="string">"peach"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF文件存储的内容是（\r\n是回车换行）：</span></span><br><span class="line"><span class="comment"># *3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n</span></span><br><span class="line"><span class="comment"># *5\r\n$4\r\nSADD\r\n$6\r\n$5\napple\r\nbanana\r\n$5\npeach\r\n</span></span><br></pre></td></tr></table></figure>

<p>AOF 的存储分为两部分，一部分是内存，一部分是硬盘。内存累计一些数据之后，同步到硬盘当中，内存起到缓存的作用，能提高文件的写入效率。Redis 执行一条写命令时，AOF 相关操作如下：</p>
<ol>
<li>服务器执行完一条写命令</li>
<li>在 redisServer 对象中的 aof_buf 属性（SDS 字符串）的末尾，追加上这条命令</li>
<li>按照一定的逻辑，将 aof_buf 中的内容，同步到硬盘文件中。同步逻辑有三种：<ul>
<li>每次都同步</li>
<li>每秒同步一次（默认）</li>
<li>不同步，由操作系统来决定何时同步</li>
</ul>
</li>
</ol>
<p>由内存缓存，再同步到硬盘文件中，这种设计能提高写入效率，但可能会造成数据丢失。</p>
<br>

<p>AOF 有一个问题：随着命令的增多，AOF 文件的体积会不断膨胀，存储占用空间，还原所需的时间也很长。</p>
<p>在这种情况下，可以通过 <code>BGREWRITEAOF</code> 命令重写 AOF 文件。重写的逻辑是，将多条写命令等效成一条，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RPUSH list <span class="string">"A"</span> <span class="string">"B"</span></span><br><span class="line">RPUSH list <span class="string">"C"</span></span><br><span class="line">RPUSH list <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">LPOP list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上命令可以等效为一条命令：【RPUSH list "B" "C" "D" "E"】</span></span><br><span class="line"><span class="comment"># 存储在AOF文件中就是：【*6\r\n$5\r\nRPUSH\r\n$4\r\nlist\r\n$1\r\nB\r\n$1\r\nC\r\n$1\r\nD\r\n$1\r\nE\r\n】</span></span><br></pre></td></tr></table></figure>

<p>为避免阻塞，<code>BGREWRITEAOF</code> 重写在子进程中执行，但这样会带来脏写的问题：AOF 重写完一条 key-value 之后，这个 key-value 又修改了。</p>
<p>为解决这个问题，在 AOF 重写期间，所有的写命令除了需要写入 AOF 缓冲区（aof_buf）之外，还需要写入 AOF 重写缓冲区。</p>
<p>当子进程执行完 AOF 重写后，主进程将 AOF 重写缓冲区内的内容写入到新的 AOF 文件，再将新的 AOF 文件改名替换到原来的 AOF 文件，这样就可以避免脏写的问题。</p>
<hr>
<p>这周就学习到这里，还要学习多机 Redis 的实现，以及部分拓展功能。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/12/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<br>

<p>十二月的第四周，来学习正则表达式。</p>
<p>工作时经常需要用到正则表达式来校验字符串，每次遇到都怵怵的，这周来扫除一下盲区。</p>
<hr>
<p>正则表达式（regular expression），根据英文也可简写为 regex。“正则”这个中文翻译颇有民国风度，所谓公正而乎法则，今已查不到何处还在用此词，似乎只有编程领域在用。</p>
<p>正则表达式只用于字符串，用来检查字符串是否符合某种规定（例如只有字母、又例如没有数字等），或者是取出符合规定的字符串子串（用于后续替换等）。</p>
<p>例如下图，为匹配以 Hello 开头的字符串的正则表达式，成功匹配到了两条。</p>
<p><img src="/assets/1576558383714.png" alt="1576558383714"></p>
<p>（上图截图自 <a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a> 网站，是一个很好用的正则表达式在线测试网站）</p>
<p>此外再安利一组入门正则表达式的视频：<a href="https://www.bilibili.com/video/av18182693?from=search&seid=9361031783812248620" target="_blank" rel="noopener">《表严肃讲正则表达式》</a>，供入门使用。这组视频讲得很用心，不像大部分编程公开课跟倒泔水一样地倾泻几十个小时垃圾，我能感受到它是精心准备过的，很是喜欢。</p>
<br>

<hr>
<p>正则表达式的概念不难理解，若不清晰用过一两次便懂。使用正则表达式若有困难，都是因为语法繁多，需要记忆的内容量大。下面整理了三张正则表达式的常用语法字符表，主要来源为<a href="https://www.runoob.com/regexp/regexp-metachar.html" target="_blank" rel="noopener">菜鸟教程的正则表达式教程</a>。分三张表，分别是：</p>
<ul>
<li>非打印字符：转义后的字符，代表某一类字符</li>
<li>特殊字符：含特殊含义的字符</li>
<li>限定字符：字符次数限制</li>
</ul>
<h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
<th>正确示例</th>
<th>错误示例</th>
</tr>
</thead>
<tbody><tr>
<td>\w</td>
<td>数字、字母、下划线</td>
<td>1/a/A/_</td>
<td>./&amp;/の/【/<strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font></td>
</tr>
<tr>
<td>\W</td>
<td>除数字、字母、下划线以外</td>
<td>./&amp;/の/【/<strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font></td>
<td>1/a/A/_</td>
</tr>
<tr>
<td>\s</td>
<td>空白字符</td>
<td><strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>→|</strong><font color="#E0E0E0">(制表符)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font>/<strong>☇</strong><font color="#E0E0E0">(换页)</font></td>
<td>1/a/A/_/./&amp;/♂</td>
</tr>
<tr>
<td>\S</td>
<td>除空白字符以外</td>
<td>1/a/A/_/./&amp;/♂/张</td>
<td><strong>︹</strong><font color="#E0E0E0">(空格)</font>/<strong>→|</strong><font color="#E0E0E0">(制表符)</font>/<strong>ㄱ</strong><font color="#E0E0E0">(换行)</font>/<strong>☇</strong><font color="#E0E0E0">(换页)</font></td>
</tr>
<tr>
<td>\d</td>
<td>数字（单个）</td>
<td>1/2/3/4/5/6/7/8/9/0</td>
<td>a/?/&amp;/1234<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>\D</td>
<td>除数字以外</td>
<td>a/B/,/%/张/<strong>︹</strong><font color="#E0E0E0">(空格)</font></td>
<td>1/2/3/1234<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
<td><strong>ㄱ</strong><font color="#E0E0E0">(换行)</font></td>
<td>1/a/A/_/?</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
<td><strong>→|</strong><font color="#E0E0E0">(制表符)</font></td>
<td>1/a/A/_/?</td>
</tr>
</tbody></table>
<br>

<h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
<th>正确示例</th>
<th>错误示例</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>除换行以外任意字符</td>
<td>1/a/A/%/_</td>
<td><strong>ㄱ</strong><font color="#E0E0E0">(换行)</font>/123<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>^</td>
<td>从字符串开始的位置处匹配</td>
<td>^12 -&gt; 12/12<font color="#E0E0E0">3</font>/12<font color="#E0E0E0">a</font></td>
<td>^12 -×-&gt; a12/abc12/</td>
</tr>
<tr>
<td>$</td>
<td>从字符串结束的位置处匹配（倒着）</td>
<td>12$ -&gt; 12/<font color="#E0E0E0">abc</font>12/<font color="#E0E0E0">0</font>12</td>
<td>12$ -×-&gt; 123/12aaa</td>
</tr>
<tr>
<td>|</td>
<td>或</td>
<td>[1|2|3] -&gt; 1/2/3</td>
<td>[1|2|3] -×-&gt; a/4/&amp;</td>
</tr>
<tr>
<td>[]</td>
<td>方框运算符，字符集合/范围/反向</td>
<td></td>
<td></td>
</tr>
<tr>
<td>()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>{}</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<br>

<h2 id="限定字符"><a href="#限定字符" class="headerlink" title="限定字符"></a>限定字符</h2><table>
<thead>
<tr>
<th>限定字符</th>
<th>描述</th>
<th>正确示例</th>
<th>错误示例</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配零个、一个或多个字符</td>
<td>12*3 -&gt; 13/123/1223</td>
<td>12*3 -×-&gt; 1</td>
</tr>
<tr>
<td>+</td>
<td>匹配一个或多个字符</td>
<td>12+3 -&gt; 123/12223</td>
<td>12+3 -×-&gt; 13</td>
</tr>
<tr>
<td>?</td>
<td>匹配零个或一个字符</td>
<td>12?3 -&gt; 13/123</td>
<td>12?3 -×-&gt; 12223</td>
</tr>
<tr>
<td>{n}</td>
<td>字符限定n次</td>
<td>2{4} -&gt; 2222</td>
<td>2{4} -×-&gt; 222/22222<font color="#E0E0E0">(整体)</font></td>
</tr>
<tr>
<td>{n,}</td>
<td>字符限定最少n次</td>
<td>2{2,} -&gt; 22/222/22222</td>
<td>2{2,} -×-&gt; 2</td>
</tr>
<tr>
<td>{n,m}</td>
<td>字符限定n-m次</td>
<td>2{2,3} -&gt; 22/222</td>
<td>2{2,3} -×-&gt; 2/2222<font color="#E0E0E0">(整体)</font></td>
</tr>
</tbody></table>
<br>

<hr>
<p>除以上常用的语法字符之外，还有以下规则，需要单独注意：</p>
<h2 id><a href="#" class="headerlink" title="[ ]"></a>[ ]</h2><p>方括号表示字符集合，可配合 ^ 符合表示反向的字符集合，常见用法有：</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[12a]</td>
<td>可匹配 ‘1’ 或 ‘2’ 或 ‘a’</td>
</tr>
<tr>
<td>[1|2|a|,]</td>
<td>可匹配 ‘1’ 或 ‘2’ 或 ‘a’ 或 ‘,’</td>
</tr>
<tr>
<td>[1-9]</td>
<td>可匹配 ‘1’ 或 ‘2’ 或 …… 或 ‘9’</td>
</tr>
<tr>
<td>[a-z]</td>
<td>可匹配 ‘a’ 或 ‘b’ 或 …… 或 ‘z’</td>
</tr>
<tr>
<td>[^12a]</td>
<td>可匹配除了 ‘1’ 或 ‘2’ 或 ‘a’ 以外的字符</td>
</tr>
<tr>
<td>[^1-9]</td>
<td>可匹配除了 ‘1’ 或 ‘2’ 或 …… 或 ‘9’ 以外的字符</td>
</tr>
</tbody></table>
<br>

<h2 id="-1"><a href="#-1" class="headerlink" title="()"></a>()</h2><p>圆括号代表同时匹配多个字符，如匹配 <code>hello</code> 这五个字符，可以使用 <code>(hello)</code> 来匹配。</p>
<p>但是除此之外，() 匹配到的字符串还会被缓存起来，缓存起来的子表达式可以在之后使用。</p>
<p>例如使用<code>([nN]o)</code>匹配 <code>No, get out!</code>，不光能匹配到 <code>No</code>，还能通过 <code>$1oooooooo</code> 将原文替换成 <code>Nooooooooo, get out!</code>。</p>
<table>
<thead>
<tr>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(hello)</td>
<td>可以匹配 “hello”，并缓存起来</td>
</tr>
<tr>
<td>(?:hello)</td>
<td>可以匹配 “hello”，但不缓存结果<br>（用于匹配多字符但并不需要结果，有时能让正则表达式更简洁）</td>
</tr>
<tr>
<td>hello(?=AA)</td>
<td>可以匹配 “helloAA……” 中的 “hello”，但是不能匹配 “helloBB……” 中的 “hello”，且不缓存结果</td>
</tr>
<tr>
<td>hello(?!AA)</td>
<td>不能匹配 “helloAA……” 中的 “hello”，但是可以匹配 “helloBB……” 中的 “hello”，且不缓存结果</td>
</tr>
<tr>
<td>(?&lt;=AA)hello</td>
<td>可以匹配 “AAhello……” 中的 “hello”，但是不能匹配 “BBhello……” 中的 “hello”，且不缓存结果</td>
</tr>
<tr>
<td>(?&lt;!AA)hello</td>
<td>不能匹配 “AAhello……” 中的 “hello”，但是可以匹配 “BBhello……” 中的 “hello”，且不缓存结果</td>
</tr>
</tbody></table>
<br>

<h2 id="贪婪"><a href="#贪婪" class="headerlink" title="贪婪"></a>贪婪</h2><p>贪婪是编程和算法中常见的概念，意思是越多越好。</p>
<p>* 和 + 这两个限定符都是贪婪的，如果用 <code>hello*</code> 或者 <code>hello+</code> 来匹配 <code>hellooooooo</code>，它们的匹配结果都是 <code>hellooooooo</code>，而不是 <code>hell</code>、 <code>hello</code> 或 <code>hellooo</code> 或是其他的。</p>
<p>在 * 和 + 后面加上 ? 就可以使匹配结果是非贪婪的（最小匹配）。按照上面的例子，<code>hello*?</code> 匹配的结果是 <code>hell</code>，<code>hello+?</code> 匹配的结果是 <code>hello</code>。</p>
<br>

<hr>
<p>写几个看到过的正则表达式，举几个例子</p>
<ul>
<li><p>身份证校验（简易版）</p>
<p><code>^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$</code></p>
</li>
<li><p>不能包含数字</p>
<p><code>^[^\d]+$</code></p>
</li>
<li><p>浮点数</p>
<p><code>^(-?\d+)(\.\d+)?$</code></p>
</li>
<li><p>域名</p>
<p><code>^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</code></p>
</li>
<li><p>数字（包含负数、小数）</p>
<p><code>^-?[0-9]+(\.[0-9]+)?$</code></p>
</li>
</ul>
<br>

<hr>
<p>学习过正则表达式的基本语法之后，感觉在工作中还是不够用，还要学习 Java 中正则表达式的使用。</p>
<p>正则表达式从 JDK 1.4 之后出现，涉及到两个新类：Pattern 和 Matcher。Pattern 类代表一个正则表达式，而 Matcher 类代表一个正则表达式对一个字符串进行校验后的结果，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式，规则：不能包含数字</span></span><br><span class="line">String regex = <span class="string">"^[^\\d]+$"</span>;</span><br><span class="line">Pattern compile = Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配abcABC?&amp;</span></span><br><span class="line">String str = <span class="string">"abcABC?&amp;"</span>;</span><br><span class="line">Matcher matcher = compile1.matcher(str);</span><br></pre></td></tr></table></figure>

<p>Pattern 类没有（对外的）构造方法，因此生成一个 pattern 对象只能通过 Pattern 类的静态方法。</p>
<p>如果只是想检验字符串是否符合要求（即只需要一个boolean值），那么使用 Pattern 类的静态方法就可以，pattern 对象是为了更多操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String regex = <span class="string">"^[^\\d]+$"</span>;</span><br><span class="line">String str = <span class="string">"abcABC?&amp;"</span>;</span><br><span class="line"><span class="keyword">boolean</span> pass = Pattern.matches(regex, str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------结果：pass:true</span></span><br></pre></td></tr></table></figure>

<p>Pattern 类多实现一些，用代码实现正则表达式的功能，而不是完全只用字符串来实现。例如它能指定正则表达式可以同时匹配大小写字母（指定后，正则表达式字符串即使只有 ‘a’，匹配时也可以同时匹配 ‘a’ 和 ‘A’），又或者可以用指定正则表达式分隔字符串，例如将一串带有数字的字符串，以数字为分隔拆分成多个子字符串。</p>
<p>Matcher 类多实现一些对匹配结果的处理，这一部分具体没怎么看，需要时再补吧。</p>
<p>最后提一句，Java 中使用正则表达式时，基本上要出现 <code>\</code> 的地方，都要转义成 <code>\\</code>，例如 <code>\d</code> -&gt; <code>\\d</code>。</p>
<p>本周就学习到这里了。</p>
<br>

<hr>
<blockquote>
<p>2020-03-08 补</p>
<p>发现平常在 Java 中使用 Pattern 类和 Matcher 类还是很频繁的，之前学习得不细致，得回来补一下。</p>
</blockquote>
<h1 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h1><p>Pattern 类可以理解成是正则表达式，可以使用 Pattern 对象来对字符串进行正则校验。</p>
<p>不能通过 new 来创建 Pattern 对象，只能通过 Pattern 类的静态方法创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">"\\w"</span>); <span class="comment">// 正则表达式：单个数字、字母或下划线</span></span><br></pre></td></tr></table></figure>

<p>日常使用 Pattern 类有两个用途：</p>
<ol>
<li><p>直接校验字符串，返回 true/false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验是否是qq邮箱</span></span><br><span class="line">String regex = <span class="string">"^\\w*@qq.com$"</span>;</span><br><span class="line"><span class="keyword">boolean</span> matches = Pattern.matches(regex, <span class="string">"hellopz@qq.com"</span>);</span><br></pre></td></tr></table></figure>

<p>这里有一处暗坑，校验成功要求<code>全部匹配</code>，如果是部分匹配，那么返回值将是 false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> matches1 = Pattern.matches(<span class="string">"[0-9]"</span>, <span class="string">"123"</span>);   <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> matches2 = Pattern.matches(<span class="string">"[0-9]*"</span>, <span class="string">"123"</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成一个校验过的结果，返回 Matcher 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式：是否是数字</span></span><br><span class="line">String regex = <span class="string">"[0-9]*"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成对"123"校验的结果（结果是一个Matcher对象）</span></span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure>

<p>Matcher 对象能做更多的事情，比如部分校验、取出校验结果等。</p>
</li>
</ol>
<p>Pattern 类的其他使用，例如指定正则模式 flag、分割字符串的 split() 方法（我好像觉得跟 String 对象的 split() 方法 没有任何区别？），感觉都不实用，不写了。</p>
<h1 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h1><p>Matcher 类可以理解成经过校验的字符串的校验结果，可以通过该对象处理校验结果。</p>
<p>Matcher 对象由 Pattern 对象的 matcher() 方法获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pattern表示正则表达式，方法内传入待校验的字符串</span></span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"wait to check"</span>);</span><br></pre></td></tr></table></figure>

<p>日常使用 Matcher 类也是两个用途：</p>
<ol>
<li><p>检查字符串中是否含正则校验内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验是否包含数字</span></span><br><span class="line">Matcher matcher1 = Pattern.compile(<span class="string">"[0-9]"</span>).matcher(<span class="string">"12345"</span>);</span><br><span class="line"><span class="keyword">boolean</span> contains = matcher.find();  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>请注意理解 find() 方法的语义，find 的意思是找到了，并不代表完全匹配，换言之只需要字符串中有正则内容就可以。因此使用 matcher.find() 和 Pattern.matches() 是不等价的。</p>
</li>
<li><p>取出正则校验结果</p>
<p>这里有一个需要先指出的暗坑：在取结果之前，必须先执行 Matcher 对象的 find() 方法，如果不执行，将抛出 <code>IllegalStateException</code> 异常：<code>No match found</code> （没找到匹配结果）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则表达式：数字(字母)数字(字母)数字(字母)</span></span><br><span class="line">Matcher matcher = Pattern.compile(<span class="string">"\\d+([a-z])\\d+([a-z])\\d+([a-z])"</span>).matcher(<span class="string">"111a111b111c"</span>);</span><br><span class="line"><span class="keyword">boolean</span> find = matcher.find();      <span class="comment">// true</span></span><br><span class="line">String result = matcher.group();    <span class="comment">// 111a111b111c</span></span><br><span class="line">String result0 = matcher.group(<span class="number">0</span>);  <span class="comment">// 111a111b111c</span></span><br><span class="line">String result1 = matcher.group(<span class="number">1</span>);  <span class="comment">// a</span></span><br><span class="line">String result2 = matcher.group(<span class="number">2</span>);  <span class="comment">// b</span></span><br><span class="line">String result3 = matcher.group(<span class="number">3</span>);  <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p>使用 group() 方法可以捕获到正则结果，如果正则表达式中有<code>( )</code>括起来的内容，这部分内容可以取出来。</p>
<p>有两种常用的 group() 方法，一种是传入 int 值的 group(int group) 方法，另一种是无参的 group() 方法。</p>
<ul>
<li><p>带 int 参数的 group() 方法，参数为 0 时代表整个表达式，为 1 时代表匹配到的第 1 个<code>( )</code>内容，为 2 时代表匹配到的第 2 个<code>( )</code>内容……以此类推，正如上面的代码示例。</p>
<p>如果参数是 n，但是实际上并没有 n 个匹配内容，会抛出 <code>IndexOutOfBoundsException</code> 异常。</p>
</li>
<li><p>无参的 group() 方法实际上就是 group(0)，代表整个表达式。</p>
</li>
</ul>
<p>此外还可以通过 groupCount() 方法获取匹配到<code>( )</code>的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...延续上面的代码</span></span><br><span class="line"><span class="keyword">int</span> count = matcher.groupCount();  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>

<p>Java 的正则表达式写到这里应该就可以了，足够日常用了。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：回溯</title>
    <url>/2020/04/12/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9B%9E%E6%BA%AF/</url>
    <content><![CDATA[<br>

<p>四月的第二周，开始学习算法题：回溯算法。</p>
<p>在二月底就零星地看了一些算法题，当时想着从四月份开始突击一个月的算法，但因为看 Java 并发耽误了一周。从本周开始，博文内容将全部是算法。</p>
<hr>
<p>回溯（backtracking）是暴力搜索法中的一种，它采用试错的思想，尝试分布地解决一个问题，在分步解决问题的过程中，当它通过尝试，发现现有的分步答案不能得到有效的正确解答时，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</p>
<p>回溯是基于深度优先遍历（DFS）的一种暴力搜索方法，因此使用回溯算法的前提是，问题本身的数据结构是树，在树的基础上采取 DFS 的方式遍历，在遍历的过程中，保存符合题目条件的叶子节点。</p>
<p>举一个例子，比如全排列问题（给定几个数字，返回所有可能的全排列），这个问题本身就是一棵树，以[1, 2, 3]这三个数字为例，可以画成如下的树。这一类的问题我们可以通过回溯算法解决。</p>
<p><img src="/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg" alt="树示例"></p>
<p>回溯算法的内核是遍历，如果一个问题能够转化为树，就可以通过回溯算法，遍历树的每一片叶子，暴力解决。在这一背景之下，回溯算法还有以下特征：</p>
<ol>
<li>遍历树的方式是递归，因此回溯是通过递归解决的。</li>
<li>遍历树时，收集叶子（收集结果）往往有约束，比如要求结果不能重复（[1, 2]和[2, 1]只保留其中一个），收集时要根据要求收集。</li>
<li>遍历树时，在知道某些分支下一定不可能出现结果，就可以忽略遍历这部分，这被称为“剪枝”，是回溯算法提高性能的主要方式。</li>
</ol>
<br>

<p>下面试着整理一下套路，但是就我个人经验而言，背过了套路也用处不大，多做一点题目就会慢慢熟悉起来。推荐的做题路线是（使用 LeetCode），39 题 -&gt; 46 题 -&gt; 77 题 -&gt; 78 题 -&gt; 40 题 -&gt; 47 题 -&gt; 90 题，都比较简单，是用来培养手感的。</p>
<p><strong>先铭记最重要的一条，做回溯算法题，第一步，先画树，画完了再做题。</strong></p>
<p>回溯算法的主要流程是：试探 - 子递归 - 回溯。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">doSub(list, ...)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    list.add(item);               <span class="comment">// 试探着加入一个元素</span></span><br><span class="line">    doSub(list, ...);             <span class="comment">// 子递归</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>); <span class="comment">// 把刚才试探加入的元素删掉</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是先加入一个元素，执行子递归操作，再删除掉刚才加的元素。这个套路我们一会在真题中使用。</p>
<p>初学时由于递归使用得少，因此对递归的结构、递归的方法参数，通常会苦恼很久。在初始阶段，可以试着这么写递归：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最终的结果可以记在全局变量中，不设置返回值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSub</span><span class="params">(List candidates, <span class="keyword">int</span> level, Object tem)</span> </span>&#123;</span><br><span class="line">                           成员         递归层数    本级递归的结果</span><br><span class="line">                               </span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (成功条件，准备记录结果) &#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        doSub(candidates, level + <span class="number">1</span>, tem);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常递归需要三个参数：操作的所有元素、递归的层数（通常用于判断什么时候要终止递归）、本级递归的结果（成功后，将参数记录下来）。这么写可能会有冗余代码（ if 的判断条件），但是按照这种思路来写，通常能写出来递归的骨架，然后再慢慢调整。</p>
<p>除了这三个参数之外，通常递归还需要其他参数，这个需要具体分析。就我做题而言，一般是需要增加两种参数，一会做题时详述。</p>
<br>

<h1 id="LeetCode39-组合总和"><a href="#LeetCode39-组合总和" class="headerlink" title="LeetCode39 组合总和"></a>LeetCode39 组合总和</h1><blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p>
<table>
<thead>
<tr>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td>candidates = [2,3,6,7], target = 7</td>
<td>[<br>&nbsp;&nbsp;[7],<br>&nbsp;&nbsp;[2,2,3]<br>]</td>
</tr>
<tr>
<td>candidates = [2,3,5], target = 8</td>
<td>[<br>&nbsp;&nbsp;[2,2,2,2],<br>&nbsp;&nbsp;[2,3,3],<br>&nbsp;&nbsp;[3,5]<br>]</td>
</tr>
</tbody></table>
</blockquote>
<p>先画树（其实只需要画出终止条件和满足条件就足够分析了）：</p>
<p><img src="/assets/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.jpg" alt="组合总和"></p>
<p>主要的逻辑是递归树</p>
<ul>
<li>如果求和不足，那么继续递归</li>
<li>如果求和正好，那么记录结果，返回（返回后删除，进行下一次循环）</li>
<li>如果求和超了，那么返回（返回后删除，进行下一次循环）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode39</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combinationSum方法返回的是什么，就直接在此定义一个该类型的变量，作为全局变量，最后直接返回该变量就可以了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 很多算法题的测试数据都会搞些数据恶心人，比如输入参数为空字符串，要预过滤</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == candidates || candidates.length == <span class="number">0</span> || target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 核心逻辑，本方法是一个无返回值的方法，因为结果记录在一个全局变量result里，省去了处理返回</span></span><br><span class="line">        process(candidates, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释一下核心逻辑，每进入下一层树，在list中增加一个数字，再进入下一层递归</span></span><br><span class="line">    <span class="comment">// 直到求和相同时，记录求和内容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步：先处理递归终止条件，此题是判断</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 第二步：当递归抵达成功时，记录结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意深拷贝</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="comment">// 第三步：当递归没终止、没成功，准备进入下一层递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 先加</span></span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                process(candidates, target - candidates[i], list);</span><br><span class="line">                <span class="comment">// 再删，删完出循环，准备再进循环加下一个</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是基础套路：</p>
<ol>
<li><p>定义一个全局变量记录结果</p>
</li>
<li><p>递归处理</p>
<ol>
<li><p>先处理递归终止，直接返回</p>
</li>
<li><p>再处理递归成功，记录结果后返回</p>
</li>
<li><p>没终止、没成功，就意味着还需要继续递归</p>
<p>在循环中执行回溯算法的核心</p>
<ol>
<li>先加</li>
<li>递归</li>
<li>再删</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>执行上述方法，得到这样的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LeetCode39.combinationSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 结果 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]</span></span><br></pre></td></tr></table></figure>

<p>会发现结果没有去重，出现了[2, 2, 3]和[2, 3, 2]这样内容一样但是排序不一样的情况，我们来分析一下如何去重。</p>
<p>重复的主要原因在于，当我们记录完[2, 2, ?]之后，进入[2, 3, ?]，选择第三个数时，我们不应当再考虑 2 了，因为在[2, 2, ?]的情况下，我们已经全部处理完有 2 的情况了，再之后我们不应该处理 2 了。细琢磨一下这句话：遍历时我们要设置一个起始点，处理过的要素，之后就跳过不参与考虑了。</p>
<p>这是递归新增参数的第一种情况，增加一个 <code>int start</code> 的参数，目的是为了在遍历时，从 start 位置开始，跳过某些元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">    <span class="comment">// 每次遍历从start开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="LeetCode46-全排列"><a href="#LeetCode46-全排列" class="headerlink" title="LeetCode46 全排列"></a>LeetCode46 全排列</h1><blockquote>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<table>
<thead>
<tr>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td>[1,2,3]</td>
<td>[<br>&nbsp;&nbsp;[1,2,3],<br>&nbsp;&nbsp;[1,3,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[2,3,1],<br>&nbsp;&nbsp;[3,1,2],<br>&nbsp;&nbsp;[3,2,1]<br>]</td>
</tr>
</tbody></table>
</blockquote>
<p>同样，还是先画递归树：</p>
<p><img src="/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg" alt="树示例"></p>
<p>直接写代码了噢，是完全一样的套路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode46</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == nums || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] select = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        doPermute(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), select);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> level, List&lt;Integer&gt; list, <span class="keyword">boolean</span>[] select)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &gt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (select[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    select[i] = <span class="keyword">true</span>;</span><br><span class="line">                    doPermute(nums, level + <span class="number">1</span>, list, select);</span><br><span class="line">                    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    select[i] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里递归在原先的三个参数基础上，又增加了一个新的参数，<code>boolean[] select</code>，一个布尔值的数组。</p>
<p>对于某些题目，就比如这道题，每个元素并不是可以无限使用的，而是只能只用一次，如果使用完一次，怎么标记下来呢，就是使用一个布尔值的数组，记录下标为x的元素，已经被使用过了，不能再使用。</p>
<p>回溯套路，就从原来的三行，变成了五行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(nums[i]);                   -&gt;   list.add(nums[i]);</span><br><span class="line">                                     -&gt;   select[i] = <span class="keyword">true</span>;</span><br><span class="line">doPermute(nums, level + <span class="number">1</span>, list);    -&gt;   doPermute(nums, level + <span class="number">1</span>, list, select);</span><br><span class="line">                                     -&gt;   select[i] = <span class="keyword">false</span>;</span><br><span class="line">list.remove(list.size() - <span class="number">1</span>);        -&gt;   list.remove(list.size() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>（上一道题每个元素可以无限制地使用，因此不需要一个布尔值数组记录是否能使用）</p>
<br>

<p>上面的套路，只是初期不熟悉时的套路，并不能解决所有回溯问题，但是可以在初接触回溯问题时尝试做出来。最好的学习方式仍然是做题，做十几道题，就自然明白了。再发一遍学习路线（LeetCode）：39 题 -&gt; 46 题 -&gt; 77 题 -&gt; 78 题 -&gt; 40 题 -&gt; 47 题 -&gt; 90 题。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus 监控方案简述</title>
    <url>/2020/09/18/Prometheus-%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<br>

<p>最近两个月，在业务上做了很多监控相关的工作，最终选用了以 Prometheus 为中心的监控解决方案。其实真正的工作也没做多少，因为腾讯云最近灰度上线了 Prometheus 监控服务，我们基本是在使用腾讯云的工作成果。而我主要的工作内容，一是广泛调研监控工具，判断是否适合当下业务场景，二是负责实际落地。</p>
<p>本文写得比较零散，总体上说明了三件事情：</p>
<ol>
<li>市面上可选用的监控方案有什么</li>
<li>以 Prometheus 为主的监控方案是怎样的</li>
<li>如何使用腾讯云 Prometheus 服务进行监控</li>
</ol>
<hr>
<h1 id="概念-amp-名词"><a href="#概念-amp-名词" class="headerlink" title="概念 &amp; 名词"></a>概念 &amp; 名词</h1><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><p>APM （Application Performance Management）应用性能管理，简单理解就是监控。</p>
<p>APM 是项系统工程，包括监控数据的<code>收集</code>、<code>存储</code>、<code>处理</code>、<code>告警</code>，通常也包含<code>可视化展示</code>。监控的内容同样包含方方面面，从整体来讲包含<code>基础设施监控</code>（比如云容器、机房硬件整体表现）和<code>业务监控</code>（比如接口调用次数、JVM 表现）。</p>
<p>举一个切实的例子：比如我想知道，最近一周哪个接口调用的次数最多。我们可以拆分成以下问题：</p>
<ol>
<li>数据收集：所有的接口每被调用一次，就要各自计数一次</li>
<li>数据存储：接口调用次数保存在哪里</li>
<li>数据处理：截取一周的时间，对接口调用次数进行倒序排序</li>
<li>可视化展示：以图表的形式，展示在前端</li>
<li>（也许）告警：某个接口在一周内调用了 100 亿次，需要向管理员发送邮件/短信警告</li>
</ol>
<br>

<p>市面上的 APM 工具（解决方案）主要有以下几种：</p>
<ul>
<li><p>ELK</p>
<p>Elasticsearch + Logstash + Kibana，这三个开源项目的首字母缩写。这三个项目各自的作用是<code>带搜索功能的数据库</code>、<code>采集数据，转换数据</code>、<code>可视化</code>，加起来是一整套 APM 解决方案。具体可以参考官网《<a href="https://www.elastic.co/cn/what-is/elk-stack" target="_blank" rel="noopener">什么是 ELK Stack？</a>》。</p>
<p>这一整套功能很全，但是也比较重，它基于日志的方式存储和处理数据，存储量很大，性能消耗也大（但同时功能也是最强的）</p>
</li>
<li><p>Skywalking</p>
<p>这是一个国人做的项目，是 Apache 的顶级毕业项目。</p>
<p>它的核心功能是分布式服务追踪，可以查出一个请求，从哪里被调用，中转了哪些微服务，使用了哪里的 Redis、MySql、MongoDB，以及最重要的：分别耗费了多长时间。它在分布式架构中表现非常卓越，通过它可以知道到底是哪里性能瓶颈大（比如某条 sql 数据库查询时间很长），但是在单体应用中作用不大。它支持 WebFlux，但是支持得比较一般。</p>
<p>SkyWalking 不负责数据的存储，因此需要单独找一套数据库，比如 H2、MySql 等，比较推荐的是 Elasticsearch。</p>
<p>SkyWalking 自己做了可视化，在分布式追踪上的效果展示还可以。</p>
<p>SkyWalking 可以不用编码，引入一个 jar 包，通过字节码增强的方式实现每个接口的监控，但是会有一定的性能消耗（官方人员描述是 5%，网上描述是 10%，此外在高并发场景下会更多）</p>
</li>
<li><p>Pinpoint、CAT、Zipkin</p>
<p>这三个跟 SkyWalking 的核心功能都差不多，都是做分布式追踪监控。Pinpoint 是韩国团队做的，小团队，开源，仍在更新。CAT 是美团系做的，功能更综合一些，研发挺慢的。Zipkin 是 Twitter 做的，开源，轻量。</p>
<p>这三个工具我都没有实操过，具体表现不太清楚，应该跟 Skywalking 差距不大。</p>
</li>
<li><p>Prometheus + Grafana</p>
<p>Prometheus 是 CNCF（云原生计算基金会）毕业的第二个项目（第一个是 Kubernetes）。它对云原生的支持度是最好的，是 Kubernetes 的官方推荐工具，两者做了很多适配，并且有大量的文章。</p>
<p>在云容器监控上，应该是唯一的推荐选择，在业务代码监控上，本来表现一般，但是由于开源社区比较给力，因此适配得还不错。</p>
<p>我们选用这一套来进行监控，一方面是腾讯云做了集成（因此我们的开发工作量是最小的），另一方面是它的性能表现理论上是最好的。具体内容下面会说。</p>
<p>有关 APM 选型，还推荐阅读这篇文章《<a href="http://code2life.top/2020/02/25/0051-prometheus-in-action-thinking/" target="_blank" rel="noopener">Prometheus监控告警——总结与思考</a>》，很有启发性。</p>
</li>
</ul>
<h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><p>Prometheus 是云原生环境中最好的 APM 监控工具，有各种天时地利的因素，使它成为云原生和 Kubernetes 监控的近乎唯一选择。</p>
<p>Prometheus 包括数据采集、存储、处理、告警、可视化等全部要素，但是具体实现跟其他 APM 工具几乎完全不同，下面简单介绍一下 Prometheus 的工作逻辑。（以下的介绍都是很粗浅的，只是描述工作原理，跟实际架构还差很远）</p>
<br>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>简单地理解 Prometheus，它是一个时序数据库，按照时间收集了很多 metric（指标）。</p>
<p>metric 可以理解为带标签的 key-value 键值对，它形如 <code>key{label1=&quot;...&quot;, label2=&quot;...&quot;} =&gt; 100</code>，也就是说 Prometheus 按时间按类型收集了很多值，排列起来最终就是监控数据。具体的格式可参照下图（图片来源：《<a href="https://www.cnblogs.com/vovlie/p/7709312.html" target="_blank" rel="noopener">剖析Prometheus的内部存储机制</a>》）：</p>
<p><img src="/assets/Prometheus%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Prometheus数据结构"></p>
<p>这种 metric 数据结构，占存储空间很小，性能很高，兼容适配也很简单，相比其他 APM 工具根据日志进行解析要优越很多。</p>
<br>

<h3 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h3><p>Prometheus 收集数据基于 pull 模式，监控数据并不是主动发送到 Prometheus 服务器中，而是给 Prometheus 提供一个接口，Prometheus 会自己去调接口收集数据，由它自己控制数据采样速度（最快应该是 1s 采样一次）。</p>
<p>这样做有特别多的好处，第一是开发者很容易在自己的程序中适配，只要提供一个符合约定格式的接口，就可以供 Prometheus 去进行监控，跨语言、跨平台、开发还迅速。第二是由于数据结构简单，采样可以很快，其他 APM 可能受限于性能，一分钟收集一次，而 Prometheus 最快可以 1s 收集一次，精度可以很高。</p>
<br>

<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>Prometheus 有自己的语言，叫做 <code>PromQL</code>，用于查询监控数据。</p>
<p>PromQL 最简单的使用，就是形如上述数据结构的样子，输入 key 查找这一类数据，或者输入 key{label1=”…”} 查找某一类数据中的某类标签。下图就是在查找 JVM 内存的使用情况，只输入了 jvm_memory_used_bytes。</p>
<p><img src="/assets/Prometheus%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt="Prometheus自带的可视化"></p>
<p>PromQL 可以非常复杂，因为内部的数据结构实际上就是 key-value 的键值对，而 value 是 64 位的浮点数，本质上只是数字而已，因此可以进行所有数值运算。PromQL 支持所有数值运算（包括微分、积分、矩阵等），同时内置很多函数。</p>
<br>

<h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>Prometheus 自己做了可视化界面，上图查询 jvm_memory_used_bytes 的图片，就是 Prometheus 的前端界面。</p>
<p>但是这个界面需要用户自己输入 PromQL，不能保存语句，视图比较单一，而且不符合恶俗的 RGB 审美，大家一般选用另一种可视化工具 Grafana 来配合使用。</p>
<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana 是一个可视化工具，它不负责任何数据的来源、存储、收集等等，它只是一个可视化的前端界面。Grafana 支持很多数据源，除了 Prometheus 之外，还支持 Elasticsearch、Zipkin、Loki 等等，甚至是 MySQL。</p>
<p>Grafana 的前身是 Kibana，这段历史还挺有趣的，推荐阅读《<a href="https://www.zhihu.com/question/54388690/answer/411123602" target="_blank" rel="noopener">Grafana 与 Kibana 有什么区别，Kibana 能做的事情 Grafana 是否也都能做？</a>》。</p>
<p>大家选用 Prometheus 基本都使用 Grafana 作为前端可视化工具。使用 Grafana 的好处，第一是符合 RGB 赛博朋克审美，第二是它能存储 PromQL 语句，也就是说配置一次之后，以后就不需要再写语句了。Grafana 的另一个优势在于，配置语句是可以拷贝出来的，去网上找一找，就能找到相关的模板，自己一句 PromQL 都不用写。</p>
<p>Grafana 有两个基本的概念，分别是 dashboard 和 panel，dashboard 是由 panel 组成的。以 Prometheus 为例，一条 PromQL 对应一个 panel，也就是一个图表，一堆图表加在一起就是一个完整的 dashboard。例如下图就是一个 dashboard，里面的每一块就是一个 panel。</p>
<p><img src="/assets/Grafana_dashboard.png" alt="Grafana_dashboard"></p>
<h2 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h2><p>上文写 Prometheus 时说到，Prometheus 基于 pull 模式，服务只需要提供一个接口，让 Prometheus 去调用，那么 Prometheus 就可以对这个服务进行监控。Micrometer 就是在 Spring Boot 框架下，给 Prometheus 提供接口的工具。</p>
<p>Micrometer 是一个专门用来进行 <code>指标收集</code> 的工具，实际上 Spring Boot 2 之后的 actuator 就是使用 Micrometer 来进行统计数据和发布数据到监控系统的。但是默认的 micrometer 并不是 Prometheus 的格式的，我们需要再主动引一个 maven 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>大致的逻辑是这样的：Micrometer 收集指标数据，并通过 actuator 主动暴露一个接口，让 Prometheus 去调用，获取那些收集的指标数据。</p>
<p>Micrometer 默认会收集 JVM 相关的一些数据，业务数据需要自己写代码，比如我想统计 A 接口被调用了多少次，那么每次进入 A 接口的时候，就使用 Micrometer 计数一次。通常使用 Micrometer 是配合 Spring AOP 来使用的，做一个全局切面，统计所有接口的情况。</p>
<p>这是调用接口，获取到 Micrometer 收集的部分真实数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jvm_buffer_count_buffers&#123;application=&quot;live-server&quot;,id=&quot;direct&quot;,&#125; 3.0</span><br><span class="line">jvm_buffer_count_buffers&#123;application=&quot;live-server&quot;,id=&quot;mapped&quot;,&#125; 0.0</span><br><span class="line">jvm_memory_committed_bytes&#123;application=&quot;live-server&quot;,area=&quot;nonheap&quot;,id=&quot;Compressed Class Space&quot;,&#125; 1.0616832E7</span><br><span class="line">jvm_memory_committed_bytes&#123;application=&quot;live-server&quot;,area=&quot;nonheap&quot;,id=&quot;Code Cache&quot;,&#125; 1.9857408E7</span><br><span class="line">jvm_memory_committed_bytes&#123;application=&quot;live-server&quot;,area=&quot;nonheap&quot;,id=&quot;Metaspace&quot;,&#125; 7.794688E7</span><br><span class="line">jvm_memory_committed_bytes&#123;application=&quot;live-server&quot;,area=&quot;heap&quot;,id=&quot;PS Eden Space&quot;,&#125; 3.3292288E8</span><br><span class="line">jvm_memory_committed_bytes&#123;application=&quot;live-server&quot;,area=&quot;heap&quot;,id=&quot;PS Old Gen&quot;,&#125; 2.4379392E8</span><br><span class="line">jvm_memory_committed_bytes&#123;application=&quot;live-server&quot;,area=&quot;heap&quot;,id=&quot;PS Survivor Space&quot;,&#125; 2.359296E7</span><br><span class="line">http_server_requests_seconds_count&#123;application=&quot;live-server&quot;,exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/v3/api-docs/swagger-config&quot;,&#125; 2.0</span><br><span class="line">http_server_requests_seconds_sum&#123;application=&quot;live-server&quot;,exception=&quot;None&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/v3/api-docs/swagger-config&quot;,&#125; 0.0825684</span><br></pre></td></tr></table></figure>

<br>

<p>使用 Micrometer 是需要理解一些概念的，这里不具体写了，推荐两篇写的很好的文章：《<a href="https://www.wqp0010.top/2018/12/27/SpringBoot2-0%E6%95%B4%E5%90%88Prometheus-Grafana/#SpringBoot%E6%9A%B4%E9%9C%B2%E6%8C%87%E6%A0%87" target="_blank" rel="noopener">SpringBoot2.0整合Prometheus Grafana</a>》《<a href="https://yunlongn.github.io/2019/08/13/%E7%BB%99%E4%BD%A0%E7%9A%84SpringBoot%E5%81%9A%E5%9F%8B%E7%82%B9%E7%9B%91%E6%8E%A7-JVM%E5%BA%94%E7%94%A8%E5%BA%A6%E9%87%8F%E6%A1%86%E6%9E%B6Micrometer/" target="_blank" rel="noopener">给你的 Spring Boot 做埋点监控</a>》，前者是总体使用思路，后者是 Micrometer 的使用细节。</p>
<hr>
<h1 id="监控解决方案"><a href="#监控解决方案" class="headerlink" title="监控解决方案"></a>监控解决方案</h1><p>我们目前的监控主要分两个方面，一方面是对<code>云容器</code>的监控，另一方面是对<code>业务代码</code>的监控，下面分别叙述。</p>
<h2 id="基础设施监控"><a href="#基础设施监控" class="headerlink" title="基础设施监控"></a>基础设施监控</h2><p>我们使用腾讯云作为服务器，腾讯云内部正在开发集成 Prometheus，对 Kubernetes 容器进行监控，目前处于灰度上线阶段。</p>
<p>我们得知之后，直接使用腾讯云集成的 Prometheus 服务，不需要进行配置就直接使用，还是比较省心的。</p>
<p>腾讯云集成的 Prometheus 服务基本配置了全部内容，包括但不限于</p>
<ul>
<li>Kubernetes 容器的数据埋点和数据收集</li>
<li>Prometheus 服务的部署、启动、数据采集、存储等</li>
<li>Grafana 的前端可视化配置（其实就是写 PromQL，很复杂）</li>
</ul>
<br>

<p>腾讯云原来也有监控服务，使用新集成的 Prometheus 的优势有以下几点：</p>
<ul>
<li>理论上，Prometheus 的收集精度会更高，因为采样数据间隔更短</li>
<li>Prometheus 收集的数据更全，我们能够获得更多信息</li>
<li>可以配置我们自己的 Prometheus 访问接口，如果需要做业务监控，不需要额外配置</li>
</ul>
<br>

<p>目前该项目还处于灰度上线阶段（2020.09.18），目前仍遇到的问题有：</p>
<ul>
<li>Prometheus 和 Grafana 都是有学习成本的，尤其是 Prometheus，此外还要有云原生的基本运维知识，门槛很高。如果我们想自己做一些改变，或者理解监控的内容，需要积累非常多的知识</li>
<li>目前 Grafana 的前端展示都是英文的（当然，这更加准确），但是参数非常多，有时并不能理解，腾讯云缺少本地化翻译工作，也缺少操作指引教程</li>
<li>不支持告警</li>
</ul>
<h2 id="业务监控"><a href="#业务监控" class="headerlink" title="业务监控"></a>业务监控</h2><p>除了 Kubernetes 的宏观监控之外，我们还需要对业务代码进行监控，对每个服务内部做微观监控。</p>
<p>比如我想要知道，在进行压力测试时，哪个接口调用地次数最多，调用的时间最长，服务启动之后 JVM 是否表现合理，由此去判断如果想要优化代码，需要优化哪里。在这种场景下，单纯监控 Kubernetes 容器层面是远远不够的，还需要对业务服务进行监控。</p>
<p>我们总体的 APM 技术栈是：</p>
<ul>
<li>actuator 和 Micrometer 做数据埋点</li>
<li>Prometheus 做数据收集（配置过程由腾讯云完成）</li>
<li>Grafana 做数据可视化</li>
</ul>
<br>

<h3 id="监控数据埋点（采集）"><a href="#监控数据埋点（采集）" class="headerlink" title="监控数据埋点（采集）"></a>监控数据埋点（采集）</h3><p>我们使用 actuator 配合 Micrometer 做数据收集。</p>
<p>Micrometer 默认会收集 JVM 等整体性的指标，我们除此之外，还收集了两项指标：所有接口的调用次数、所有接口的调用时间。</p>
<p>这些指标都通过 actuator 暴露接口，供 Prometheus 查询。默认暴露的接口是 <code>/actuator/prometheus</code>，比如 <code>http://localhost:8080/actuator/prometheus</code>。</p>
<p>下面附一下代码，分为三部分，分别是 <code>pom.xml</code>、<code>application.yml</code>、埋点代码：</p>
<p><code>pom.xml</code> 也就是 Maven 中需要引入的包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- actuator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- micrometer 的 Prometheus 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- AOP 切面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>application.yml</code> 是 Spring 对 actuator 的配置内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="comment"># actuator 允许访问的地址</span></span><br><span class="line"><span class="attr">  endpoints:</span></span><br><span class="line"><span class="attr">    web:</span></span><br><span class="line"><span class="attr">      exposure:</span></span><br><span class="line"><span class="attr">        include:</span> <span class="string">prometheus</span></span><br><span class="line">  <span class="comment"># 采样时，每个指标都会带的 label，方便可视化查找</span></span><br><span class="line"><span class="attr">  metrics:</span></span><br><span class="line"><span class="attr">    tags:</span></span><br><span class="line"><span class="attr">      application:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<p>埋点业务代码，通过 AOP 切面，对所有接口做拦截，统计数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrometheusAopConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MeterRegistry meterRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrometheusAopConfig</span><span class="params">(MeterRegistry meterRegistry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.meterRegistry = meterRegistry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截所有controller方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* 包.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controllerAop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"controllerAop()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">controllerAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 获取方法名</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取类名</span></span><br><span class="line">        String className = joinPoint.getTarget().getClass().getName();</span><br><span class="line">        <span class="comment">// 方法计数</span></span><br><span class="line">        meterRegistry.counter(<span class="string">"method.count"</span>, <span class="string">"method"</span>, methodName, <span class="string">"className"</span>, className).increment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取执行方法前的时间</span></span><br><span class="line">        <span class="keyword">long</span> beforeTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        Object proceed = joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录方法执行时间</span></span><br><span class="line">        <span class="keyword">long</span> processTime = System.currentTimeMillis() - beforeTime;</span><br><span class="line">        Timer timer = meterRegistry.timer(<span class="string">"method.time"</span>, <span class="string">"method"</span>, methodName, <span class="string">"className"</span>, className);</span><br><span class="line">        timer.record(processTime, TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="监控数据处理"><a href="#监控数据处理" class="headerlink" title="监控数据处理"></a>监控数据处理</h3><p>由腾讯云的 Prometheus 监控进行数据的采集，通过简单的配置，比如设置 Kubernetes 的实例名、服务名、端口号、采集数据接口等，就可以完成 Prometheus 的配置。</p>
<p><img src="/assets/%E8%85%BE%E8%AE%AF%E4%BA%91Prometheus%E9%85%8D%E7%BD%AE.png" alt="腾讯云Prometheus配置"></p>
<p>如果个人搭建的话，需要去 Prometheus 官方下载程序，配置 <code>application.yml</code> 文件，启动服务。</p>
<br>

<h3 id="监控数据展示"><a href="#监控数据展示" class="headerlink" title="监控数据展示"></a>监控数据展示</h3><p>使用 Grafana 进行可视化展示。</p>
<p>使用 Grafana 时，因为有很多 dashboard，因此要自己选择。</p>
<p>首先选择右边栏，找到 Manage 选项，会看到 Dashboards 目录。默认会有一个文件夹，是腾讯云配置的 Kubernetes 文件夹，里面是对云容器监控的 dashboard（有很多很多）。</p>
<p><img src="/assets/%E8%85%BE%E8%AE%AF%E4%BA%91Grafana%E9%BB%98%E8%AE%A4.png" alt="腾讯云Grafana默认"></p>
<p>个人配置的话，需要先创建一个 dashboard，再在里面创建一个个 panel，每一个 panel 就是一条 PromQL（写起来非常痛苦）。</p>
<p>还有一条捷径，就是去找网上已经配好的模板，比如 Micrometer 采集的 JVM 数据，网上就有已经配置好的模板《<a href="https://grafana.com/grafana/dashboards/4701" target="_blank" rel="noopener">JVM (Micrometer)</a>》。但是业务逻辑的话，还是乖乖自己写吧。</p>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>jpa 实体关联注解</title>
    <url>/2019/09/08/jpa%E5%AE%9E%E4%BD%93%E5%85%B3%E8%81%94%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<br>

<p>九月的第二周，来看 Jpa 注解开发实体关联，Spring Cloud 下周再说。</p>
<p>被 Jpa 实体关联搞得有点烦，两个月了也没完全清晰，特来写一篇文章把常见关联情况都试一遍。</p>
<hr>
<p>从 ORM 框架说起。</p>
<p>ORM（ Object-Relational Mapping ），对象关系映射。我们平常操纵的数据库都是关系型数据库（关系：表与表之间存在关系，例如从【部门表】可以查到【员工表】）。 Java 是一门面向对象的语言，它希望与对象打交道，而不是与数据库、与表打交道，通过 <code>ORM （对象关系映射）</code> 实现对象之间建立起关系。</p>
<p>术语一些： ORM，把关系数据库的表结构映射到对象上。</p>
<br>

<p>我们首先厘清一下概念。</p>
<p>从大类上分，有两类：数据库、实体。</p>
<ul>
<li><p>数据库：表 + 字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── 部门表</span><br><span class="line">│   ├── 部门ID （字段）</span><br><span class="line">│   └── 部门名（字段）</span><br><span class="line">└── 员工表</span><br><span class="line">    ├── 员工ID （字段）</span><br><span class="line">    └── 员工名（字段）</span><br></pre></td></tr></table></figure>
</li>
<li><p>实体：类 + 属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── 部门类</span><br><span class="line">│   ├── 部门ID （属性）</span><br><span class="line">│   └── 部门名（属性）</span><br><span class="line">└── 员工类</span><br><span class="line">    ├── 员工ID （属性）</span><br><span class="line">    └── 员工名（属性）</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>

<p>数据库中，表之间的关联，是通过外键做到的，具体内容我们不讨论，这个去看数据库和 SQL 相关。</p>
<p>实体中，类之间的关联，可以通过注解来实现，这是我们这篇要详细讨论的。</p>
<br>

<p>顺便一提命名规则。</p>
<p>数据库的命名规则，基本使用下划线命名法，例如：department_id（部门ID）。</p>
<p>实体的命名规则，基本使用驼峰命名法，例如：departmentId（部门ID）。</p>
<hr>
<p>注解是 JDK 1.5 引入的内容，原理基于反射，使用起来非常方便，Spring 中大量使用，具体不细叙。</p>
<p>使用注解开发实体关联，有两种途径：</p>
<ul>
<li><p><code>@OneToOne</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@ManyToMany</code> 这四个注解是一类。</p>
<p>除了 <code>@ManyToOne</code> 这个注解之外，其他三个注解都有 <code>mappedBy</code> 属性，用于关联实体。</p>
</li>
<li><p><code>@JoinColumn</code> 注解，用于关联实体。（但是还是要加上 <code>@OneToOne</code> 等关联注解的，两个注解一起使用）</p>
</li>
</ul>
<p>要注意的是，这两种注解关联的方法，不能一起使用，只能选择一种使用。</p>
<br>

<h2 id="注解填写属性"><a href="#注解填写属性" class="headerlink" title="注解填写属性"></a>注解填写属性</h2><p>这两种注解，填写的属性是不同的。</p>
<p> <code>mappedBy</code> ：类层面，关联的全都是【实体类】中的【属性名】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// departmentId ：类中的属性名</span></span><br><span class="line"><span class="meta">@OneToOne</span>(mappedBy = <span class="string">"departmentId"</span>)</span><br></pre></td></tr></table></figure>

<p> <code>@JoinColumn</code>：字段层面，关联的全都是【表】中的【字段名】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// department_id ：表中的字段名</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"department_id"</span>)</span><br></pre></td></tr></table></figure>

<p>多说一句， <code>@Table</code>、 <code>@Column</code>、 <code>@JoinTable</code>、 <code>@JoinColumn</code>、<code>@JoinColumns</code>，这些都是一类的，填写的全都是数据库中的字段名（下划线命名法的那些）。</p>
<hr>
<p>正式开始。</p>
<p>建两个实体类，<code>Department</code> 和 <code>Employee</code> ，各有 id 和 name 两个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_department"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"department_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> String departmentId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"department_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_employee"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"employee_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> String employeeId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"employee_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String employeeName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续代码会略写。</p>
<hr>
<h1 id="OneToOne-一对一映射"><a href="#OneToOne-一对一映射" class="headerlink" title="@OneToOne 一对一映射"></a>@OneToOne 一对一映射</h1><p>场景：一个部门里只有一个员工，同样的，一个员工只属于一个部门。</p>
<h2 id="JoinColumn"><a href="#JoinColumn" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"own_employee_name"</span>, referencedColumnName = <span class="string">"employee_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> Employee ownEmployee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【己方】实体的【数据库字段】</li>
<li><code>referencedColumnName</code> ：【对方】实体的【数据库字段】（如果是主键，可以省略）</li>
</ul>
<p><img src="/assets/%E5%8D%95%E5%90%91%E4%B8%80%E5%AF%B9%E4%B8%80.jpg" alt="一对一 @JoinColumn"></p>
<br>

<h2 id="OneToOne-mappedBy-“…”"><a href="#OneToOne-mappedBy-“…”" class="headerlink" title="@OneToOne(mappedBy = “…”)"></a>@OneToOne(mappedBy = “…”)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"own_employee_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Employee ownEmployee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToOne</span>(mappedBy = <span class="string">"ownEmployee"</span>)</span><br><span class="line">    <span class="keyword">private</span> Department belongDepartment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>@OneToOne</code> 注解，<code>mappedBy</code> 只有一种使用方法，那就是对方先关联自己，自己反关联回去。（因此无法通过 <code>mappedBy</code> 来实现一对一的单向关联，如若一对一关系使用 <code>mappedBy</code> ，必定是双向关联）</p>
<p>上面的代码实现了这样的功能：【部门类】首先关联了【员工类】（通过 <code>@JoinColumn</code> 注解），把员工作为自己的一个属性。【员工类】通过 <code>mappedBy</code> 反关联回去【部门类】，其中 <code>mappedBy</code> 所指向的值，就是部门类已经关联好的员工类属性。</p>
<p>换句话说，一对一的关联关系是由【部门类】所创建和维护的，<code>mappedBy</code> 自身不关联，它只是顺着这层已经存在的单层关联，顺藤摸瓜地反关联回去。</p>
<p><img src="/assets/%E4%B8%80%E5%AF%B9%E4%B8%80mappedBy.jpg" alt="一对一 mappedBy"></p>
<hr>
<h1 id="OneToMany-一对多映射"><a href="#OneToMany-一对多映射" class="headerlink" title="@OneToMany 一对多映射"></a>@OneToMany 一对多映射</h1><p>场景：一个部门里有多个员工。</p>
<h2 id="JoinColumn-1"><a href="#JoinColumn-1" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToMany</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"employee_name"</span>, referencedColumnName = <span class="string">"own_employee_id"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; ownEmployeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【对方】实体的【数据库字段】</li>
<li><code>referencedColumnName</code> ：【己方】实体的【数据库字段】（如果是主键，可以省略）</li>
</ul>
<p>（发现了吗，刚好是跟一对一关系是反过来的）</p>
<p><img src="/assets/%E4%B8%80%E5%AF%B9%E5%A4%9A@JoinColumn.png" alt="一对多@JoinColumn"></p>
<p>这是个很有意思的事情，为什么这里反过来了呢？这个我们在后文的分析中再讨论。</p>
<h2 id="OneToMany-mappedBy-“…”"><a href="#OneToMany-mappedBy-“…”" class="headerlink" title="@OneToMany(mappedBy = “…”)"></a>@OneToMany(mappedBy = “…”)</h2><p>一对多的情况下，<code>mappedBy</code> 有两种使用方式。</p>
<ol>
<li><p>跟一对一关联一样，首先对面已经关联好自己，自己只需要反向关联回去即可，<code>mappedBy</code> 的值是自己在对方类中的属性名。（在这种情况下，必须双向关联）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"employeeName"</span>) <span class="comment">// 匹配自己在对方的实体属性</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; ownEmployeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无需对方关联，直接去关联对方的外键属性。（在这种情况下，虽然使用了 <code>mappedBy</code> ，但是依旧是单向关联）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"departmentId"</span>) <span class="comment">// 匹配对方的外键</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; ownEmployeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样单向关联有一个前提：对方的外键关联自己时，必须关联自己的主键。</p>
<p>比较简单，就不画图了。</p>
</li>
</ol>
<hr>
<h1 id="ManyToOne-多对一映射"><a href="#ManyToOne-多对一映射" class="headerlink" title="@ManyToOne 多对一映射"></a>@ManyToOne 多对一映射</h1><p>场景：多个员工归属于同一个部门。</p>
<h2 id="JoinColumn-2"><a href="#JoinColumn-2" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@ManyToOne</span></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"belong_department_name"</span>, referencedColumnName = <span class="string">"department_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> Department belongDepartment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【己方】实体的【数据库字段】</li>
<li><code>referencedColumnName</code> ：【对方】实体的【数据库字段】（如果是主键，可以省略）</li>
</ul>
<p>多对一关联（ ManyToOne ），和一对一关联（ OneToOne ），在使用 <code>@JoinColumn</code> 时，是一模一样的。</p>
<p>也就是说，一对一、多对一的关联，和一对多的关联，在 <code>name</code> 和 <code>referencedColumnName</code> 上，是刚好相反的，这个我们一会分析。</p>
<h2 id="❌-mappedBy"><a href="#❌-mappedBy" class="headerlink" title="❌ mappedBy"></a>❌ mappedBy</h2><p><code>@ManyToOne</code> 不存在 <code>mappedBy</code> 属性。</p>
<p>因为 <code>mappedBy</code> 的原理是把关联的任务交给对面去做，员工有N个，部门只有1个，员工让部门去维护关联，一个部门是无法同时关联N个员工的，因此不存在 <code>mappedBy</code> 属性。</p>
<hr>
<h1 id="ManyToMany-多对多映射"><a href="#ManyToMany-多对多映射" class="headerlink" title="@ManyToMany 多对多映射"></a>@ManyToMany 多对多映射</h1><p>场景：一个部门内有多个员工，但是同时，一个员工也可以属于多个部门。</p>
<h2 id="JoinTable"><a href="#JoinTable" class="headerlink" title="@JoinTable"></a>@JoinTable</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 部门实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@ManyToMany</span></span><br><span class="line">    <span class="meta">@JoinTable</span>(name = <span class="string">"pz_ref"</span>,</span><br><span class="line">            joinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"ref_department_id"</span>)&#125;,</span><br><span class="line">            inverseJoinColumns = &#123;<span class="meta">@JoinColumn</span>(name = <span class="string">"ref_employee_id"</span>)&#125;)</span><br><span class="line">    <span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employeeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多对多关联，是需要自己建一张中间表的。粗略一想就会发现，多对多，双方都是多，无法实现一方用外键关联另一方，所以必须有中间表。（但是不需要为这张中间表创建实体类）</p>
<p>除了新增一张表之外，连注解也发生了改变。原先是 <code>@JoinColumn</code> ，<code>join</code> 到字段中，现在是 <code>@JoinTable</code> ，<code>join</code> 到表中。</p>
<p>注解中的属性：</p>
<ul>
<li><code>name</code> ：【中间表】的【表名】</li>
<li><code>joinColumns</code> ：【己方表】与【中间表】关联（按 @OneToMany 的方式来）</li>
<li><code>inverseJoinColumns</code>：【对方表】与【中间表】关联（按 @OneToMany 的方式来）</li>
</ul>
<p><img src="/assets/@JoinTable.png" alt="@JoinTable"></p>
<h2 id="ManyToMany-mappedBy-“…”"><a href="#ManyToMany-mappedBy-“…”" class="headerlink" title="@ManyToMany(mappedBy = “…”)"></a>@ManyToMany(mappedBy = “…”)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 员工实体</span></span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">    <span class="meta">@ManyToMany</span>(mappedBy = <span class="string">"employeeList"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;Department&gt; departmentList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一种使用方法，跟一对一关联（ OneToOne ）、一对多关联（ OneToMany )都具有的使用方法一致：<code>mappedBy</code> 属性值是自己在对面实体类中的属性名，即必须双向映射。</p>
<hr>
<p>四类关联：一对一、一对多、多对一、多对多，已经都走过一遍了。现在分析一下两种注解方式（ <code>@JoinTable</code> 就懒得提了）。</p>
<h1 id="JoinColumn-3"><a href="#JoinColumn-3" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h1><p>我所理解的 <code>@JoinColumn</code> ，它的本质是 <code>@Column</code> ，从本质上来说，它并不是在做关联，它是在做映射，它把【数据库】和【实体】映射起来，使用这类注解能够实现：数据库中的一个字段，对应着，实体类中的一个字段。所以，它在做的事情，并不是把【部门】和【实体】关联起来，而是把【表】和【实体类】映射起来（但是与此同时，也就关联起来了两个实体)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OneToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"自己"</span>, referencedColumnName = <span class="string">"对方"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@OneToMany</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"对方"</span>, referencedColumnName = <span class="string">"自己"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"自己"</span>, referencedColumnName = <span class="string">"对方"</span>)</span><br></pre></td></tr></table></figure>

<p>刚才我们发现，【1 - 1】、【N - 1】的使用方法是相同的，但是【1 - N】刚好反了过来，这是为什么。</p>
<p>是因为，<code>@JoinColumn</code> 根本就不关心它所在的实体类是谁，它的 <code>name</code> 属性指向的，永远都是外键。因为外键始终在【多】的一方（一对一的话就默认自己是多），因此 <code>name</code> 属性值为【多的一方的外键】。</p>
<p>有关 <code>@JoinColumn</code> 自动建表的事情，我还没有弄清楚。</p>
<h1 id="mappedBy-“…”"><a href="#mappedBy-“…”" class="headerlink" title="mappedBy = “…”"></a>mappedBy = “…”</h1><p><code>mappedBy</code> 通常出现，都是为了做双向关联，而且对于 <code>@OneToOne</code> 和 <code>@ManyToOne</code> 而言，<code>mappedBy</code> 只能做双向关联。</p>
<p>我们在文章开头就指出，<code>mappedBy</code> 是针对【实体类】而做操作的，它的值是本类在对方类的属性名。我们再理一遍，它要等对方关联自己之后，自己顺着这层【已经建立起来的联系】，反关联回去。</p>
<p>这么做的道理是，A 关联 B，B 不应该再去建立新的关联关系，去重新关联 A（当然你硬要这么做也可以），而应该根据 A 关联 B 的这层关系，自动地找回去。这叫做：</p>
<blockquote>
<p>本类放弃控制关联关系，关联由对方去控制。</p>
</blockquote>
<br>

<p>很奇怪的一件事是，对于三种能使用 <code>mappedBy</code> 属性的注解： <code>@OneToOne</code> 、<code>@OneToMany</code> 、 <code>@ManyToOne</code> ，它们有一种统一的使用方法（即本类在对方类的属性名）。但是对于 <code>@OneToMany</code> ，它有第二种使用方法，它仿佛可以不需要对面先建立联系，直接使用 <code>mappedBy</code> 指向对方类的外键属性。</p>
<p>这样做的原理是，依旧让对方维护关联关系，但是必须由对方的【外键】关联己方的【主键】（如果使用 <code>@JoinColumn</code> 可以由对方的【外键】关联己方的【任意键】）。</p>
<p>也就是说，在一对多的关系中，【一方】想去关联【多方】，但是又不想自己去维护关联关系（因为一对多时，维护关联关系的话，代码会自动地创建出来一张新表），因此【一方】使用 <code>mappedBy</code> 让对面来处理关联关系。对面是怎么做关联的呢，是通过外键关联主键的方式关联的。</p>
<hr>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>最后说一说 Jpa 和注解关联的各种坑。</p>
<br>

<ol>
<li><p>驼峰命名法和下划线命名法的自动转换</p>
<p>我还没查清具体的原因，是 Spring 框架还是 hibernate ，总之现在框架能自动把数据库中的【下划线命名法】映射到实体类中的【驼峰命名法】。</p>
<p>例如，正常来讲，实体类中的属性应该要通过 <code>@Column</code> 配置映射关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_department"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里通过 @Column 注解</span></span><br><span class="line">    <span class="comment">// 将部门表中的【department_name】字段映射到部门类中的【departmentName】</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"department_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是实际上，就是不加 <code>@Column</code> 注解，框架也能自动映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"pz_department"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部门表中的【department_name】字段，自动映射到部门类中的【departmentName】</span></span><br><span class="line">    <span class="comment">// 框架能够自动将下划线命名，转换为驼峰命名</span></span><br><span class="line">    <span class="keyword">private</span> String departmentName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是！一定不要这么做！</p>
<p>因为在做关联时，有可能会生成新表，如果之前没有加 <code>@Column</code> 注解映射到数据库的话，新表的字段，将不会是原表中的字段名（下划线命名），而将是实体类中的属性名（驼峰命名），这时再去做关联，会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: org.hibernate.MappingException: Unable to find column with logical name: employee_name in org.hibernate.mapping.Table(pz_employee) and its related supertables and secondary tables</span><br></pre></td></tr></table></figure>

<p>报错信息：【employee_name】字段，在【pz_employee】表以及其他相关表中找不到。</p>
<p>报错原因：因为在其他相关表（自动创建）中，字段名是【employeeName】。</p>
<br>
</li>
<li><p>进行双向关联时，循环打印</p>
<p>部门关联员工，员工关联回部门，部门再关联回员工……程序运行本身不会出现问题，但是如果打印出来，就会造成关联上的死循环，直至溢出。</p>
<p>想要解决的话，就在其中一个类的该属性上加上 JSON 相关的注解，让这个属性不进行序列化。</p>
<p>例如通过 <code>fastjson</code> 中的 <code>@JSONField(serialize = false)</code> 注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JSONField</span>(serialize = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> Department department;</span><br></pre></td></tr></table></figure>

<br>
</li>
<li><p><code>@JoinColumn(name = &quot;...&quot;)</code> 属性映射不能重复</p>
<p>上文中分析过，<code>@JoinColumn</code> 注解本质上是对数据库和实体类进行映射。如果某一数据库中的字段，已经映射到某属性上了，在 <code>@JoinColumn</code> 中的 <code>name</code> 属性里再次映射，就会出现问题：到底映射的是哪一个呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Column</span>(name = <span class="string">"belong_department_id"</span>)</span><br><span class="line"><span class="keyword">private</span> String belongDepartmentId;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ManyToOne</span></span><br><span class="line"><span class="meta">@JoinColumn</span>(name = <span class="string">"belong_department_id"</span>, referencedColumnName = <span class="string">"department_id"</span>)</span><br><span class="line"><span class="keyword">private</span> Department belongDepartment;</span><br></pre></td></tr></table></figure>

<p>例如上面这段代码，就会报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: org.hibernate.MappingException: Repeated column in mapping <span class="keyword">for</span> entity: com.app.ykym.modules.test.entityAndRepository.Employee column: belong_department_id (should be mapped with insert=<span class="string">"false"</span> update=<span class="string">"false"</span>)</span><br></pre></td></tr></table></figure>

<p>解决方法在报错信息里也说明了：重复映射的两个属性，选一个，让它 <code>insert=&quot;false&quot; update=&quot;false&quot;</code> （写在注解里），意思是让其中一个属性放弃更新和插入数据库的权限。</p>
<p>（但是 <code>@OneToMany</code> 时，<code>@JoinColumn(name = &quot;...&quot;)</code> 是可以重复的）</p>
</li>
</ol>
<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven 工具</title>
    <url>/2019/11/03/maven-%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<br>

<p>十一月的第一周，来学习和整理 Maven。</p>
<p>用维基的话讲，Maven 是一个项目管理以及自动构建的工具（初听还是有些一头雾水的）。我开始工作之后，几乎天天和 Maven 打交道，但是仿佛又对它很生疏，特用一周的时间来学习与整理相关知识。</p>
<hr>
<p>Maven 是 Apache 公司所创造的项目管理工具。项目管理这个词，在计算机编程方面没那么容易解释，你可以理解为编程中除了写代码那部分之外的工作，例如编译、打包、引入依赖资源等等这类打杂的事情。</p>
<br>

<p>在 Maven 出现之前，Ant 是 Java 世界的主流项目管理工具，所有人在介绍 Maven 的时候，总是会先讲几句 Ant 如何拧巴、如何不优雅，然后才话归正题说起 Maven。我并没有用过 Ant，我猜测很多像我一样的萌新也是直接上手 Maven，而从没使用过 Ant 的，我们这类人每次看 Maven 的教程都会一脸懵逼：“Ant 是什么？我们这说 Maven 呢你提它干嘛？”</p>
<p>看了许久，大概能猜到 Maven 和经常被鞭尸的 Ant 的区别：Ant 是一个很传统的项目管理工具，想实现什么，自己写去，麻烦也得自己写；Maven 是一个【约定大于配置】的项目管理工具，帮你写好了大部分东西、配好了大部分操作，你稍微一改就能用了（前提是你要遵守约定）。</p>
<br>

<p>在 Maven 的官网中，有一篇名为《Maven 的哲学》的文章，里面粗略介绍了 Maven 的设计哲学。其中有这么一句话：</p>
<blockquote>
<p>Maven is about the application of patterns in order to achieve an infrastructure which displays the characteristics of visibility, reusability, maintainability, and comprehensibility. </p>
</blockquote>
<p>我认为这句话里最重要的词是“patterns”，这个词直译是模式、范例。我觉得呢，pattern 是一个很有哲学思辨性的词，印象中它最早出现应该是在柏拉图的理念论里面，柏拉图认为有两个世界，一个是理想世界，一个是现实世界，现实世界中的一切都以理想世界中的“范型”（pattern）为模板创造出来。</p>
<p>不要有抵制心理，这是个很简单的概念，举个例子：世界上有那么多人，每个人都各有不同，但大家都属于同一类事物：人。按照柏拉图的理解，一定有另一个世界，那里有人这个模板，我们这个世界上的所有人，都是从另一个世界上的那个模板拷贝而来的。如果用编程术语来描述的话，这就是对象与类之间的关系，一个是抽象化的，一个是实例化的。</p>
<p>Maven 自述哲学思想的这段话，我理解的意思是，Maven 设置了一个公用模板，如果你使用 Maven 来管理项目，你就可以使用那个默认的模板，稍微改一点东西就可以了。这是一种和 Spring Boot 一样的配置思路，即约定大于配置，我们约定好了，你就别自己配置了。这样做有两种好处，一种是减少开发时间，一种是标准化、规范化，以方便大家交流。</p>
<br>

<p>但我是觉得吧，Maven 所指的“patterns”，说的不光是约定大于配置这件事，它当然包括这个，但是不只是。因为 Maven 本身不光是一个解决项目配置问题的工具，它做的事情是项目管理，管理这个概念就广泛了很多，包括依赖、编译、部署等等，当然，其中也包括配置。我理解的 Maven，它在配置方面采用约定大于配置的思路，但是在其他地方，也是本着【模块化】、【范型化】、【标准化】这一类的思路来处理的。</p>
<p>这个慢慢体会。</p>
<hr>
<p>对我而言，学习 Maven 首先遇到的问题是，我分不清楚那一堆项目管理的功能，究竟是 Maven 的，还是 IDE 的（此处应该配一个扶额焦虑的表情）。在我写这篇博文之前，很多 Maven 的设计与功能，我都以为是 IDEA 帮我做的，毕竟我每一次构建项目，都是打开 IDEA 软件，使用 Maven 来构建工程的，而且一切过程都是全程默认下一步做的，搞得我现在都分不清这两个工具的功能边界了……</p>
<br>

<p>用 Maven 构建项目，首先注意到的，是文件的目录结构。多建几次就会发现，每次新建出来的项目（project），或者是模块（module），文件的目录索引都是一样的，基本都长下面这个样子：</p>
<p><img src="/assets/maven%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="maven目录结构"></p>
<p>这种目录结构是 Maven 构建出来的，统一化的文件索引方式，好处之一在于，各开发者在开发时，存放文件的位置几乎没有差别（而且符合直觉），能够维持团队高效运作；好处之二在于，固定的文件存放路径，能够让第三方工具 Maven 帮助我们管理项目，而不是我们自己做繁复的操作。</p>
<p>这种目录结构，最重要的是三部分：<code>src</code>、<code>target</code>、<code>pom.xml</code>。他们分别对应着：源代码、编译文件、配置文件。稍详细一点的信息看下面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── src                src即source，代表源文件目录</span><br><span class="line">│   ├── main             主程序</span><br><span class="line">│   │   ├── java           存放java源代码，几乎所有代码文件都在这里</span><br><span class="line">│   │   └── resources      存放资源文件，例如application.xml</span><br><span class="line">│   └── test             测试程序</span><br><span class="line">│       └── java           内存放测试代码</span><br><span class="line">│</span><br><span class="line">├── target             输出目录</span><br><span class="line">│   ├── classes          编译输出目录</span><br><span class="line">│   └── test-classes     测试编译输出目录</span><br><span class="line">│</span><br><span class="line">└── pom.xml            配置文件</span><br></pre></td></tr></table></figure>

<p>我觉得这部分没什么好关注的，看几次就记得很牢固了，这种目录结构还是很符合直觉的。</p>
<p>上文说到，重要的有三部分：<code>src</code>、<code>target</code>、<code>pom.xml</code>，这前两个着实没什么可介绍的，一个放源码，一个放编译文件，但第三个 <code>pom.xml</code> （Maven 的配置文件），还是要单独学习的。</p>
<hr>
<p>POM 的全程是 Project Object Model，项目对象模型。Maven 是一个项目管理工具，它要面对的是项目，它面对项目的管理方式是 POM，把项目当做对象一样管理。这种面向对象的处理方式，跟 Java 是一个路数的，只不过 Java 的编码语言是 Java，Maven 的编码语言是 xml。</p>
<p>初看 Maven 的配置文件（pom.xml），xml 这种语言在字符数量上实在是令人畏惧，这一大堆的代码让人一头雾水，感觉要配置的东西很繁琐，很混乱。</p>
<p>以下是一段配置得较为简单，但还是能够运行的 pom.xml 文件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.pz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我在四处找 Maven 教程和总结贴的时候，看到了一篇博文（但是我后来找不到了，抱歉不能链接来源了），他提供了一种新的认知思路：既然 POM 就是将项目视作对象，以面向对象的方式进行管理，那么我们可以把 xml 的代码转换成 Java 代码来理解。上面的那段 xml 代码，如果是用 java 代码来看待的话，应该是这样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Project</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> modelVersion;</span><br><span class="line">    <span class="keyword">private</span> String groupId;</span><br><span class="line">    <span class="keyword">private</span> String artifactId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">private</span> Dependency dependencies;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Class Dependency &#123;</span><br><span class="line">        <span class="keyword">private</span> String groupId;</span><br><span class="line">        <span class="keyword">private</span> String artifactId;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">        <span class="keyword">private</span> String scope = compile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就清晰很多，便于初次看到 xml 代码来理解了。</p>
<br>

<p>下面分类型，挑选一部分经常要使用的配置项来总结一下。</p>
<p>pom.xml 文件能够配置的地方特别多，在此全部总结出来不现实，以后遇到了现查就可以了。参考这篇<a href="https://www.runoob.com/maven/maven-pom.html" target="_blank" rel="noopener">《POM 标签大全详解》</a>去查阅更多配置解释（在网页内容的下半部分）。</p>
<h1 id="项目基本信息"><a href="#项目基本信息" class="headerlink" title="项目基本信息"></a>项目基本信息</h1><p>以这段代码为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.pz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从头文件说起，这部分不是 Maven 的 pom.xml 文件所专有的，而是一切 xml 文件都要配置的。</p>
<ul>
<li><p><strong>xmlns</strong></p>
<p>全称是 xml name space，即 xml 命名空间。</p>
<p>命名空间的意思是，有两个 xml 文件都使用了同一个名字，比如 A.xml 文件是一个人员文件，里面用 name 这个名字表示人名，与此同时 B.xml 文件是一个公司文件，里面用 name 这个名字表示公司名。当两个文件同时执行时，如果不指定 xml 文件的命名空间，那么就会造成混乱。</p>
<p>通常情况下，如果要指定命名空间，应该是 <code>xmlns:a</code>、<code>xmlns:b</code> 之类的写法，表示 a 的命名空间、b 的命名空间是什么，这里什么都不写，是表示默认的命名空间。</p>
<p><code>xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</code> 这一行的右边是一个字符串（更准确的讲，是一个 url 地址字符串），这个字符串表示该命名空间的唯一标识符。通常情况下，这个字符串会是一个 url 地址，点开之后能够看到详细的对于该命名空间的说明。但是在这里，如果你尝试的话，这个 url 并打不开，这个后面再说。</p>
</li>
<li><p><strong>xmlns:xsi</strong></p>
<p>根据上面对于 xmlns 的解释，这里应该就是声明 xsi 命名空间了。</p>
<p>xsi 的全称是 xml schema instance，这个命名空间并不是偶然出现的，它已经成为了一种业界规范，是表示 xml 文档结构（ XSD，xml scheme definition）的命名空间。xml 文档结构，就是整个 xml 文件需要有哪些内容，这些内容的格式、默认值等等是什么，我们所写的 pom.xml 文件，都是基于它的 xml 文档结构来写的。由于文档结构是非常重要的东西，因此为它单独指定一个命名空间。</p>
<p>这次你点开后面的网址，就能看见对于 xsi 这个命名空间的简单说明了。</p>
</li>
<li><p><strong>xsi:schemaLocation</strong></p>
<p>这个的意思是：xsi 的 schemaLocation 是什么，翻译之后的意思是：xml 文档结构的具体内容应该会存放在某个文件里，那么这个文件在哪里？</p>
<p>你去观察这行代码，发现在 <code>xsi:schemaLocation</code> 之后有两个 url 地址，而且第一个 url 地址，居然就是 xmlns 默认命名空间的指定地址。实际上，这两个 url 地址是以 key-value 的形式出现的，key 是该 xml 默认命名空间的值（那当然也就是 xmlns 所指定的那个 url 地址），value 是该 xml 文档结构文档的位置。</p>
<p>如果你打开后面那个 url 地址，你会真的看到一个文件，而且你单纯从格式上就能判断出来，这就是该 xml 文件的文档结构的具体内容。</p>
</li>
</ul>
<br>

<p>示例代码中，中间一共有六个配置项，逐一介绍：</p>
<ul>
<li><p><strong>modelVersion</strong></p>
<p>Maven 工程的模型版本，就目前而言只有一种参数可能：<code>4.0.0</code>。</p>
<p>但是即使如此，这一项也必须显式地配置出来，因为未来 Maven 可能会有更多的版本，例如 <code>4.0.1</code>、<code>5.0.0</code> 等等。到那时，如果遇到了没有配置模型版本的 xml 文件，将无法向前兼容。</p>
<br>
</li>
<li><p><strong>groupId</strong></p>
<p>公司或组织名称，是指本项目的归属人是谁。</p>
</li>
<li><p><strong>artifactId</strong></p>
<p>项目名称，例如一个公司有10个项目，各个项目相互区别就是通过这个 ID。</p>
<p>groupId 和 artifactId 两个 ID 一起构成了唯一索引，也就是说，一个 groupId 加上一个 artifactId，在这个世界上只能出现一次（除非是同一个项目的不同版本）。</p>
</li>
<li><p><strong>version</strong></p>
<p> 项目当前版本，格式为：主版本.次版本.增量版本-限定版本号。</p>
<p>限定版本号有两种：SNAPSHOT（快照）和  RELEASE（发布）。前者表示不稳定版本，可能会经常发生变化，后者是相对稳定的版本，版本不会频繁变动。</p>
<p>与 groupId 和 artifactId 联合构成 GAV，这三个值加在一起，可以精准地指向【一个特定版本的项目】。当别的项目要引入依赖，把别的项目加载进来时，必须指定这三个值。</p>
<br>
</li>
<li><p><strong>packaging</strong></p>
<p>项目打包之后的类型，有很多种，例如 jar、war、pom 等等，默认使用 jar（也就是说如果你不写这一行也可以，默认是 <code>&lt;packaging&gt;jar&lt;/packaging&gt;</code>）。</p>
<p>pom 类型是父 pom.xml 文件所使用的，比如有一个公共的 pom.xml 文件，其中配置了很多共性的配置，有四个子模块的 pom.xml 文件都可以直接引用该 pom.xml 文件，少配置一些内容。这个公共的 pom.xml 文件，就是父 pom 文件，它的构建类型就是 pom（即 <code>&lt;packaging&gt;pom&lt;/packaging&gt;</code>）。</p>
</li>
<li><p><strong>name</strong></p>
<p>项目的名称，Maven 生成文档时用的。</p>
</li>
</ul>
<p>还有很多很多很多可以配置的地方，这里只介绍了一点点（但是足够日常使用了）。</p>
<h1 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h1><p>以这段代码为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 省略了一些必要配置，只保留了依赖配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段示例 xml 代码共引入了两个外部依赖，分别是 junit（测试单元）和 joda-time（一个很好用的第三方时间类）。</p>
<ul>
<li><p><strong>dependencies</strong></p>
<p>在 dependencies 内可以存放多个 dependency，表示项目所引入的所有依赖。Maven 将自动地去仓库里寻找依赖包，从本地开始找，没有就去仓库找，再没有就去远程仓库找，每次在仓库里找到了都会下载到本地。如果依赖之间有版本上的冲突，先根据依赖深度判决，深度相同再根据先来后到的原则判决。</p>
</li>
<li><p><strong>dependency</strong></p>
<p>一个依赖包，其中包括 groupId、artifactId、version 等标签。</p>
</li>
<li><p><strong>groupId</strong>、<strong>artifactId</strong>、<strong>version</strong></p>
<p>GAV 三参数，依赖包所必需的标签，通过这三个标签才能找到一个特定版本的依赖包。</p>
</li>
<li><p><strong>scope</strong></p>
<p>依赖作用的范围，例如值为 test 时表示，只会在测试时引用该依赖，正式的版本不会依赖。</p>
<p>共有种，分别是：compile（全程，默认配置）、provided（类似于全程，但打包期可以被替代）、test（测试）、runtime（除了编译的全程阶段）、system（类似于全程，但依赖从本地文件抓取）。</p>
</li>
<li><p>其他</p>
<p>在父 pom 文件中，还可以配置 dependencyManagement，用法上和 dependencies 类似，可以作为集中化的依赖配置中心，可以配置依赖的版本号、作用域等等，子 pom 文件如果声明了一个 dependency，并且只配置了 groupId、artifactId 这两个参数，其他参数就会从父 pom 文件的 dependencyManagement 里找。（当然，如果自己填了其他参数，会以子配置为准）</p>
</li>
</ul>
<h1 id="继承、聚合"><a href="#继承、聚合" class="headerlink" title="继承、聚合"></a>继承、聚合</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.app.pz<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pz-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>pz-app-server<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>继承和聚合通常是对应存在的，父 pom 文件会标明聚合（modules）内容表示它的作用模块有哪些，子 pom 文件会标明继承（parent）内容，表示它继承自哪个 pom 文件。</p>
<ul>
<li><p><strong>parent</strong></p>
<p>parent 表示继承， 子 pom 可以使用 <code>parent</code> 指定父 pom。</p>
<p>parent 内需要明确写明的标签，依然是 GAV 三标签。</p>
</li>
<li><p><strong>modules</strong></p>
<p>modules 表示聚合，Java 的文件结构中，一个项目可以有多个模块，modules 内即是模块。</p>
<p>聚合内只需要放模块的名字即可。</p>
</li>
</ul>
<br>

<p>其他配置内容，例如 build、profile、plugin 等，用到再说吧。</p>
<hr>
<p>接下来看 Maven 的生命周期。</p>
<p>看了好多篇教程和博文，它们对 Maven 的生命周期的解释与描述，总让我觉得是相互冲突的，甚至在同一篇文章中都是冲突的。之后渐渐发现，原来 Maven 的生命周期并不只有一个，而是有三个，分别是 clean、default（or build）、site。也就是说“Maven 的生命周期”这种说法是不正确的，Maven 本身并没有生命周期，而应该是 Maven 的 <code>clean 生命周期</code>、<code>default 生命周期</code>、<code>site 生命周期</code>。再换句话说，“生命周期”这四个字，描述的不是 Maven，而是那三个词。</p>
<p>生命周期这个说法，在编程中是一个非常常见的概念。我觉得 Maven 在这里也使用生命周期这个词，是为了表达【阶段性】的概念。我以人为例，人的生命周期是 幼年 -&gt; 青年 -&gt; 中年 -&gt; 老年，那么当人值中年时，必定已经经历了幼年和青年。Maven 的三个生命周期，各自都有一些阶段，你可以不执行完全部的生命周期，可以只执行到中间的某个阶段，但是当你执行到这个阶段时，你一定已经执行完，在这之前的所有阶段了。</p>
<p>以下的内容主要参考来源为：<a href="https://www.runoob.com/maven/maven-build-life-cycle.html" target="_blank" rel="noopener">《Maven 构建生命周期》</a>。</p>
<h1 id="clean-生命周期"><a href="#clean-生命周期" class="headerlink" title="clean 生命周期"></a>clean 生命周期</h1><p>clean 生命周期包含三个阶段：</p>
<ul>
<li>pre-clean：执行一些需要在 clean 之前完成的工作</li>
<li>clean： 移除所有上一次构建生成的文件</li>
<li>post-clean：执行一些需要在 clean 之后立刻完成的工作</li>
</ul>
<p>这三个阶段，如果使用命令行执行的话，那么是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn pre-clean</span><br><span class="line"></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line">mvn post-clean</span><br></pre></td></tr></table></figure>

<p>再提一遍，下文不再提了。当执行 <code>mvn clean</code> 语句时，表示执行 pre-clean 阶段和 clean 阶段。当执行 <code>mvn post-clean</code> 语句时，表示执行 pre-clean 阶段、clean 阶段和 post-clean 阶段。总之，之前的阶段，全部执行。</p>
<p>具体的执行过程、原理，不叙。</p>
<h1 id="default-生命周期"><a href="#default-生命周期" class="headerlink" title="default 生命周期"></a>default 生命周期</h1><p>你光看 default 这个词就能看出来，这是 Maven 最重要的那个生命周期。这是 Maven 的构建生命周期，项目的编译、测试、打包、部署等等，都属于这个生命周期的范围。</p>
<p>default 生命周期共有 23 个阶段，其中重要的阶段是：</p>
<ul>
<li>validate：验证项目是否正确且所有必须信息是可用的</li>
<li>compile：编译代码</li>
<li>test：运行测试（例如 JUnit 单元）</li>
<li>package：打包，创建 jar 包、war 包等等</li>
<li>verify：对测试结果进行检查</li>
<li>install：把打包的内容安装到本地仓库中</li>
<li>deploy：把打包的内容部署到远程仓库中</li>
</ul>
<h1 id="site-生命周期"><a href="#site-生命周期" class="headerlink" title="site 生命周期"></a>site 生命周期</h1><p>site 生命周期用于创建报告文档、部署站点等等，包括以下四个阶段：</p>
<ul>
<li>pre-site：执行一些需要在生成站点文档之前完成的工作</li>
<li>site：生成项目的站点文档</li>
<li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li>
<li>site-deploy：将生成的站点文档部署到特定的服务器上</li>
</ul>
<hr>
<p>本来还想写写 Maven 的插件，哎懒了，反正大概就是在执行生命周期的某个阶段，打开 IDE 一般都会默认集成一些 Maven 的插件，可以不用自己写指令了。</p>
<p>这篇就写到这里叭。</p>
<br>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 关键字</title>
    <url>/2020/03/22/synchronized-%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<br>

<p>三月的第四周，踏（gǔn）平（jìn）并发大门。</p>
<p>这周来学习 synchronized 关键字，把使用方法和基本原理学清楚。</p>
<hr>
<p>我在春节放假之前特别膨胀，想一个周把 synchronized 和 JUC 实现的 Lock 都看完，结果两个月过去了，synchronized 还不会用。当初是想入门锁，写了一段介绍锁的开头，就写不下去了，我把那段开头粘贴过来：</p>
<blockquote>
<p>锁的出现，是多线程并发编程所需要的，如果程序在并发执行，同时对一个资源进行操作，这是很容易出现问题的：多个线程同时运行，就像是活在同一个地球上不同维度的生物，它们互相感知不到对方，却在操作同一个东西，可能操作着操作着，突然东西就不见了，或者变多了。这是因为它们在同时操作，而且操作的时候没有互相告知。</p>
<p>《Java 编程思想》对并发导致的问题是这么比喻的：</p>
<blockquote>
<p>想象一下，你坐在桌边手拿叉子，正要去叉盘子中的最后一片食物，当你的叉子就要够着它时，这片食物突然消失了。</p>
</blockquote>
<p>这个比喻有点草。</p>
</blockquote>
<p>Java 原生的有两种实现锁的机制，一种是通过底层实现的 synchronized 关键字，另一种是 Doug Lea 在 JDK1.5 实现的 <code>java.util.concurrent</code> 包中的 Lock 类。这两种方法一种是 Java 关键字，另一种是用对象的方式，两种都实现了并发状态下对公共资源的加锁。</p>
<p>这周来学习通过底层实现的 synchronized 关键字。</p>
<hr>
<h1 id="synchronized-原理铺垫"><a href="#synchronized-原理铺垫" class="headerlink" title="synchronized 原理铺垫"></a>synchronized 原理铺垫</h1><br>

<p>synchronized 是一个 Java 的关键字，能够对并发资源上锁，它由 JVM 实现，也就是说 synchronized 跟底层有关系。</p>
<p>synchronized 关键字从 JDK 1.0 就存在了，最开始是一种代价很大的保证线程安全的方法（但也是唯一一种），在 JDK 6 被重新设计，性能大大提升。这一性能提升，一方面归功于软件代码设计的进步，另一方面也要归功于硬件的发展。</p>
<br>

<h2 id="最初的-synchronized-关键字"><a href="#最初的-synchronized-关键字" class="headerlink" title="最初的 synchronized 关键字"></a>最初的 synchronized 关键字</h2><p>最开始的 synchronized 关键字，基于互斥同步的原理来实现。互斥同步的意思是说：如果一个线程在使用资源，另一个线程想要使用资源，就要等，等到能获取资源为止，这里的等就是互斥的表现，一方使用，另一方就不准使用（即阻塞）。互斥同步是一种很消耗性能的操作，这是因为实现互斥的方式：<code>阻塞</code>，是一种很消耗性能的操作。</p>
<p>这里要提到操作系统的用户态和内核态。主流的 Java 虚拟机对于 Java 线程的实现，是直接将 Java 线程映射到操作系统的原生内核线程之上的，因此实现线程阻塞和线程唤起，必须需要操作系统来帮忙完成，操作系统的用户态和内核态之间进行转换。一个线程尝试获取资源时，发生线程阻塞，这里的阻塞是操作系统来帮助进行的，操作系统由用户态转为内核态，在内核态状态下将这一条线程阻塞住。</p>
<p>用户态和内核态是很重要的操作系统的概念，这里不多进行学习，只记住有这么一回事就可以了。用户态和内核态在进行转换的过程中，需要保存上下文信息，将两种状态的信息都存储下来，这是很消耗资源的。因此互斥同步是很很消耗性能的，用户态和内核态之间进行转换消耗的处理器时间，甚至比同步状态下的代码执行时间还要长，这是一种非常重量级的操作，由此造成了最初的 synchronized 关键字性能很差。</p>
<h2 id="经过改进的-synchronized-关键字"><a href="#经过改进的-synchronized-关键字" class="headerlink" title="经过改进的 synchronized 关键字"></a>经过改进的 synchronized 关键字</h2><p>最初 synchronized 关键字性能差的原因，是因为互斥同步是通过线程阻塞来实现的，而线程阻塞必然导致操作系统在用户态和内核态之间做转换，因而性能差。如果 synchronized 关键字不通过互斥同步实现（不通过阻塞线程来实现安全），那么性能说不定就会好很多。</p>
<p>阻塞，是一种无奈之举，因为不阻塞住线程，就不敢保证操作数据的过程是安全的。不安全最常见的现象是：一条线程读取完数据进行操作，还没保存，另一条线程就修改了数据，那么这时再保存，就会无视刚刚修改的数据，换言之，另一条线程的操作被“无效化”了。</p>
<p>一种比较常见的处理办法是，获取资源时记录下数据的值，在保存的时候，先比对数据是否还是当时的大小，如果是，就默认资源没有问题，可以进行保存。这也就是并发中非常重要的概念：<code>CAS</code>（compare and swap - 比较后交换），先比较预期的数据，如果是预期的大小，就交换值（保存）。值得一提的是，<code>CAS</code> 是另一种实现线程安全的方式：JUC 包的核心逻辑。（但是这实际上还是有潜在问题的，比如我在早晨 10 点获取到数据知道是 1，在下午 5 点发现数据还是 1，这并不能保证数据在这段时间中没有被改过，有可能改了又改回来了，即“ABA 问题”，但好在大多数的情况下 ABA 问题不会影响程序并发的正确性）</p>
<p>如果通过 <code>CAS</code> 操作数据，就可以代替阻塞，性能提高。<code>CAS</code> 的英文原名是 compare &amp; swap，这是指 compare 和 swap 必须在一起进行，执行完 compare 就必须接着执行 swap，即这两个动作合在一起是原子性的，是不能拆开的。这也就是为什么 synchronized 关键字性能提升是需要借助于硬件技术的提高的，因为 <code>CAS</code> 必须由硬件执行，而不能是软件（如果是软件实现，那还是通过互斥同步的方式进行，这就没有意义了），最初的 cpu 在硬件指令集中是没有 <code>CAS</code> 操作的，之后才出现这一指令，JDK 5 的 Java 类库开始使用 <code>CAS</code> 操作，在 JDK 6 中使用该操作对 synchronized 进行了改造。</p>
<p>粗略地讲，synchronized 通过 <code>CAS</code> 操作进行改造的原理，是分了两种情况：如果只有一个线程使用资源（但在理论上有可能有别的线程抢资源），直接 <code>CAS</code> 保存数据就可以了，不需要阻塞线程；如果线程一多争抢资源，那没有办法，乖乖地阻塞线程，通过互斥同步来实现线程安全。</p>
<h2 id="顺带一提"><a href="#顺带一提" class="headerlink" title="顺带一提"></a>顺带一提</h2><p>原始的 synchronized 通过互斥同步来实现线程安全，新的 synchronized 通过 <code>CAS</code> 操作来部分实现线程安全，这实际上也是两种思路，两种在面对并发风险时的思路。</p>
<ol>
<li>互斥同步的思路是，有可能发生并发风险，那么我提前准备，一条线程使用，另一条线程就不准使用。</li>
<li><code>CAS</code> 的思路是，有可能发生并发风险，不用提前准备，先进行 <code>CAS</code> 操作保存，真发现了数据不一样再说。</li>
</ol>
<p>一种是提前应对风险，将风险扼杀在摇篮中，另一种是不管风险先进行操作，产生了冲突再进行补偿措施。这两种思路实际上就是锁机制当中的“乐观锁“和”悲观锁“的思路。乐观和悲观指的是面对并发风险时的态度：</p>
<ol>
<li>乐观的话，先不管风险，干了再说，有问题回来找补（对应于 <code>CAS</code> 操作）</li>
<li>悲观的话，先考虑风险，万无一失，再进行数据处理（对应于互斥同步）</li>
</ol>
<p>因此乐观锁回滚重试，悲观锁阻塞事务。JDK 6 之后的 synchronized 关键字就是先乐观，乐观不起来了再悲观。</p>
<hr>
<h1 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h1><br>

<p>学习 synchronized 关键字需要对 JVM 中对象的内存布局（尤其是对象头部分）有所了解。对象头的内容，我在上篇文章《对象的大小》中进行了详尽的描述，在此不多赘述，只将上篇文章中绘制的图放在下面。</p>
<p><img src="/assets/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg" alt="对象头"></p>
<p>对象存储在 JVM 堆里，鉴于内存寸土寸金，需要尽可能地缩减对象头的大小，因此对象头有五种状态，在不同的状态下存储不同的信息。上图的前四种与 synchronized 关键字有关，分别在【没有锁】、【偏向锁】、【轻量级锁】和【重量级锁】状态下，存储不同的信息。换个角度理解，这意味着 synchronized 也有四种场景。</p>
<p>synchronized 关键字的原理（改进之后），就像是开车挂挡，起步一档，速度上来之后挂二档，最后一脚油门上了三挡。</p>
<ol>
<li>如果只有一个线程在使用资源，那么挂一档：偏向锁</li>
<li>如果有少数几个线程在使用资源，那么挂二档：轻量级锁</li>
<li>如果有好几个线程在使用资源，那么挂三挡：重量级锁</li>
</ol>
<p>这三种档位是针对于 JDK 6 之后的 synchronized，在这之前起步直接三挡。</p>
<p>对应于这三个档位（外加上空挡）一共有四种状态，这四种状态的标志位如下：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>偏向模式(1 bit)</th>
<th>锁标志位(2 bit)</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>（没有该字段）</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>（没有该字段）</td>
<td>10</td>
</tr>
</tbody></table>
<br>

<p>（下文主要参考《深入理解 Java 虚拟机》书中的第 12、13 章，这本书写得非常出色，常给我一种醍醐灌顶之感）</p>
<br>

<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>对于上锁的对象，有一个资源争抢的升级过程。最开始的情况，是只有一条线程在使用资源，这时并不存在竞争的情况。如果不存在竞争，上锁是没有必要的，或者说上重量级的锁是没有必要的，毕竟没其他线程抢资源。</p>
<p>偏向锁的<code>偏向</code>，是“偏心”的“偏”、“偏袒”的“偏”，其含义是偏向线程，偏向于第一个获取到它的线程。如果之后一直没有其他线程出现，则持有偏向锁的线程永远不需要进行同步。如果出现了新的线程，偏向锁立即终止。</p>
<p>因此，如果只有一条线程使用资源，则使用偏向锁。如果出现了第二条线程，不论这两条线程是否存在竞争，锁都会膨胀，偏向锁即刻作废。（还是有一些例外的，比如根据<a href="https://zhuanlan.zhihu.com/p/71156910" target="_blank" rel="noopener">《通俗易懂 悲观锁、乐观锁……》</a>这篇博文提示，如果前一条线程死亡了，新的线程来申请资源，还是能继续使用偏向锁的）在这种意义上，偏向锁是不需要解锁的，因为它从始至终只会有一个锁的主人，出现了第二个主人时，它就作废了，没有解锁是偏向锁相比于轻量级锁、重量级锁的一个区别。</p>
<br>

<p>偏向锁的具体实现，实际上还是比较繁琐的。总体上讲，是把偏向线程的线程ID记录在对象头中，之后再此使用前比对线程ID，如果就是当前线程则无需同步，如果不是当前线程那么偏向锁立即停止使用。</p>
<p>细致地讲，偏向锁的上锁过程如下（自行对照上面对象头示意图）：</p>
<ol>
<li><p>确保可以上偏向锁</p>
<p>首先对象应处于未上锁状态（锁标志位是 01），且对象应为可偏向（偏向标志位是 1），因此对象头的标记部分应为 101 结尾。由于无锁和偏向锁的锁标志位是相同的（都是 01），因此另用 1 bit 来表示对象是否可偏向。JDK 6 下的 HotSpot 虚拟机默认开启偏向锁，可以手动设置参数关闭。</p>
<p>我印象中曾看过一篇博文（但是找不到了），他表述说对象最开始的偏向标志位是 0，过了短暂的时间之后，对象就会自动地将偏向标志位设为 1，但是我不敢确定。</p>
<p>参照上图，对象头在无锁的状态下会保存对象的哈希码（hashcode），实际上这并不一定，如果对象没有计算过哈希码（例如调用 Object :: hashCode() 会计算哈希码），那么哈希码将不会保存在对象头中。但一旦计算过哈希码，对象头中就会储存哈希码，这个对象就再也不会进入偏向锁状态了，如需上锁，它只会一步到位膨胀成重量级锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（附上 64 位 JVM 的对象头标记字段，在无锁和偏向锁状态下的内容：）</span><br><span class="line">|------------------------------------------------------------------------------|----------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |     Normal     |（无锁）</span><br><span class="line">|------------------------------------------------------------------------------|----------------|</span><br><span class="line">| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |     Biased     |（偏向锁）</span><br><span class="line">|------------------------------------------------------------------------------|----------------|</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 CAS 尝试上偏向锁</p>
<p>在确保对象进入偏向模式的前提下，JVM 将会使用 CAS 操作把获取到这个锁的线程的ID记录在对象的标记字段中（图中的对象头标记字段，在偏向模式下的偏向 ID 部分，32 位虚拟机占 23 bit，64 位虚拟机占 54 bit）。</p>
<p>如果 CAS 记录线程 ID 成功，那么认为偏向锁上锁成功，以后持有偏向锁的线程每次进入这个锁相关的同步块时，都不需要进行任何同步操作。</p>
<p>如果 CAS 记录线程 ID 失败，那么偏向模式马上就宣告结束。</p>
<ul>
<li><p>如果此时对象没有上锁，那么该对象将先撤销偏向（将偏向标志位设置为 0），再升级为轻量级锁（这一步的撤销偏向是有一定的性能损耗的）</p>
</li>
<li><p>如果此时对象已经上了偏向锁，那么该对象将继续申请轻量级锁</p>
<p>(下图为《深度理解 Java 虚拟机》的配图，描述了偏向锁膨胀到轻量级锁的过程)</p>
<p><img src="/assets/%E5%81%8F%E5%90%91%E9%94%81%E8%86%A8%E8%83%80%E5%88%B0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.jpg" alt="偏向锁膨胀到轻量级锁"></p>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>对象头的标记字段中，还有一个字段：偏向时间戳（epoch）</p>
<p>这个字段的作用是统计重偏向次数。重偏向的概念是这样的，如果有一个类实例化 20 个对象出来，这 20 个对象先经历线程 1，再经历线程 2，上锁时需要发生 20 次的撤销偏向，再升级到轻量级锁的过程。偏向锁的撤销是比较昂贵的（原理暂不考究），如果这种现象多次出现，就意味着这个类不适合使用偏向锁。</p>
<p>对于这种场景 JVM 单独做了优化，类记录了一个 epoch 值，对象在创建时也将有一个 epoch 值（创建时与类的相同）。如果类对象发生了一次大规模的撤销偏向行为，类的 epoch 值将加 1（以后创建的对象也会采用新的 epoch 值），如果类的 epoch 值超过某个阈值，则证明该类不适合使用偏向锁，以后的对象也将不会再使用偏向锁，直接使用轻量级锁。</p>
<p>对象头中的 epoch 值是为了和类的 epoch 值对比用的，如果不一样，则将直接膨胀到轻量级锁。</p>
</li>
</ol>
<br>

<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>当资源不再只被一条线程获取，出现了两个及以上的线程时，偏向锁立即作废，膨胀为轻量级锁。</p>
<p>轻量级锁存在的意义是，如果有多个线程获取资源，但是是交替获取的，并没有发生资源竞争的风险，那么加一个轻量级锁，保证其中一条线程在运行时另一条线程不会并行操作即可。因此轻量级锁的目的，是为了消除数据在无竞争情况下的同步原语，提高程序的运行性能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（附上 64 位 JVM 的对象头标记字段，在偏向锁和轻量级锁状态下的内容：）</span><br><span class="line">|---------------------------------------------------------------------|--------------------|</span><br><span class="line">| thread:54 |   epoch:2   | unused:1 | age:4 | biased_lock:1 | lock:2 |       Biased       |（偏向锁）</span><br><span class="line">|---------------------------------------------------------------------|--------------------|</span><br><span class="line">|                     ptr_to_lock_record                     | lock:2 | Lightweight Locked |（轻量级锁）</span><br><span class="line">|---------------------------------------------------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<p>无论是无锁还是偏向锁，这两种状态的锁标志位都是 01，都可以膨胀到轻量级锁，将锁标志位修改为 00。对于轻量级锁而言，上锁的对象，其对象头的标记字段只有两部分内容：分别是锁标志位（2 bit，值为 00），以及正在占有对象的线程ID。</p>
<p>无锁膨胀到轻量级锁的过程是这样的（偏向锁的话，要先撤销偏向到无锁状态，再进行膨胀）：</p>
<ol>
<li><p>确保对象没有被锁定，锁标志为是 01。</p>
</li>
<li><p>备份对象头的标记字段</p>
<p>将对象头的标记字段（Mark Word）拷贝到当前线程的栈帧中。也就是把那 8 字节包含着哈希码、分代年龄、偏向状态、锁标志位等信息的标记字段，存储在当前线程的 JVM 栈中。</p>
<p>标记字段保存在线程栈帧的地址，叫做“锁记录”（Lock Record），换种表述方法，这块 Lock Record 用来存储对象目前的 Mark Word 的拷贝。</p>
</li>
<li><p>CAS 更新对象头，上轻量级锁</p>
<p>虚拟机使用 CAS 操作尝试将对象头的 Mark Word 更新为指向 Lock Record 的指针（就是上一步中，线程栈帧备份对象头的地址），并将对象头的锁标记更新为轻量级锁（00）。</p>
<p>如果这步 CAS 操作能够成功，那么轻量级锁就上好了，如果没有成功，则证明在同一时间有多个线程在竞争资源，轻量级锁不再有效，锁进一步膨胀为重量级锁。</p>
</li>
</ol>
<p>如果对象已经上了轻量级锁，当有线程再次申请资源时：</p>
<ol>
<li>如果是同一个线程，则是一次锁重入。每次锁重入依旧会在线程栈帧中创建一个 Lock Record，只不过重入创建的 Lock Record 的值为 null，即它不再是对象头标记字段的备份。</li>
<li>如果是另一个线程，说明存在多个线程竞争锁，锁膨胀为重量级锁。</li>
</ol>
<p>轻量级锁有解锁的操作，当线程操作完对象资源后，需要将轻量级锁解除。解锁的方法，是将对象头的 Mark Word 和线程栈中的 Lock Record 通过 CAS 替换回来，如果 CAS 操作失败代表有其他线程在竞争资源，锁膨胀。</p>
<br>

<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>当出现两个或更多的线程，在同一时间操作资源时，会发生线程竞争，此时锁膨胀为最强的重量级锁，采取互斥同步的方式，让同一时间只有一个线程操作资源，其他线程阻塞等待。</p>
<p>重量级锁通过一个 monitor 对象实现多线程竞争时的互斥同步，monitor（监视器）是并发设计中很重要的设计，在不同的语言中有不同的实现（然而这些我都不会，我只了解一点点 JVM 的 monitor 设计哈哈）。monitor 作为监视器，监视的是资源，每一个类或者每一个对象只能有一个 monitor 对象，这个 monitor 由 JVM 创建，能够保证同一时间只会有一个线程使用资源，其他线程都乖乖阻塞。</p>
<p>在  JVM 中 monitor 是 ObjectMonitor 类的实例对象，该类源码由 C++ 编写，<a href="https://www.jianshu.com/p/c3313dcf2c23" target="_blank" rel="noopener">代码如下：</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//monitor进入数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;  <span class="comment">//线程的重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">//标识拥有该monitor的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//等待线程组成的双向循环链表，_WaitSet是第一个节点</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ; <span class="comment">//多线程竞争锁进入时的单项链表</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个类实例化的 monitor 对象，一对一地监控着每一个需要互斥同步的类或对象，由 <code>_owner</code> 属性记录并发竞争成功的线程，执行完后换下一个线程，实现重量级锁。如果有其他线程尝试获取 monitor，会由于线程重入次数不为 0 而被迫阻塞。</p>
<br>

<p>synchronized 是以代码块的形式使用的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 将 Java 代码解释成 CPU 原语时，解析 synchronized 关键字，会分别将代码块的<code>开始</code>和<code>结束</code>，解释成 <code>monitorenter</code> 和 <code>monitorexit</code>，这两个原语非常形象，就是进入 monitor 和离开 monitor。通过这两个 CPU 原语，JVM 使每个线程都要去 monitor 处报到，等待重新调度。</p>
<p>这部分我学习得很浅，粗略知道 JVM 使用 monitor 对象来实现互斥同步，实际上是在借助操作系统的互斥原语 mutex 实现。等以后对并发的理解更深厚了，再回来进行学习。</p>
<hr>
<h1 id="synchronized-使用"><a href="#synchronized-使用" class="headerlink" title="synchronized 使用"></a>synchronized 使用</h1><br>

<p>以下内容主要参考自<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=synchronized" target="_blank" rel="noopener">《CS-Notes Java 并发》</a>。</p>
<p>synchronized 关键字有四种使用表现，分别是同步对象、类、方法、静态方法，而同步方法和静态方法，实际上还是在同步对象和类，因此从原理上 synchronized 关键字同步的是对象或类。</p>
<br>

<h2 id="1-同步一个对象"><a href="#1-同步一个对象" class="headerlink" title="1.同步一个对象"></a>1.同步一个对象</h2><p>对任意一个对象加 synchronized，代码块当中的代码都会同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object object = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>例如下列代码：实现一个 Runnable 接口，按顺序打印 1-10</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// r1不同步</span></span><br><span class="line">Runnable r1 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r2同步</span></span><br><span class="line">Runnable r2 = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时在线程池中分别跑<code>不同步的 r1</code> 和<code>同步的 r2</code>，每次线程池中跑两个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">executorService.execute(r1);</span><br><span class="line">executorService.execute(r1);</span><br><span class="line"><span class="comment">// 打印结果：1 1 2 2 3 4 5 6 7 8 9 10 3 4 5 6 7 8 9 10 </span></span><br><span class="line"></span><br><span class="line">executorService.execute(r2);</span><br><span class="line">executorService.execute(r2);</span><br><span class="line"><span class="comment">// 打印结果：1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>

<br>

<p>一种非常常见的同步对象的方式，是在类方法中同步 this，即表示同步当前对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="2-同步一个类"><a href="#2-同步一个类" class="headerlink" title="2.同步一个类"></a>2.同步一个类</h2><p>当 synchronized 同步一个类时，使用该类的所有线程，无论是在操作哪一个对象，都将进行同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>例如如下代码：自定义一个 MyClass 类，该类只有一个按顺序打印 1-10 的方法。生成两个该类的对象，并调用两个线程分别执行这两个类的打印数字方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含打印数字方法的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个类对象</span></span><br><span class="line">MyClass clazz1 = <span class="keyword">new</span> MyClass();</span><br><span class="line">MyClass clazz2 = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在线程池中执行打印数字的方法</span></span><br><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">executorService.execute(() -&gt; clazz1.testSync());</span><br><span class="line">executorService.execute(() -&gt; clazz2.testSync());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：1 2 3 4 5 1 2 3 4 5 6 7 8 9 10 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>

<p>如果对类方法进行 synchronized 同步，同步的内容是一个类（任意一个类都可以），则可实现线程间的同步。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Object.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （其他代码略）打印结果：1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="3-同步一个方法"><a href="#3-同步一个方法" class="headerlink" title="3.同步一个方法"></a>3.同步一个方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它作用于同一个对象。（这就是 HashTable 不如 ConcurrentHashMap 的地方，因为它在方法上同步，锁住了整个对象，太过笨重）</p>
<br>

<h2 id="4-同步一个静态方法"><a href="#4-同步一个静态方法" class="headerlink" title="4.同步一个静态方法"></a>4.同步一个静态方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它作用于整个类。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>从 NIO 到 Netty</title>
    <url>/2020/09/05/%E4%BB%8E-NIO-%E5%88%B0-Netty/</url>
    <content><![CDATA[<br>

<p>八月整个月没有写一篇文章，有很多原因：尝试入门 Docker 和 Kubernetes 失败、（公司任务）调研 Prometheus、SkyWalking 等监控工具花了不少时间，以及想写 I/O 但入门门槛好高。八月过去了，九月份要重新拾起笔了。</p>
<p>九月的第一周，从 NIO 开始，一路趟到 Netty。</p>
<hr>
<p>这个月的目标，是以 Netty 为基，学习网络 I/O 和计算机网络，我本想通过一周的时间学完 Netty，结果一周过去了，刚刚明白这是个什么东西……Netty 的入门门槛比较高，首先需要有 NIO 的前导知识，其次要理解 Netty 多如牛毛的类设计。本周的目标是梳理清楚 NIO 和 Netty 都有哪些类。</p>
<p>先从 NIO 学起吧。</p>
<p>I/O(Input/Output) 即输入输出，入和出的标准指的是电脑内存，从磁盘流入内存、从网络流入内存，这些都叫做输入（Input），反之，从电脑内存流到外设，这些叫做输出（Output）。</p>
<p>I/O 是一项基本操作，从 JDK 1.0 开始就有了，而后在 JDK 1.4 和 JDK 1.7 又推出了新的 I/O 包。</p>
<ul>
<li>JDK 1.0 的 I/O 以 InputStream、OutputStream、Writer、Reader 为首，由于它们会阻塞程序的特点，这种最初的 I/O 又被称为 BIO(Blocking IO)。</li>
<li>JDK 1.4 的 I/O 被称为 NIO，N 有双层含义，即代表 Non-blocking（非阻塞），也代表 New（新）。见名知意，这一代的 I/O 的核心特点就是非阻塞。</li>
<li>JDK 1.7 的 I/O 被称为 AIO(Asynchronous IO)，Asynchronous 的意思是异步，这一代 I/O 的特点是异步（同时也是非阻塞的）。</li>
</ul>
<p>由于<a href="https://github.com/netty/netty/issues/2515" target="_blank" rel="noopener">各种原因</a>（核心原因是性能表现一般），Netty 最终没有选择最新的 AIO，而是基于 NIO 来实现。因此本篇也不学习 AIO 了，来学习相对旧一点的 NIO，至于 AIO 以后有机会再学习吧。</p>
<p>（NIO 部分主要参考自《<a href="https://www.javadoop.com/post/java-nio" target="_blank" rel="noopener">Java NIO：Buffer、Channel 和 Selector</a>》，讲得很好）</p>
<hr>
<p>NIO 有三大组件：Buffer、Channel、Selector。</p>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>Buffer 就是缓冲区，它本质上就是一块内存。读写都是它，读是从这块 Buffer 读到 cpu 里，写是 cpu 写到这块 Buffer 中。</p>
<p>Buffer 的子类有很多：</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>其中最重要的是 ByteBuffer，其他 xxxBuffer 都是 ByteBuffer 的包装类。</p>
<p>Buffer 可以理解为数组，ByteBuffer 就是 byte[]，IntBuffer 就是 int[]，这样理解起来很容易。</p>
<p>Buffer 有四个需要理解的概念：capacity、position、limit 和 mark。</p>
<h2 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h2><p>容量，也就是数字的大小，初始化后就不变了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化一块 capacity 为 1024 的 ByteBuffer</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>当前读/写的位置，初始是 0，写多少就是多少，读多少也就是多少。</p>
<p>比如一个长达 1024 的 Buffer 实例，写了 100 个 byte，position 就是 100。切换到读模式，position 再从 0 开始，读了 50 个 byte，position 就是 50。</p>
<h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>读/写的最大限制，写模式是就是 Buffer 的大小（capacity），读模式是实际数据的大小（比如长达 1024 的 Buffer 实例，写了 100 个 byte，切换到读模式，limit 就是 100）。</p>
<h2 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h2><p><code>mark 一下</code>的那个 mark，就是打点做一下标记。</p>
<p>比如在 position 为 10 的地方 mark 了一下，mark 就是 10，往里再写了 5 个 byte，觉得不对，回退一下，就可以回到上次 mark 的位置 10。</p>
<br>

<p>看图简单回顾一下 capacity、position 和 limit 这三个概念。（下图来源自 <a href="https://www.javadoop.com/post/java-nio" target="_blank" rel="noopener">javadoop</a> 博客，画得很好，我就不重画了）</p>
<p><img src="/assets/NIO-Buffer.png" alt="NIO-Buffer"></p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Channel 直译是通道，在理解和使用上都类似于原始 I/O 的流，只不过 I/O 流把读写拆开，拆成 InputStream 和 OutputStream，而 Channel 同时支持读写。</p>
<p>Channel 和上面所说的 Buffer 打交道，读写都是对 Channel 自己而言的，读是读 Channel，把数据从 Channel 填充到 Buffer 中，写是写 Channel，把 Buffer 中的数据写入到 Channel 中。</p>
<p>通常用到的 Channel 有四种：</p>
<ul>
<li><p>FileChannel：文件 Channel</p>
</li>
<li><p>DatagramChannel：UDP Channel（UDP:User Datagram Protocol，用户数据报协议）</p>
</li>
<li><p>SocketChannel：TCP Channel</p>
</li>
<li><p>ServerSocketChannel：监听 TCP 连接的 Channel，每建立一个连接都会创建一个 SocketChannel</p>
</li>
</ul>
<p>Channel 最常用的方法是 read() 和 write()，这两个方法都是 Channel 的实例方法，可能有些反直觉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把 channel 中的数据读到 buffer 里</span></span><br><span class="line">channel.read(buffer);</span><br><span class="line"><span class="comment">// 把 buffer 中的数据写到 channel 里</span></span><br><span class="line">channel.write(buffer);</span><br></pre></td></tr></table></figure>

<h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector 选择器，又被成为多路复用器。</p>
<p>多路复用是学通信专业课时经常听到的概念，意思是一个信道上同时传输多路信号，比如带宽 10 G 的信道，可以容纳 5 条 2 G 的信号同时传输。多路复用的意义，是把多个低速信道整合到一个高速信道进行传输，能够更高效地利用高速信道，避免浪费。Selector 是 I/O 领域的多路复用器，单个 I/O 操作消耗小，但是占用了整个线程，如果把所有的 I/O 操作集中在一起，就避免了浪费。</p>
<p>Selector 的原理我乍一看还有点复杂，涉及到操作系统的内容，先放一放吧，日后再学习。</p>
<p>Selector 的使用逻辑是这样的：创建一个全局唯一的 Selector，然后所有的 Channel 都注册到这个 Selector 里，并指明关心 Channel 的哪一种事件。然后让 Selector 一直监听，如果监听到有 Channel 被使用了，就用 Selector 调出 Channel 再进行操作。在整个流程中，Selector 是始终处于工作的，但是 Channel 并不是，注册完就该干什么干什么去了，当需要使用时，Selector 会唤醒它。下面是简要的使用代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个全局的 Selector 实例</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// 将 channel 注册到 selector 里，并指明 selector 只监听【channel 有数据可以进行读取】这件事</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// selector 获取监听到有事件的 channel</span></span><br><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line"><span class="comment">// 逐个处理有事件的 channel</span></span><br><span class="line"><span class="keyword">for</span> (SelectionKey key : selectedKeys) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Selector 一共可以监听四类 Channel 的时间（可同时监听多类），分别是：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>作用</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>SelectionKey.OP_READ</td>
<td>通道中有数据可以进行读取</td>
<td>1 &lt;&lt; 0（即 00000001）</td>
</tr>
<tr>
<td>SelectionKey.OP_WRITE</td>
<td>可以往通道中写入数据</td>
<td>1 &lt;&lt; 2（即 00000100）</td>
</tr>
<tr>
<td>SelectionKey.OP_CONNECT</td>
<td>成功建立 TCP 连接</td>
<td>1 &lt;&lt; 3（即 00001000）</td>
</tr>
<tr>
<td>SelectionKey.OP_ACCEPT</td>
<td>接受 TCP 连接</td>
<td>1 &lt;&lt; 4（即 00010000）</td>
</tr>
</tbody></table>
<hr>
<p>终于要说到 Netty 了。</p>
<p>Netty 是一套 I/O 框架，它在 NIO 的基础之上，完成了一整套代码，从某种程度上讲可以认为是对 NIO 的再包装。由于 JDK 提供的原生 IO API 都比较难用，Netty 使用起来简单且性能很高，因此获得了广泛的好评。通常情况下，大家在讨论 Netty，都是在讨论网络 IO。</p>
<p>Netty 的特点是异步、非阻塞、高性能，这三个定语边学习边体会吧。</p>
<p>初学 Netty 会有很高的学习门槛，因为 Netty 中的类实在是太多了，写一个 Hello World 程序也需要几十行代码，并且需要有 NIO 的先导知识。Netty 是基于 NIO 实现的，并且直接使用了 NIO 中 Channel 和 Selector 的概念（实现不一样，但是概念是一样的），因此上文简单介绍了 NIO 三大组件的概念，但是没有介绍具体的 API 方法（因为没必要）。</p>
<p>本周目的并不是学通 Netty，而至少了解 Netty 的基本类有哪些。下面开始拆解着学习 Netty 的各个类。</p>
<h1 id="Channel-1"><a href="#Channel-1" class="headerlink" title="Channel"></a>Channel</h1><p>概念同 NIO 的 Channel，是 I/O 操作的核心，用以 read、write、connect、bind 等。</p>
<p>我们只关注两个类，分别是充当服务端的 NioServerSocketChannel，以及充当客户端的 NioSocketChannel。</p>
<p><img src="/assets/Netty_Channel.jpg" alt="Netty_Channel"></p>
<p>Netty 的 Channel 是全部重新设计的，图中两个 Channel 子类都间接实现了 Channel 接口，但是这个 Channel 接口实际上是 Netty 自定义的接口，而非 NIO 的 Channel。</p>
<br>

<p>在使用上，Netty 的 Channel 和 JDK 的 Channel 是一一对应的：</p>
<table>
<thead>
<tr>
<th>Netty</th>
<th>NIO</th>
</tr>
</thead>
<tbody><tr>
<td>NioServerSocketChannel</td>
<td>ServerSocketChannel</td>
</tr>
<tr>
<td>NioSocketChannel</td>
<td>SocketChannel</td>
</tr>
</tbody></table>
<br>

<p>具体的实现是：Netty 各种 Channel 子类都继承自 AbstractNioChannel，这个类的其中一个实例变量就是 NIO 的 Channel 实例，换句话说，Netty 中每个 Channel 的内部，都包着一个 NIO 的 Channel 实例。</p>
<p>（下图来源自《<a href="https://www.javadoop.com/post/netty-part-2" target="_blank" rel="noopener">Netty 源码解析（二） - Netty 中的 Channel</a>》）</p>
<p><img src="/assets/Netty-NIO-Channel.png" alt="Netty-NIO-Channel"></p>
<p>Netty 的 Channel 枝叶繁杂，每个类内部又有一大堆的方法，为了方便起见，这里只看 NioServerSocketChannel 和 NioSocketChannel 这两个的构造方法。</p>
<h2 id="new-NioServerSocketChannel"><a href="#new-NioServerSocketChannel" class="headerlink" title="new NioServerSocketChannel()"></a>new NioServerSocketChannel()</h2><ul>
<li>在本类中，设置了 config 成员变量，它是 Channel 的配置，内部保存了 JavaSocket，并做了些别的事</li>
<li>在父类的父类 AbstractNioChannel 中<ul>
<li>设置了 NIO 的 ServerSocketChannel</li>
<li>设置了 readInterestOp 为 SelectionKey.OP_ACCEPT，这代表接收数据时操作为 accept</li>
<li>设置了 Channel 为非阻塞</li>
</ul>
</li>
<li>在父类的父类的父类 AbstractChannel 中，设置了 pipeline、unsafe 和其他成员变量</li>
</ul>
<h2 id="new-NioSocketChannel"><a href="#new-NioSocketChannel" class="headerlink" title="new NioSocketChannel()"></a>new NioSocketChannel()</h2><ul>
<li>在本类中，设置了 config 成员变量，它是 Channel 的配置，内部保存了 JavaSocket，并做了些别的事</li>
<li>在父类的父类 AbstractNioChannel 中<ul>
<li>设置了 NIO 的 ServerSocketChannel</li>
<li>设置了 readInterestOp 为 SelectionKey.OP_READ，这代表接收数据时操作为 read</li>
<li>设置了 Channel 为非阻塞</li>
</ul>
</li>
<li>在父类的父类的父类 AbstractChannel 中，设置了 pipeline、unsafe 和其他成员变量</li>
</ul>
<p>能够看出，这两种 Channel 的构造方法只有一处不一样：设置接收数据时操作一个是 accept，一个是 read。</p>
<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><blockquote>
<p>AbstractBootstrap is a helper class that makes it easy to bootstrap a Channel.（Javadoc 解释）</p>
</blockquote>
<p>AbstractBootstrap 是一个帮助类，可以用来轻松地创建 Channel。</p>
<p>我们只关注两个类，分别是帮助创建 NioSocketChannel 的 Bootstrap，以及帮助创建 NioServerSocketChannel 的 ServerBootstrap。</p>
<p><img src="/assets/Netty_Bootstrap.jpg" alt="Netty_Bootstrap"></p>
<p>bootstrap 是一个计算机中通用的概念，代表“引导程序”，Spring Boot 的 <code>boot</code> 也是相同的概念，可以认为是 bootstrap 的缩写，意思是“一种简单快速的配置方式”。知乎上能够查到这个词的出处：《<a href="https://www.zhihu.com/question/28257837/answer/206689697" target="_blank" rel="noopener">Boot 一词是为什么被用作计算机并作为引导解释的？或者说他的由来？</a>》，挺有意思的。</p>
<p>Netty 中 Channel 是一个巨无霸的设计，里面有特别多的内容，Bootstrap 类是 Netty 提供的工厂类，用来便捷地创建 Channel 实例。</p>
<p>初学 Netty 时几乎所有的工夫都花在 Bootstrap 上，我们下一周专门来学它。</p>
<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>处理器，处理一个 I/O 事件或拦截一个 I/O 事件。</p>
<p><img src="/assets/Netty_Handler.jpg" alt="Netty_Handler"></p>
<p>每个 Channel 内部都有一个 pipeline（流水线），所有 I/O 事件都会经过这条 pipeline 被加工处理，pipeline 由多个 handler 构成，也就是一个由 handler 构成的双向链表。（下图依然来源于《<a href="https://www.javadoop.com/post/netty-part-4" target="_blank" rel="noopener">Netty 源码解析……</a>》）</p>
<p><img src="/assets/Netty_pipeline.png" alt="Netty_pipeline"></p>
<p>Netty 在整体上把 Handler 分成两类：inbound 和 outbound，并各自派生出一条路线。inbound 代表 I/O 操作往内部进行，例如 read、accept，而 outbound 代表 I/O 操作往外部进行，例如 write、connect、flush。</p>
<p>ChannelInboundHandler 和 ChannelOutboundHandler 这两个 handler 都是接口，定义了一些方法，而两个 xxxAdapter 是它们的实现类。</p>
<p>ChannelInitializer 是一个特殊的 handler，它本身是一个 handler，但它的实际作用是包装着别的 handler。也就是说，当把 ChannelInitializer  加入到 pipeline，就相当于把它包着的一堆 handler 都加入到 pipeline 中。这跟 Bootstrap 的设计有关，下一篇重点讲。</p>
<p>除了 inbound 和 outbound 之外，还有一种 duplex（双向），它同时支持 in 和 out，比如 LoggingHandler 就是这种类型。</p>
<h1 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h1><p>Netty 的线程和线程池。</p>
<p><img src="/assets/Netty_EventLoop.jpg" alt="Netty_EventLoop"></p>
<p>EventLoop 直译为“事件循环”，其实就是一个线程，一个复用的线程。同理 EventLoopGroup 就是管理线程的线程池。</p>
<p>我们学习的是 NioEventLoop，这个类的继承路线很庞大，学习起来也比较痛苦，仅一个构造方法就要辗转十个类左右，不停地调用父类的构造方法。</p>
<p>理解 Netty 的线程模型还是较为困难的，我们下篇或者下下篇再学习 EventLoop 的构造方法与工作流程。</p>
<h1 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h1><p>Netty 中的各种异步调用，就是使用这套 Future 体系。</p>
<p><img src="/assets/ChannelFuture.jpg" alt="ChannelFuture"></p>
<p>Netty 在 JUC 的 Future 基础上又创建了一个 Future（看上图，有两个 Future 类），并根据这个 Future 衍生出 ChannelFuture 和 Promise 两条路，这两条路最终在 DefaultChannelPromise 汇合。</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Netty 对 JUC 的 Future 进行了扩充，增加了一系列的方法，大致可以分成三类：</p>
<ol>
<li>isSuccess()、isCancellable() 等方法，获取异步任务的状态。</li>
<li>sync()、await() 等方法，阻塞获取异步任务的结果，没执行完就等到执行完。</li>
<li>addListener(…) 等 listener 相关方法，增加 listener 监听。</li>
</ol>
<p>虽然我们还没有看实现类，但是可以先提前学习一个知识点：Netty 中使用 Future 处理异步事件是有两套方式的。</p>
<ol>
<li>第一种方式，创建好异步任务之后，阻塞干等，什么时候等到异步执行结束带回来结果，什么时候继续往下执行。（调用 Future 实例的 sync() 或者 await() 方法，程序阻塞，一直等到异步任务完成为止，获取到完成后的结果，程序继续）</li>
<li>第二种方式，创建好异步任务之后，设置好 listener 监听的回调事件，当异步任务执行结束后，让异步任务自己去调用方法，主程序不掺和了。（调用 Future 实例的 addListener(…) 设置监听回调事件，异步任务一执行完毕，就去调用回调方法，全部过程都跟主程序无关）</li>
</ol>
<h2 id="ChannelFuture-1"><a href="#ChannelFuture-1" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><p>ChannelFuture 几乎跟 Future 接口一模一样，只是在 Future 接口的基础上，增加了 channel() 方法。也就是说，ChannelFuture 实际上就是把 Future 和 I/O 操作中的 Channel 关联在一起，用于异步处理 Channel 中的事件。</p>
<p>简单来说，ChannelFuture 就是 Future + Channel。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 概念抽象一点，它的意思是“许诺，约定”，它在 Future 的基础之上增加了 setSuccess()、setFailure() 之类的方法，可以设置 Future 异步任务的完成结果。Javadoc 这么形容这个类：</p>
<blockquote>
<p>Special Future which is writable.</p>
</blockquote>
<p>它是一个“可写”的 Future。</p>
<p>再说得清楚一点，Promise 是一个 set 类型的 Future，它可以人工设置 Future 的执行成功与失败。</p>
<p>Promise 在 set 任务成功或失败时，可以在 set 之后去通知所有监听的 listener，去执行回调方法，也就是我们刚才说的 Future 处理异步事件的第二种方式。</p>
<br>

<p>《<a href="https://www.javadoop.com/post/netty-part-3" target="_blank" rel="noopener">Netty 源码解析……</a>》对 Future 的两种的处理异步事件方式的解读，比我要清晰很多，我抄一下：</p>
<blockquote>
<p>……有两种编程方式，一种是用 await()，等 await() 方法返回后，得到 promise 的执行结果，然后处理它；另一种就是提供 Listener 实例，我们不太关心任务什么时候会执行完，只要它执行完了以后会去执行 listener 中的处理方法就行。</p>
</blockquote>
<br>

<p>总结一下 Netty 的 Future 体系：Netty 重新定义了 Future，并延伸出两种路线，一种是 ChannelFuture（把 Future 和 Channel 绑定在一起），另一种是 Promise（可以设置 Future 的执行结果），最常使用的 DefaultChannelPromise 是两种路线的实现类。</p>
<hr>
<p>本周就写到这里，铺垫了 NIO 和 Netty 的基础知识，下周就正式学习 Netty 的实现了。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/04/14/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<br>

<p>从本周开始，新增一个博文模块 <code>Random Post</code>，用于不定期的学习与整理，原本的每周博文 <code>Weekly Post</code> 仍是主要更新计划（名为每周实则随缘hhh），当每周时间有余，或者不屑于将学习内容作为周计划时，在此更新。</p>
<p>本篇是该模块的第一篇文章，学习单例模式。我在随缘学习单例模式时，发现这种设计模式的水很深，不是 Java 初学人员能够完全理解的，涉及到并发基础、类加载过程、枚举设计等内容，因此来写篇文章整理一下。</p>
<p>本文主要参考自博文<a href="https://www.javadoop.com/post/design-pattern#toc_4" target="_blank" rel="noopener">《设计模式也可以这么简单》</a>的单例模式部分。</p>
<hr>
<p>单例模式，GOF 分类下（最常见的那种分类）的 23 种设计模式之一，创建型模式中的一种，面试常备题目之一。</p>
<p>单例模式的意思是，类必须保证只有一个实例存在，整个系统，所有线程，可以有并且最多只能有一个该类的对象，这是一个针对于整个程序而言的全局对象。通常的实现思路是，该类提供一个静态的获取实例对象的方法（方法名通常为 getInstance），并且将构造函数定义为私有方法（这样就不能 new 对象出来了）。</p>
<p>单例模式有多种实现方式，常见的有四种，分别是饿汉模式、懒汉模式、嵌套类、枚举。</p>
<h1 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h1><p>饿汉模式（Eager Initialization）和懒汉模式（Lazy Initialization），这两个名字的翻译，让我觉得早期的程序员都是上海电影译制厂的配音演员退休转业来的，硬是拉大了本就已经存在的文化代沟，垃圾翻译。</p>
<ul>
<li><p>饿汉模式的意思是，不管是否使用都抢着在第一时间加载。</p>
</li>
<li><p>懒汉模式的意思是，什么时候要用了，什么时候再加载。</p>
</li>
</ul>
<p>厘清两汉区别之后，我们先来看饿汉模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先，将构造函数定义为私有方法，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（以下内容基本来源于《深入理解 Java 虚拟机》第七章，但可能因为我自身理解不足导致有错误）</p>
<p>饿汉模式创建对象的时机，是在类加载过程中，当类加载完成之后，无论是否需要，此时单例对象都已经被创建了。饿汉模式实现单例模式要靠 static 关键字，而理解 static 关键字需要了解类加载机制。</p>
<p><img src="/assets/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="类的生命周期"></p>
<p>一个类的生命周期有七个阶段，如上图，其中前五个阶段是类加载的过程，分别是：</p>
<ul>
<li>加载（Loading）</li>
<li>验证（Verification）</li>
<li>准备（Preparation）</li>
<li>解析（Resolution）</li>
<li>初始化（Initialization）</li>
</ul>
<p>中间三个阶段又可以统称为连接（Linking）阶段。</p>
<p>以上五个类加载阶段基本上交由 Java 虚拟机主导控制，而不是由业务程序去控制。</p>
<p>对于小白而言，一个很反直觉的地方在于，类加载过程（即上面的五个阶段），并不是在编译期执行完成的，而是在程序的运行期间完成的，如果类没有被用到，那么类就不会被加载，如果用到了就在程序运行过程中现场加载。这种设计为 Java 提供了极高的扩展性和动态连接性，当程序运行之后，仍然可以在不停机的情况下输入新的类，比如从网络上加载一段二进制流作为程序的一部分。</p>
<p>Java 虚拟机规范中，对于类加载过程的约束是相当宽容的，这使得不同的 Java 虚拟机可以按照编写人员自己的想法来设计。比如对于不同的 Java 虚拟机而言，最开始的加载阶段需要在什么时候完成，随便你，各个阶段能否交叉混合执行，随便你，各个阶段具体要做什么事情，（在保证一定前提下）随便你。当然还是有一些限制，在这里需要指出的有两点：</p>
<ol>
<li><p>加载、验证、准备、初始化这四个阶段（即除了解析之外的类加载阶段），开始执行的顺序必须如图依次开始（但是允许上一个阶段没执行完，下一个阶段就已经开始）。</p>
</li>
<li><p>明确地说明了，初始化阶段的执行时机，并且是有且仅有这些场景下，Java 虚拟机需要立即执行初始化过程。场景还是挺多的，就不一一列举了，其中包括：</p>
<ul>
<li>使用 new 关键字实例化对象的时候</li>
<li>调用一个类型的静态方法的时候</li>
</ul>
<p>这也隐性地规定了，在这些场景之下，加载、验证、准备这三个阶段也已经开始执行（因为要按顺序开始）。</p>
</li>
</ol>
<p>因此，当 new 一个对象，或者调用一个对象的静态方法时（正如饿汉模式示例代码中的 <code>getInstance()</code> 方法），类加载过程一定会被执行，且执行完毕。</p>
<br>

<p>简单地描述一下，各个阶段分别在做什么事情：</p>
<ul>
<li>加载：获取类的二进制字节流，并存储在方法区中（存储格式由 JVM 自行决定）</li>
<li>验证：确保二进制字节流格式等合规</li>
<li>准备：为静态变量（被 static 修饰的变量）分配空间并设置初始值（请注意是初始值，比如 int 类型设为 0）</li>
<li>解析：（没懂）将常量池内的符号引用替换为直接引用</li>
<li>初始化：执行类构造器 <code>&lt;clinit&gt;()</code> 方法，该方法执行类变量的赋值动作、并执行 static 块中的内容。该方法在多线程环境下会被加锁同步执行，确保多线程环境下类只会被加载一次。</li>
</ul>
<p>总结一下，饿汉模式创建对象实例，会在准备阶段分配出空间，并在初始化阶段进行真正的赋值，这一切都发生在类加载过程中，当类加载阶段结束之后，饿汉模式的单例就已经被创建出来了。</p>
<br>

<p>如果要给饿汉模式一个缺点，那么如果该类里面有一个静态方法，执行该类的静态方法，就会触发初始化阶段，从而导致该类的单例对象也会被一同创建，浪费了性能和空间。（但是我觉得，生产中似乎没有这种可能吧，通过饿汉模式写了一个类，不要该类的实例对象，反而只调用该类的一个静态方法，这么任性吗？）</p>
<hr>
<h1 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h1><p>懒汉模式（也有叫饱汉模式的，都是垃圾翻译）有多种实现代码，这主要是因为懒汉模式的创建逻辑是懒加载，当程序需要单例对象时才创建，而创建的过程中有并发风险，为了处理并发风险，就出现了多种处理方式。</p>
<p>我在这里不循序渐进地写多套代码，直接把最好的一种复制如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉模式需要对并发、Java 的内存模型有一定认识，主要是要理解 volatile 关键字，这里只解释 volatile 的作用。</p>
<p>volatile 关键字主要实现两方面的作用：内存可见性、禁止重排序，懒汉模式使用 volatile 修饰单例对象，是用到了第二个特性，禁止指令重排序。但我们还是按顺序说，先讲内存可见性。</p>
<ol>
<li><p>内存可见性</p>
<p>内存可见性的问题，指的是如果多条线程同时操作资源，这边改变了数据，另一边能否及时知道数据发生了改变。</p>
<p>共享变量的可见性问题，不是由于多核导致的，而是由于多缓存导致的，所有的共享变量都存储在主内存中，每个线程也有自己独自的本地内存，这种设计能够加快运算速度，但导致了内存可见性的问题。</p>
<p>学习内存可见性应当去学习 Java 内存模型，这里分享一篇博文<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%e5%8d%81%e3%80%81java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b" target="_blank" rel="noopener">《Java 并发 - Java 内存模型》</a>。</p>
</li>
<li><p>禁止重排序</p>
<p>为了运行更快，编译器、CPU、内存系统都进行了重排序，下列三行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;      <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">20</span>;      <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">int</span> sum = i + j; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>从代码上看，执行顺序应该是 1 2 3，但是实际的执行顺序有可能是 2 1 3。</p>
<p>我原来一直不理解重排序有什么影响，后来我才明白：对于单线程而言确实是没有影响，即使重排序了，实际的执行逻辑也不会有变化，但是多线程情况下就不一定了，当存在数据竞争的情况时，重排序可能会导致违反直觉的现象发生。</p>
<p>这里就以懒汉模式为例，说明如果发生重排序，可能会发生什么问题：</p>
<p>在 synchronized 代码块中，<code>instance = new Singleton();</code> 这行实例化对象的代码，可以拆分成三个指令（可参考《Java 并发编程的艺术》）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1. 分配内存 相当于c的malloc</span></span><br><span class="line">ctorInstanc(memory);  <span class="comment">// 2. 初始化对象</span></span><br><span class="line">s = memory;           <span class="comment">// 3. 设置s指向刚分配的地址</span></span><br></pre></td></tr></table></figure>

<p>new 对象的过程可以拆解为：</p>
<ul>
<li>首先 JVM 将申请一块空间（1）</li>
<li>然后执行构造方法为属性赋值（2）</li>
<li>最后让对象指向刚刚分配好的地址（3）。</li>
</ul>
<p>如果发生指令重排序，那么 new 对象的过程就有可能变成：</p>
<ul>
<li>首先 JVM 将申请一块空间（1）</li>
<li>让对象指向刚刚分配好的地址（3）</li>
<li>执行构造方法为属性赋值（2）</li>
</ul>
<p>如果只有一条线程则没问题，但出现了另一条线程，执行 getInstance() 方法时，先检查单例对象 instance 是否为空（<code>if (instance == null)</code>），完全有可能检查到 instance 不为空（因为已经指向了刚刚分配好的地址），但是 instance 还没有执行完构造方法，最终拿到了一个没真正创建完毕的对象。</p>
<br>

<p>volatile 关键字实现的第二个作用，就是禁止指令重排序。（顺便一提，不光是禁止两个被 volatile 修饰的属性，在操作上不能重排序，而且被 volatile 修饰的属性，和它周围的普通属性的相关操作都不能重排序）。</p>
<p>被 volatile 修饰的单例对象，将严格按照指令顺序被创建，因此不存在问题。</p>
</li>
</ol>
<br>

<hr>
<h1 id="嵌套类方式"><a href="#嵌套类方式" class="headerlink" title="嵌套类方式"></a>嵌套类方式</h1><p>先看代码吧，然后再解释一下嵌套类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，还是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先解释一下嵌套类是什么。</p>
<p>Java 中，类的内部也可以有类，这种情况被称为嵌套类（nested class），嵌套类分为两种，分别是静态嵌套类（static nested class）和内部类（inner class）。</p>
<p>我认为，这里要从文法的角度上琢磨一下语义，请注意，Java 中把类中有类的现象称为嵌套类，嵌套是一种位置性的描述词语，只是在描述两个类的位置关系，并没有从属关系。也就是说，两个类是嵌套关系，并不能认为其中一个类归属于另一个类，而只是从位置上来讲，一个类出现在了另一个类的里面，但是是否有从属关系，这个不好说。嵌套类中有一种情况是内部类，内部（inner）就有一定的归属关系了，如果一个类是另一个类的内部类，就说明这个类是归属于另一个类，是任另一个类操纵的。</p>
<p>我认为这种文法上的理解是很有必要的，对于访问权限、类加载时机等等的理解都是有帮助的。</p>
<p>Java 从语言语法上对嵌套类的区分，是判断有没有 static 关键字：</p>
<ul>
<li><p>静态嵌套类（static nested class），有 static 修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有static -&gt; 静态嵌套类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内部类（inner classer），没有 static 修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有static -&gt; 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类还可以再细分为三种，主要是在访问权限上的区别，这里为了主干清晰，就不介绍了。</p>
</li>
</ul>
<p>在民间叫法上，往往把这两种情况都称为“内部类”，因为从直观的角度上看，这两种好像都是“类中类”，感觉都是内部的，因此民间往往把带有 static 关键字的称为静态内部类（也就是官方说的静态嵌套类），而把没有 static 关键字的称为内部类。这种叫法非常广泛，也有一定的道理，但我觉得这种叫法会模糊意义，具有迷惑性，最好不要这么称呼。</p>
<p>还有一种民间声音，把静态嵌套类直接称为嵌套类，也就是说”类中类“分为两种，分别是嵌套类和内部类，这种叫法很坚决地表明了区别，我觉得还有点道理。</p>
<p>下图是几种称呼的示意图：</p>
<p><img src="/assets/%E5%B5%8C%E5%A5%97%E7%B1%BB%E7%9A%84%E7%A7%B0%E5%91%BC.jpg" alt="嵌套类的称呼"></p>
<p>这里的单例模式，是通过静态嵌套类来实现的，接下来讨论一下原理。</p>
<p>从语法层面，静态嵌套类和内部类的区别，在于类是否被 static 修饰，然后根据 static 访问权限划分出了不同的用法，例如“static 语句块中不能使用 non- static 语句”、“内部类不能有 static 变量”、“static 的类加载时机不同”等等的问题。</p>
<p>通过语法进行解释这两种类型的区别，当然是可以的，但如果揣摩为什么这么设计的原因，应该会更易理解和记忆很多。静态嵌套类和内部类的区别，从 Java 设计的角度上讲，是跟外部类的关系是不一样的：静态嵌套类跟外部类可以说是没什么关系（除了位置特殊了些），但是内部类要依赖于外部类，它可以视为外部类的一个成员。</p>
<ul>
<li><p>静态嵌套类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以认为，A 类（外部类）和 B 类（静态嵌套类）是没有关系的，这里的没有关系体现在：</p>
<ul>
<li>不需要实例化 A 类出来，就可以实例化 B 类</li>
<li>B 类不能直接访问 A 类的非静态变量（只能直接访问 A 类的静态变量，即类变量，访问类变量是不需要先获取对象的）</li>
<li>A 类和 B 类的类加载时间没有关系，如果完全可以 A 类加载了，但是 B 类还没有加载（这是实现单例模式的核心）</li>
</ul>
<p>值得一提的是，静态嵌套类是可以用 private、protected、public 修饰的，指的是访问它的权限，比如如果是 public 的话，那么所有地方都可以访问该静态嵌套类，但是如果是 private 修饰的话，只有外部类可以访问静态嵌套类。</p>
</li>
<li><p>内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 A 类（外部类）和 C 类（内部类）之间是有关系的，这种关系大概像是“A 有一个成员变量 C”，具体体现在：</p>
<ul>
<li>A 类没有实例化出来之前，C 类不能创建，就像是一个对象成员变量一样</li>
<li>C 类可以访问 A 类的所有变量，无论是否是静态变量</li>
<li>C 类可以自定义变量，但是不能有自己的静态变量（因为没有必要，这里可以自己多想一下）</li>
</ul>
</li>
</ul>
<br>

<p>我们来回头看一下这里单例模式的实现。</p>
<p>外部类中套一个静态嵌套类，外部类进行类加载时，静态嵌套类并没有加载，而当调用了外部类的 <code>getInstance()</code> 方法之后，该方法会触发静态嵌套类进行类加载（这里跟饿汉模式是一样的原理），然后实例化出来想要的单例。</p>
<p>因此通过嵌套类实现单例模式，实际上就是饿汉模式的一种特殊使用方法，通过类套类的方式，延时加载了饿汉模式。这是最方便实用的一种单例模式。</p>
<br>

<hr>
<h1 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，还是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举创建单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> SingletonEnum &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">        SingletonEnum() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外暴露的获取单例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式怎么说呢，人人都夸，人人都不用hhh</p>
<p>简单的讲，枚举类会在类加载时，初始化所有实例，由 JVM 保证它们不会再被实例化，天生就实现了单例模式。</p>
<p>（以下内容来源自知乎文章<a href="https://zhuanlan.zhihu.com/p/55327937" target="_blank" rel="noopener">《枚举的本质》</a>，建议直接阅读）</p>
<p>在类加载过程中，枚举中定义的枚举值，实际上是一个个的 <code>static final</code> 的变量，并且会被直接赋值，不存在再次被实例化的可能。</p>
<p>下面写一段很简单的枚举代码，定义了一个水果的枚举类，并且规定有一个金额的属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Fruit &#123;</span><br><span class="line">    </span><br><span class="line">    APPLE(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    Noodle(<span class="keyword">int</span> money)&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码经过反编译之后，可以等效为如下代码（经过了删减）：</p>
<p>可以看出，枚举值实际上是一个静态的 final 变量，并且会在类加载的过程中就被赋值（static 代码块中的内容会在类加载过程中被执行），因此保证了单例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Fruit APPLE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Fruit</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">        code = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        APPLE = <span class="keyword">new</span> Fruit(<span class="string">"APPLE"</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多说一点有关枚举的知识点：</p>
<ul>
<li>枚举类实际上继承自 Enum 类（参照上面的反编译代码），因此枚举类均不能继承（因为 Java 单继承）</li>
<li>枚举类默认有两个成员变量（可以自行增加更多的），分别是 <code>name</code> 和 <code>ordinal</code>，代表枚举值的名字和顺序，<code>toString()</code> 方法重写为返回 <code>name</code>。</li>
<li>枚举值使用 <code>==</code> 和 <code>equals()</code> 进行比较，作用是相同的，枚举类的 <code>equals()</code> 经过重写，实际上就是 <code>==</code>，其含义是比较内存地址（由于天生单例，所以通过地址就可以判断是否是同一个）</li>
<li>枚举不允许克隆和反序列化，永远保证单例（因此很安全）</li>
<li>枚举类有两个方法：<code>values()</code> 返回所有枚举值、<code>valueOf()</code> 根据 <code>name</code> 返回枚举值。</li>
</ul>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>各容器迭代器的实现</title>
    <url>/2019/12/08/%E5%90%84%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<br>

<p>十二月的第二周，来学习迭代器在各个容器中的具体实现。</p>
<p>不知道自己能看多少，ArrayList 和 HashSet 的实现是应该必须看完的，如果时间有余也要看看 TreeSet 的实现（哈哈哈……不相信自己的苍白的微笑）。</p>
<p>这周的目标应该不是在迭代器上，而是在容器设计和怎么看源码这两件事上。迭代器是因和果，但从因走到果的那条路是更有价值的。</p>
<hr>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList 是可调整大小的 List，实现了两种迭代器：迭代器、列表迭代器。</p>
<p>列表迭代器是在原本迭代器的基础上增加了顺序，例如增加了<code>是否有前一个元素</code>、<code>下一个元素的坐标</code>等方法。</p>
<p>我在这里只关注 ArrayList 实现的普通迭代器。</p>
<br>

<p>获取 ArrayList 的迭代器，与其他容器的方式一样，都是调用 <code>Iterator()</code> 方法，获得一个迭代器。（这里迭代器支持泛型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; iterator = arrayList.iterator();</span><br></pre></td></tr></table></figure>

<p>公共方法 <code>Iterator()</code>，返回了一个 ArrayList 类内部实现的迭代器 <code>Itr</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// Itr类的内部实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们要关注的就是 <code>Itr</code> 类内部是怎么实现的。</p>
<br>

<p>ArrayList 的迭代器，<code>Itr</code> 类的基本骨架是这样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还有其他两个方法</span></span><br><span class="line">    <span class="comment">// 包括jdk 1.8版本新增的方法forEachRemaining，以及一个私有的辅助方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 在实现迭代器时，自己又定义了三个 int 类型的局部变量：<code>cursor</code>、<code>lastRet</code>、<code>expectedModCount</code>。我们先不看迭代器重写的方法是怎么实现，先关注这三个局部变量是做什么的。</p>
<ul>
<li><p><strong>cursor</strong> 坐标</p>
<p>表示迭代器移动到了 ArrayList 的第几个元素，它会伴随着迭代器的移动而移动。</p>
<p>用于判断迭代器的位置，也用于错误判断（比如越界）</p>
</li>
<li><p><strong>lastRet</strong> 上个坐标</p>
<p>最开始是 -1，随着 cursor 一同增加，但始终比 cursor 小 1。</p>
<p>用于判断迭代器刚刚经过的位置，来删除元素，或是错误判断。</p>
</li>
<li><p><strong>expectedModCount</strong> 列表结构变化次数</p>
<p>这是一个很有趣的设计，它不光出现在 ArrayList 的迭代器里，而是出现在 ArrayList 的各个方法中。</p>
<p>这个变量，记录的是列表改变了多少次结构（即列表内元素的数量，发生了多少次变化）。比如初始化一个 ArrayList 之后，add 了一个元素，那么 modCount 就是 1，又 add 了一个元素，那么 modCount 就是 2，之后 remove 了一个元素，列表的结构又发生了改变，modCount 变成了 3。modCount 记录的，就是列表的结构发生了多少次的变化（mod：modification)。</p>
<p>记录列表结构发生变化的次数，这有什么意义呢。ArrayList 是一个非线程安全的类，当有多个线程共用时，很有可能一边新增或删除了列表的某个元素，另一边对此毫不知情而发生错误。对此，ArrayList 为迭代器专门设计了一个 transient 的变量 modCount，不论任何位置，只要改变了列表的结构，都把这一次记录下来。那么，当迭代器初始化时，记录下来 modCount，之后迭代器工作前简单比较一下，当初记录的次数和现在的次数是否相同，就能知道列表有没有发生结构性变化。虽然这不是一个很保险的方式（即使 modCount 相同也有可能出现问题），但是这种方式很轻便，也基本能覆盖大部分问题。</p>
<p>实际上 modCount 并不是 ArrayList 独有的设计，在很多容器（ArrayList、LinkedList、HashMap……）都能看到这种设计：记录容器结构变化的次数，迭代器工作时能快速纠错。这被称为 Java 的 fail-fast 机制，一种用于容器的错误检错机制。</p>
</li>
</ul>
<p>好了，那么开始看源码吧。</p>
<br>

<h2 id="hasNext"><a href="#hasNext" class="headerlink" title="hasNext"></a>hasNext</h2><p>极为简单，当前坐标是否达到容器的长度，达到则返回 false，没达到则返回 true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cursor != size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么是容器的长度，而不是长度 - 1，这个要根据其他两个方法来看，cursor 坐标究竟指向哪个元素。</p>
<br>

<h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><p>next 方法的目的，是返回容器的下一个元素。对于列表而言，元素之间是有顺序的，按顺序返回即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="comment">// E 代表泛型</span></span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="keyword">int</span> i = cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致上分两个步骤：</p>
<ol>
<li><p>检查</p>
<p>ArrayList 实现的 next 方法首先检查 modCount，如果列表发生结构性变化，快速失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器的内部方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查非常简单，比较迭代器初始化时的 modCount（expectedModCount），和当前列表的 modCount 是否相同，不同就是结构变了。</p>
<p>然后还会检查 cursor 坐标是否指向了越界的位置。</p>
</li>
</ol>
<ol start="2">
<li><p>移动</p>
<p>在检查完结构后，next 方法正式工作。</p>
<p>它利用 cursor 来判断位置，返回列表的第 cursor 个元素，由于 ArrayList 的背后是由数组实现的，next 方法实际上返回的是数组的第 cursor 个元素，即 <code>return elementData[cursor];</code>。</p>
<p>在迭代器执行 next 方法返回下一个元素的同时，它的两个类变量 cursor、lastRet 也自增 1。</p>
</li>
</ol>
<p>观察发现，cursor 始终指向迭代器的下一个元素的位置，当 next 方法还没执行时，cursor 指向的是要返回的那个“下一个元素”，但当 next 方法要返回下个元素的时候，cursor 就又自增 1，指向了更下一个的元素。还有一种说法是，迭代器是以 cursor 为当前坐标的，next 方法是越过当前元素，到下一个元素的位置上，并返回刚刚越过去的那个元素。</p>
<p>lastRet 是 cursor 的跟班，紧跟在 cursor 一步远的距离，做迭代器的校验工具人。</p>
<br>

<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p>remove 方法的目的，就是把迭代器的当前元素，在整个列表里剔除掉。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>照例还是分两步走，第一步校验。next 方法校验的是结构是否变化、下个位置是否越界。与之对称的，remove 方法校验的是结构是否变化，当前元素是否不存在。</p>
<p>第二步移除。这里迭代器的 remove 方法，实际上就是列表自己的 remove 方法。列表的 remove 方法实际上是在调用 <code>System.arraycopy</code> 方法，将数组需要移除那个元素，之后的所有元素逐个往前挪位置，以达到数组复制的效果，是个开销不小的实现方法。不过仔细看，迭代器的 remove 方式是只能执行一次的，执行之后 lastRet 就归为初始的 -1 值，不能再 remove 了。</p>
<hr>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>看了源码才知道，原来 HashSet 基本就是 HashMap，它的迭代器实现也是 HashMap 里面的。</p>
<p>HashSet 内部维护一张 HashMap 表，HashMap 有 <code>key</code> 和 <code>value</code>，<code>key</code> 就是 HashSet 的值，而 <code>value</code> 统一都是一个空对象。当创建一个 HashSet 时，实际上就是在创建一张 HashMap，修改 set 的值实际上就是在修改 map 的键值对。可以从 HashSet 的 add 方法来粗略一窥：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HashSet内部用map存储</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E, Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet存储时，key是集合的值，value是这个空对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet的add方法，增加元素实际上就是在往map里存键值对</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向 HashSet 里增加一个元素，实际上就是在内部维护的 HashMap 里，存入一个 key 为想要增加的元素、value 为空对象的键值对。</p>
<br>

<p>HashMap 自己是没有迭代器的，因为 map 里的每个元素都是有两部分的键和值，迭代器无法同时迭代两个部分。但是迭代其中的一部分是可行的，例如迭代 key，或是迭代 value。实际上，HashSet 的迭代器，就是在迭代 key。</p>
<p>在 HashMap 的源码中，与迭代器相关的内部类有四个，它们被码在同一个区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------------------------------------------------ */</span></span><br><span class="line"><span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实还有四个与 Spliterator 相关的迭代器类 （Spliterator：splitable iterator）</span></span><br><span class="line"><span class="comment">// 它们是可分隔迭代器，用于并行迭代，但我们目前忽视它们</span></span><br></pre></td></tr></table></figure>

<p>这四个迭代器，第一个是抽象类，后面三个是我们能使用的类：</p>
<ul>
<li><font color="#32CD32"><strong>KeyIterator</strong></font>  key 迭代器</li>
<li><font color="#32CD32"><strong>ValueIterator</strong></font>  value 迭代器</li>
<li><font color="#32CD32"><strong>EntryIterator</strong></font>  key-value （键值对）迭代器</li>
</ul>
<p>第一个迭代器 <font color="#32CD32"><strong>HashIterator</strong></font> 是上面这三个迭代器的父类，它算是实现了迭代器的 hasNext、next、remove 三个方法，后面三个迭代器直接继承了它的 hasNext 和 remove 方法，简单写了 next 方法。</p>
<p>是怎么简单实现 next 方法的呢，以 <font color="#32CD32"><strong>KeyIterator</strong></font> 类为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// K 是泛型类，与迭代器的泛型类相同</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br></pre></td></tr></table></figure>

<p>就是返回了父类定义的键值对的 key 值，一行代码。</p>
<p>其他两个类也是如此，返回 value 和返回 key-value，因此我们就不提 HashMap 的后面三个迭代器了，重点看第一个迭代器的实现。</p>
<br>

<p>从整体上看，HashIterator 类的骨架是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Node 类是 HashMap 里定义的键值对类，它继承了 Map.Entry 类</span></span><br><span class="line">    Node&lt;K,V&gt; next;        </span><br><span class="line">    Node&lt;K,V&gt; current;     </span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  </span><br><span class="line">    <span class="keyword">int</span> index;             </span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共四个内部变量，</p>
<ul>
<li><font color="#32CD32"><strong>next</strong></font>  下一个键值对</li>
<li><font color="#32CD32"><strong>current</strong></font>  当前键值对</li>
<li><font color="#32CD32"><strong>expectedModCount</strong></font>  预期 hashMap 的结构变化次数</li>
<li><font color="#32CD32"><strong>index</strong></font> 当前键值对的坐标（HashMap 存放键值对，是以数组的方式来存储的）</li>
</ul>
<p>以及四个方法。</p>
<ul>
<li><font color="#32CD32"><strong>HashIterator</strong></font>  构造方法，初始化迭代器</li>
<li><font color="#32CD32"><strong>hasNext</strong></font>  是否有下一个元素 </li>
<li><font color="#32CD32"><strong>nextNode</strong></font>  下一个键值对</li>
<li><font color="#32CD32"><strong>remove</strong></font>  删除当前元素</li>
</ul>
<p>四个内部变量，跟 ArrayList 实现迭代器的逻辑是相同的，就不写两遍了，看后面的四个方法是怎么实现的。</p>
<br>

<h2 id="HashIterator"><a href="#HashIterator" class="headerlink" title="HashIterator"></a>HashIterator</h2><p>HashMap 的迭代器的构造器，初始化了四个内部变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashIterator() &#123;</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">    Node&lt;K,V&gt;[] t = table;</span><br><span class="line">    current = next = <span class="keyword">null</span>;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化 modCount 和 current 没什么好讲的，简单赋值。</p>
<p><code>table</code> 是 HashMap 内部存储键值对的数组，具体内容这周不看，但是我们需要知道的是，这个数组内部并不是连续排列，一个键值对紧跟着一个键值对的，中间可能会有 null。</p>
<p>为了考虑内部存储的结构，当前元素存储的下一个数组格子，可能没有存储任何东西，只是 null，因此需要跳过这些空格。为 next 变量赋值时，以及为 index 变量赋值时，是需要跳过空白格子的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;&#125; </span><br><span class="line"><span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p>（这行代码还真是紧凑……）</p>
<br>

<h2 id="hasNext-1"><a href="#hasNext-1" class="headerlink" title="hasNext"></a>hasNext</h2><p>迭代器是否有下个元素，去掉方法的结构体只有一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="nextNode"><a href="#nextNode" class="headerlink" title="nextNode"></a>nextNode</h2><p>HashMap 的抽象迭代器并没有 next 方法，next 方法交由子类实现，但是它实现了 next 方法所必需的，搜索下一个键值对的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] t;</span><br><span class="line">    Node&lt;K,V&gt; e = next;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查 HashMap 的结构是否发生变化（fail-fast 机制），然后检查存储键值对的数组是否为 null（即没有初始化过）。再之后是两行密度很高的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两行代码的含义是：</p>
<ol>
<li>为迭代器的当前元素赋值（也就是上一轮迭代器的 next 元素）。</li>
<li>如果没遍历完存储的内容，那么让 index 移动，让 next 键值对往后挪。</li>
<li>存储键值对的数组，可能存在 null 值，要跳过这些 null 值，让 next 变量指向真正的下一个元素，让 index 坐标指向真正的下一个元素的再下一个位置。</li>
</ol>
<p>从 HashMap 的迭代器，能够大概看出，HashMap 似乎用链表和数组两种方式来存储键值对，数组中放着一个个的链表节点，而链表节点又能指向下一个元素。在数组中的每个元素都连续排列的情况下，用链表检索下一个；当数组中出现“缝隙”，元素之间断开时，又用数组来检索下一个。</p>
<p>没看 HashMap 的其他源码，不知道这种处理方式有什么好处。</p>
<p>（次日改：我智障了，我原来以为链表和数组是互补的，同时使用提高效率，其实链表的作用是让同一个数组格子能够存放多个元素，因为 HashMap 存储元素时，存储的位置是计算出来的，如果计算出来结果相同，那就要存在相同的地方。）</p>
<br>

<h2 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h2><p>感觉 remove 方法没什么太多可说的，检查完然后调用 HashMap 的删除方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; p = current;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    current = <span class="keyword">null</span>;</span><br><span class="line">    K key = p.key;</span><br><span class="line">    removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    expectedModCount = modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>写这篇迭代器的原因，是因为写业务代码时犯了错误，在 for-each 循环里调用了容器的 remove 方法，结果让生产代码回滚了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">    <span class="comment">// 执行逻辑...</span></span><br><span class="line">    list.remove(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for-each 实际上是用迭代器实现的（这个找不到源码，但可以从反编译代码中推断出来），容器使用了 remove 方法改变了结构，modCount 改变了，和迭代器中的 expectModCount 不相同，会直接抛异常（ConcurrentModificationException）。</p>
<p>当时测试没有看出来，因为只测试了列表的倒数第二个元素。很有趣的是，列表迭代器中的每个元素都会报错，唯独倒数第二个不会报错，就这样侥幸通过了代码自测……至于为什么倒数第二个不会报错，这个跟坐标有关，就不写下去了。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：动态规划</title>
    <url>/2020/04/19/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<br>

<p>四月的第三周，来学习动态规划。</p>
<p>本来上篇博文的题目叫做《回溯与动态规划》，结果我高估了自己的算法能力，根本学不透hhh，这周来学习动态规划，努力把都所有变种都学会并熟练使用。</p>
<hr>
<p>动态规划（Dynamic programming，简称DP），是一种拆分问题变成相对简单的子问题的算法。我一直觉得这种算法跟高中的数学归纳法有相似之处：在思考问题时，都是思考怎么从第 N 步推出第 N+1 步，在写答案时，都是先写出第 1 步，然后写第 N 步到第 N +1 步的过程，最终输出结论。这种从第 N 步推到第 N+1 步的过程，在算法中称为“重叠子问题”，就是怎么把问题转换成子问题，通常重叠子问题就是解答的核心问题。</p>
<p>动态规划的核心在于写出递推公式，也就是怎么从第 n 步推到第 n+1 步（这个公式的术语叫做<code>状态转移方程</code>），只要能写出这个递推公式，一般问题就不大了。而写出这个公式的通常做法在于画格子，自己画一个表格，每一行新增一个物品/一天/一个数字，自行观察总结新增了一个之后，怎么从上一行信息得出本行信息。</p>
<p>我觉得自己上篇整理算法的方式是错误的，熟练运用算法最重要的不是理解模板，而是大量的练习。本文不再讲解具体内容了，只简单整理 10 道动态规划的题目（题目描述也不抄了，点击题目能跳转过去），画出表格，写出递推公式。</p>
<hr>
<h1 id="LeetCode53-最大子序和"><a href="#LeetCode53-最大子序和" class="headerlink" title="LeetCode53  最大子序和"></a>LeetCode53 <a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener"> 最大子序和</a></h1><table>
<thead>
<tr>
<th>物品[-2, 1, -3, 4, -1, 2, 1, -5,  4] 背包容量1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>-2</td>
<td>-2</td>
</tr>
<tr>
<td>-2, 1</td>
<td>1</td>
</tr>
<tr>
<td>-2, 1, -3</td>
<td>-2</td>
</tr>
<tr>
<td>-2, 1, -3, 4</td>
<td>4</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1</td>
<td>3</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2</td>
<td>5</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2, 1</td>
<td>6</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2, 1, -5</td>
<td>1</td>
</tr>
<tr>
<td>-2, 1, -3, 4, -1, 2, 1, -5, 4</td>
<td>5</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,<span class="number">1</span>) = max( dp(i<span class="number">-1</span>,<span class="number">1</span>) + nums[i], nums[i] )</span><br><span class="line">               在原本基础上新增数字    新增数字本身</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 物品个数：nums.length</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建dp数组</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录结果</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，dp[i] = (dp[i-1] + num) || (num)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = Math.max(nums[i], nums[i] + dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode416-分割等和子集"><a href="#LeetCode416-分割等和子集" class="headerlink" title="LeetCode416  分割等和子集"></a>LeetCode416 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum" target="_blank" rel="noopener"> 分割等和子集</a></h1><table>
<thead>
<tr>
<th>物品[1, 2, 3, 4]  背包容量5</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1, 2</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1, 2, 3</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>1, 2, 3, 4</td>
<td></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = (j == nums[i]) || (dp(i<span class="number">-1</span>,j)) || (dp[i - <span class="number">1</span>][j - nums[i]])</span><br><span class="line">          刚好是新加的数字     原本就可以       新加数字之后可以</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验数据</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物品个数：nums.length</span></span><br><span class="line">    <span class="comment">// 背包容量：总和/2</span></span><br><span class="line">    <span class="keyword">int</span> itemCount = len;</span><br><span class="line">    <span class="keyword">int</span> capacity = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[itemCount][capacity + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; capacity + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 自己本身</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == j) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 拷贝上一行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 自己本身组合上一行</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; nums[i] &amp;&amp; dp[i - <span class="number">1</span>][j - nums[i]]) &#123;</span><br><span class="line">                dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[itemCount - <span class="number">1</span>][capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Mi27-石头收藏家"><a href="#Mi27-石头收藏家" class="headerlink" title="Mi27 石头收藏家"></a>Mi27 <a href="https://code.mi.com/problem/list/view?id=27" target="_blank" rel="noopener">石头收藏家</a></h1><table>
<thead>
<tr>
<th>物品[2, 3, 5, 7]  物品价值[1, 5, 2, 4] 背包容量10</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2,3</td>
<td></td>
<td></td>
<td>1</td>
<td>5</td>
<td></td>
<td>6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2,3,5</td>
<td></td>
<td></td>
<td>1</td>
<td>5</td>
<td></td>
<td>6</td>
<td></td>
<td>3</td>
<td>7</td>
<td></td>
<td>8</td>
</tr>
<tr>
<td>2,3,5,7</td>
<td></td>
<td></td>
<td>1</td>
<td>5</td>
<td></td>
<td>6</td>
<td></td>
<td>4</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = max( value[i],       dp(i<span class="number">-1</span>,j-nums[j])+value[i], dp(i<span class="number">-1</span>,j))</span><br><span class="line">               新增物品价值本身   新增物品价值加已有价值         继承上一轮的结果</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String line, line1 = <span class="keyword">null</span>, line2 = <span class="keyword">null</span>, line3;</span><br><span class="line">    <span class="keyword">while</span> (scan.hasNextLine()) &#123;</span><br><span class="line">        line = scan.nextLine().trim();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (line1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            line1 = line;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            line2 = line;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            line3 = line;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            String[] s1 = line2.split(<span class="string">" "</span>);</span><br><span class="line">            String[] s2 = line3.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> capacity = Integer.parseInt(line1);</span><br><span class="line">            <span class="keyword">int</span>[] weights = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length];</span><br><span class="line">            <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[s2.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.length; i++) &#123;</span><br><span class="line">                weights[i] = Integer.parseInt(s1[i]);</span><br><span class="line">                values[i] = Integer.parseInt(s2[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 动态规划数组 行：物品数量 列：背包容量</span></span><br><span class="line">            <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[weights.length][capacity + <span class="number">1</span>];</span><br><span class="line">            List&lt;Integer&gt; history = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            <span class="keyword">if</span> (weights[<span class="number">0</span>] &lt;= capacity) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][weights[<span class="number">0</span>]] = values[<span class="number">0</span>];</span><br><span class="line">                history.add(weights[<span class="number">0</span>]);</span><br><span class="line">                max = values[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weights.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 先拷贝上一行数据</span></span><br><span class="line">                System.arraycopy(dp[i - <span class="number">1</span>], <span class="number">0</span>, dp[i], <span class="number">0</span>, dp[<span class="number">0</span>].length);</span><br><span class="line">                <span class="comment">// 结合之前的数据</span></span><br><span class="line">                <span class="keyword">int</span> newWeight = weights[i];</span><br><span class="line">                <span class="keyword">int</span> newValue = values[i];</span><br><span class="line">                <span class="keyword">int</span> historyNum = history.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; historyNum; j++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> hWeight = history.get(j);</span><br><span class="line">                    <span class="keyword">int</span> hValue = dp[i - <span class="number">1</span>][hWeight];</span><br><span class="line">                    <span class="keyword">int</span> nowHeight = hWeight + newWeight;</span><br><span class="line">                    <span class="keyword">if</span> (nowHeight &lt;= capacity) &#123;</span><br><span class="line">                        dp[i][nowHeight] = Math.max(dp[i - <span class="number">1</span>][nowHeight], hValue + newValue);</span><br><span class="line">                        max = Math.max(max, dp[i][nowHeight]);</span><br><span class="line">                        <span class="keyword">if</span> (!history.contains(nowHeight)) &#123;</span><br><span class="line">                            history.add(nowHeight);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把本身的数据赋值</span></span><br><span class="line">                <span class="keyword">if</span> (newWeight &lt;= capacity) &#123;</span><br><span class="line">                    dp[i][newWeight] = Math.max(dp[i][newWeight], newValue);</span><br><span class="line">                    max = Math.max(max, dp[i][newWeight]);</span><br><span class="line">                    history.add(newWeight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printArray(dp);</span><br><span class="line"></span><br><span class="line">            line1 = <span class="keyword">null</span>;</span><br><span class="line">            line2 = <span class="keyword">null</span>;</span><br><span class="line">            line3 = <span class="keyword">null</span>;</span><br><span class="line">            System.out.println(max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode188-买卖股票的最佳时机-IV"><a href="#LeetCode188-买卖股票的最佳时机-IV" class="headerlink" title="LeetCode188  买卖股票的最佳时机 IV"></a>LeetCode188 <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv" target="_blank" rel="noopener"> 买卖股票的最佳时机 IV</a></h1><p>（这个解法效率比较差，但是能做出来）</p>
<table>
<thead>
<tr>
<th>物品[3, 2, 6, 5, 0, 3] 背包容量6</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3, 2</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3, 2, 6</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3, 2, 6, 5</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3, 2, 6, 5, 0</td>
<td></td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3, 2, 6, 5, 0, 3</td>
<td></td>
<td>4</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = max( (遍历取最大)&#123;dp(i-1,j-1)+nums[i]-nums[k]&#125;,       dp(i<span class="number">-1</span>,j) )</span><br><span class="line">               第k<span class="number">-1</span>天进行j<span class="number">-1</span>次交易 + （第i天的股票 - 第k天的股票）  不交易，沿用上一天</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="keyword">null</span> || prices.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> days = prices.length;</span><br><span class="line">    <span class="keyword">int</span> saleTimes = Math.min(prices.length, k);</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[days + <span class="number">1</span>][saleTimes + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第i天进行j次交易 = （遍历取最大）&#123;第k-1天进行j-1次交易 + （第i天的股票 - 第k天的股票）&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= days; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= saleTimes; j++) &#123;</span><br><span class="line">            <span class="comment">// 第1天交易，肯定赚不到钱</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 交易次数是0，肯定赚不到钱</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> max = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; i; m++) &#123;</span><br><span class="line">                    max = Math.max(max, dp[m - <span class="number">1</span>][j - <span class="number">1</span>] + (Math.max(prices[i - <span class="number">1</span>] - prices[m - <span class="number">1</span>], <span class="number">0</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[days][saleTimes];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode32-最长有效括号"><a href="#LeetCode32-最长有效括号" class="headerlink" title="LeetCode32 最长有效括号"></a>LeetCode32 <a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">最长有效括号</a></h1><table>
<thead>
<tr>
<th>物品[(, (, ), (, ),  ), (, )] 背包容量1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>(</td>
<td>0</td>
</tr>
<tr>
<td>((</td>
<td>0</td>
</tr>
<tr>
<td>(()</td>
<td>1</td>
</tr>
<tr>
<td>(()(</td>
<td>1</td>
</tr>
<tr>
<td>(()()</td>
<td>2</td>
</tr>
<tr>
<td>(()())</td>
<td>3</td>
</tr>
<tr>
<td>(()())(</td>
<td>3</td>
</tr>
<tr>
<td>(()())()</td>
<td>4</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i)  =  dp(i<span class="number">-2</span>) + <span class="number">2</span>   ||   dp(i<span class="number">-1</span>) + <span class="number">2</span> + dp(i-dp(i<span class="number">-1</span>)<span class="number">-2</span>)</span><br><span class="line">          <span class="string">"()"</span>结尾            <span class="string">"))"</span>结尾 （dp(i-dp(i<span class="number">-1</span>)<span class="number">-2</span>)代表对应的<span class="string">"("</span>之前有多少个有效括号</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] brackets = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[brackets.length];</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历符号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; brackets.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (brackets[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> already = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// ()结尾，则是dp[i-2]+2</span></span><br><span class="line">            <span class="keyword">if</span> (brackets[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    already = dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = already + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// ))结尾，则先判断是否成立，如果成立，在上个成立点的基础上+2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; brackets[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        already = dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span> + already;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode44-通配符匹配"><a href="#LeetCode44-通配符匹配" class="headerlink" title="LeetCode44  通配符匹配"></a>LeetCode44 <a href="https://leetcode-cn.com/problems/wildcard-matching" target="_blank" rel="noopener"> 通配符匹配</a></h1><table>
<thead>
<tr>
<th>物品[*, a, *,  b] 背包容量 5</th>
<th>a</th>
<th>d</th>
<th>c</th>
<th>e</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>*, a</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>*, a, *</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>*, a, *, b</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = dp(i<span class="number">-1</span>,j<span class="number">-1</span>) || dp(i<span class="number">-1</span>,j<span class="number">-1</span>) || &#123; dp(i-1,j) || dp(i,j-1) &#125;</span><br><span class="line">          字母相同        通配符是“?”      通配符是“*”</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先过滤一遍"*"，多个连续的*缩减成一个</span></span><br><span class="line">    String t = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> pChar : p.toCharArray()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pChar != <span class="string">'*'</span>) &#123;</span><br><span class="line">            t += pChar;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            t += pChar;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.charAt(t.length() - <span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">            t += pChar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m = s.length();</span><br><span class="line">    <span class="keyword">int</span> n = t.length();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态 dp[i][j] : 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] &amp;&amp; t.charAt(i - <span class="number">1</span>) == <span class="string">'*'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>) || t.charAt(j - <span class="number">1</span>) == <span class="string">'?'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode62-不同路径"><a href="#LeetCode62-不同路径" class="headerlink" title="LeetCode62  不同路径"></a>LeetCode62 <a href="https://leetcode-cn.com/problems/unique-paths" target="_blank" rel="noopener"> 不同路径</a></h1><table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>3</td>
<td>6</td>
<td>10</td>
<td>15</td>
<td>21</td>
<td>28</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = dp(i<span class="number">-1</span>,j) + dp(i,j<span class="number">-1</span>)</span><br><span class="line">             上           左</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="comment">// 主要是处理0的特殊情况</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                up = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left = dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 核心逻辑就一行代码，上+左</span></span><br><span class="line">            dp[i][j] = up + left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode72-编辑距离"><a href="#LeetCode72-编辑距离" class="headerlink" title="LeetCode72  编辑距离"></a>LeetCode72 <a href="https://leetcode-cn.com/problems/edit-distance" target="_blank" rel="noopener"> 编辑距离</a></h1><table>
<thead>
<tr>
<th></th>
<th>null</th>
<th>r</th>
<th>r, o</th>
<th>r, o, s</th>
</tr>
</thead>
<tbody><tr>
<td>null</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>h</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>h, o</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>h, o, r</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>h, o, r, s</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>h, o, r, s, e</td>
<td>5</td>
<td>4</td>
<td>4</td>
<td>3</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i,j) = n 其中一方是null，采用另一方单词的长度</span><br><span class="line">          || dp(i<span class="number">-1</span>,j<span class="number">-1</span>) 尾字母相同，采用去掉尾字母的dp</span><br><span class="line">          || <span class="number">1</span> + min&#123; dp(i,j-1), dp(i-1,j), dp(i-1,j-1) &#125; 从三种临界状态过来，再+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">0</span> || n2 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n1 + n2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="comment">// 当其中一个单词为null时，dp为另一个单词的长度</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当两个单词尾字母相同时，dp(i,j)=dp(i-1,j-1)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// dp(i,j) = 1 + min&#123; dp(i,j-1), dp(i-1,j), dp(i-1,j-1) &#125; 代表从任意临近状态过来</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode85-最大矩形"><a href="#LeetCode85-最大矩形" class="headerlink" title="LeetCode85 最大矩形"></a>LeetCode85 <a href="https://leetcode-cn.com/problems/maximal-rectangle" target="_blank" rel="noopener">最大矩形</a></h1><p>（不好画表格，经过了两次dp，第一次是行，第二次是列）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length, columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行dp一次</span></span><br><span class="line">    <span class="keyword">int</span>[][] lineDp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">'0'</span>) &#123;</span><br><span class="line">                lineDp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                lineDp[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lineDp[i][j] = lineDp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][columns];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = lineDp[i][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> columnMin = lineDp[i][j];</span><br><span class="line">                <span class="keyword">int</span> max = lineDp[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    columnMin = Math.min(columnMin, lineDp[k][j]);</span><br><span class="line">                    <span class="keyword">if</span> (columnMin == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 宽：遍历之后的最小值  高：i和k之间的距离</span></span><br><span class="line">                    <span class="keyword">int</span> width = columnMin;</span><br><span class="line">                    <span class="keyword">int</span> high = i - k + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, high * width);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = max;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LeetCode279-完全平方数"><a href="#LeetCode279-完全平方数" class="headerlink" title="LeetCode279  完全平方数"></a>LeetCode279 <a href="https://leetcode-cn.com/problems/perfect-squares" target="_blank" rel="noopener"> 完全平方数</a></h1><table>
<thead>
<tr>
<th></th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>3</td>
</tr>
<tr>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>9</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>2</td>
</tr>
<tr>
<td>11</td>
<td>3</td>
</tr>
<tr>
<td>12</td>
<td>3</td>
</tr>
</tbody></table>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">dp(i) = i   ||  dp(i)     ||    dp(i<span class="number">-1</span>)+<span class="number">1</span>  ||   平方数   || dp(i-平方数)+<span class="number">1</span> </span><br><span class="line">        i个<span class="number">1</span>    遍历的上个结果     上个dp+<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平方数</span></span><br><span class="line">    <span class="keyword">int</span>[] squares = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) Math.sqrt(n) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; squares.length; i++) &#123;</span><br><span class="line">        squares[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历平方数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; squares.length &amp;&amp; squares[j] &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果是平方数，那么dp(i)=1</span></span><br><span class="line">            <span class="keyword">if</span> (i == squares[j]) &#123;</span><br><span class="line">                dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是平方数，那么dp(i)= &#123; i || 前一个+1 || dp(i-平方数)+1 &#125;</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = min(i, dp[i - <span class="number">1</span>] + <span class="number">1</span>, dp[i - squares[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[i - <span class="number">1</span>] + <span class="number">1</span>, dp[i - squares[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>... nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        min = Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>对象的大小</title>
    <url>/2020/03/08/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<br>

<p>一晃都三月了，过了一个很古早的冬天呐。</p>
<p>冬眠回来，三月的第二周，来看 Java 对象的内存设计，这部分的学习是为之后学习 synchronized 关键字铺路的。本来想在学习锁时顺便提一嘴写完它，结果发现这坑有点大，还是要单独学。</p>
<br>

<p>我们这周学习的目的，是搞清楚存储在内存中的对象，它具体是如何存储的，存储时都需要存哪些信息，以及存这些信息的意义是什么。</p>
<p>比如看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList;</span><br><span class="line">list.add(<span class="string">"hello, world!"</span>);</span><br></pre></td></tr></table></figure>

<p>上面这两行代码当中的 <code>list</code> 对象是如何存储起来的。</p>
<hr>
<p>要学习对象是怎么存储在内存当中的，就要从很原始的地方说起，先学习 JVM 的内存结构。</p>
<p>这一块我是真的很欠缺，只知道一点基础的概念，我只把本次要用到的知识写在这里，其他的知识我还要慢慢学。有关 JVM 的内存结构，我学习的起点是<a href="https://www.bilibili.com/video/av62009886" target="_blank" rel="noopener">《【java】jvm内存模型全面解析》</a>视频，很推荐一看。</p>
<p>JVM 在运行 Java 程序时，会管理一块内存区域，这一片区域被称为<code>运行时数据区域</code>，从结构上可以分为五个部分，分别是：</p>
<ul>
<li><code>Java 虚拟机栈</code>：线程私有，存储局部变量等</li>
<li><code>本地方法栈</code>：线程私有，存储本地方法的变量等</li>
<li><code>程序计数器</code>：线程私有，存储字节码的地址（程序执行到第几行了）</li>
<li><code>堆</code>：线程共享，存储几乎所有对象</li>
<li><code>方法区</code>：线程共享，存储类的结构信息（字段、构造方法等等）</li>
</ul>
<p>（下图来源自<a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">《CYC - Java 虚拟机 - 运行时数据区域》</a>，其内容整理非常值得反复阅读)</p>
<p><img src="/assets/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="JVM内存结构"></p>
<p>我们今天要说的，只是<code>栈</code>和<code>堆</code>（栈指的是 Java 虚拟机栈）。非常浅薄地讲，<code>栈</code>存放的是局部变量以及对象的地址，<code>堆</code>存放的是对象的实体。（看书发现，栈中存放的并不一定是对象地址，但这是最常见的寻找堆对象的方式）</p>
<p>简单制作了一张图，描述了代码、栈、堆之间的关系。</p>
<p><img src="/assets/JVM%E5%86%85%E5%AD%98%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1.jpg" alt="JVM内存存储对象"></p>
<br>

<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>内存结构和内存模型并不是一个概念：</p>
<p>当我们说内存结构时，通常是指<code>JVM 内存结构</code>，这是真实存在的，指的是上文介绍的 Java 虚拟机栈、堆、本地方法栈等等那五部分构成的 JVM 运行时数据区域，这是在<code>结构</code>上把 JVM 的内存分成了多个部分。</p>
<p>当我们说内存模型时，通常是指<code>Java 内存模型</code>，这是虚拟存在的，指的是面对并发时 Java 是如何实现内存访问一致的，牵扯到了主内存和工作内存等知识，这是在<code>模型</code>和概念上，屏蔽各种硬件和操作系统的内存访问差异，来实现并发内存一致性。</p>
<br>

<hr>
<p>简单说完了对象存放的位置，那么接下来就要进入这周学习的重点了：如何计算对象的大小。这个问题实际上可以拆成两个问题：</p>
<ol>
<li>对象由哪些部分组成？</li>
<li>每部分各占多少字节？</li>
</ol>
<p>在这两个问题的基础上，自然会问出第三个问题：</p>
<ol start="3">
<li>组成对象的这些基础部分，各自是做什么的？</li>
</ol>
<p>PS：在看书的时候，发现自己所学习对象大小的这部分知识，实际上是 HotSpot 虚拟机的实现，而并非所有 Java 虚拟机的实现，但是目前基本上所有的 Java 程序都跑在 HostSpot 虚拟机上面。</p>
<br>

<p>所有对象都可以笼统地切分成两部分：<code>对象头</code>（Header）和<code>对象内容</code>（Instance Data）。</p>
<p>举一个实际的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这个 Person 类，它实例化出来的对象同样具有对象头和对象内容两部分，<code>name</code> 和 <code>age</code> 都是对象的内部变量，属于对象内容，而对象头是其余一些辅助信息。</p>
<br>

<p>我绘制了一张图，画出了在最常见情况下（64 位虚拟机开启指针压缩），对象在内存中的结构，后文都是在解释这个结构的具体信息。</p>
<p><img src="/assets/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg" alt="对象头"></p>
<h1 id="对象内容"><a href="#对象内容" class="headerlink" title="对象内容"></a>对象内容</h1><p>对象内容准确地讲应该叫做实例数据（Instance Data），比较简单，因此我们先讲完。</p>
<p>正如之前提到的 Person 对象的例子，对象内的属性（包括基本数据类型 <code>int age</code> 和引用的另一个对象 <code>String name</code>），这些属性所占的内容大小，就是对象内容的大小。在该例子中，int 类型的 <code>age</code> 占 4 个字节（即 32 位），引用另一个对象时，存储的是对象的地址，地址是一个 int 类型的指针，因此 String 类型的 <code>name</code> 存储在 Person 对象中也占 4 个字节（即 32 位），两个属性加起来一共占 8 个字节。</p>
<p>因此计算对象内容的大小，实际上就是分两部分，基本数据类型一类，占内容大小加起来，引用别的对象占一类，引用一个就是 4 字节（int 的大小），引用 N 个对象就占 N*4 个字节。</p>
<p>下面列举了 8 种基本数据类型的大小。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>2（表示一个 UTF-16be 编码单元，<a href="https://colobu.com/2019/01/04/how-many-charactors-in-a-java-string/" target="_blank" rel="noopener">生僻字用两个char</a>）</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>flote</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>boolean</td>
<td>通常是1</td>
</tr>
</tbody></table>
<p>此外还要注意的一点是，如果 A 类继承自 B 类，那么计算 A 类的对象内容大小时，继承来的 B 类的属性也是要算在内的。比如计算 ArrayList 对象大小的时候，它的父类 AbstractList 中的属性，也是要计算在内的。</p>
<br>

<h1 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h1><p>对象头（Header）比较复杂，它包含着对象的“冗余信息”，这些信息或实现并发锁，或帮助垃圾分类，或包含类的信息。</p>
<p>从整体上看，对象头包含三部分的信息，分别是</p>
<ul>
<li>标记字段</li>
<li>地址</li>
<li>数组长度</li>
</ul>
<h2 id="标记字段"><a href="#标记字段" class="headerlink" title="标记字段"></a>标记字段</h2><p>标记字段（Mark Word）是对象头中最复杂的内容，需要对照上面绘制的图来看。</p>
<p>由于内存空间寸土寸金，在希望对象能够记录更多信息的同时，还要尽可能地压缩空间，在这种背景之下，32 位虚拟机的对象标记字段长 4 字节，64 位虚拟机的对象标记字段长 8 字节（现在基本都是 64 位了吧），并且都有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据。32 位和 64 位的存储长度不同，仅仅是因为地址指针长度引起的变化，在存储的内容类型方面没有区别。</p>
<p>（具体的标记字段信息可见文末的备注）</p>
<p>以我当下的理解，标记字段主要实现了三个事情：</p>
<ol>
<li>对并发情况下的 synchronized 支持</li>
<li>GC 垃圾回收</li>
<li>保存 hashcode</li>
</ol>
<p>标记字段共有五种状态，分别是对应于 synchronized 的四种状态（无锁、偏向锁、轻量级锁和重量级锁），以及一种 GC 状态，这五种状态通过 2 位标志位实现（无锁和偏向锁的标志位相同）。</p>
<p>因此，了解标记字段的具体信息，实际上就是在了解 synchronized 锁和垃圾回收的原理。这两部分都有点难，本文暂时不讨论了，有关 synchronized 的信息可以参考这篇文章<a href="https://www.itqiankun.com/article/bias-lightweight-synchronized-lock" target="_blank" rel="noopener">《彻底搞懂 Java 中的偏向锁，轻量级锁，重量级锁》</a>。</p>
<h2 id="地址信息"><a href="#地址信息" class="headerlink" title="地址信息"></a>地址信息</h2><p>对象头中有一部分是地址信息，它实际上是一个类型指针，指向了该对象类型的地址。</p>
<p>例如 person 对象的对象头中的地址信息，指向了 Person 类的地址（类在方法区）。</p>
<p>在这种设计下，可以通过对象找到类，比如在 main() 方法中实例化一个 Person 对象 person，在内存中寻址的过程为：</p>
<ol>
<li>main() 方法的 Java 栈中记录着 person 对象的地址，</li>
<li>根据这个地址在堆中找到了 person 对象，</li>
<li>person 对象的头部又记录着 Person 类的地址，根据这个地址在方法区中找到了 Person 类。</li>
</ol>
<p>（实际上，在对象的头部中保留类的地址信息，通过对象找到类的位置，这种设计是 HotSpot 虚拟机的设计，也有别的虚拟机不这么设计，对象头中并不包含类的地址，不通过对象找类。）</p>
<p>地址信息的大小并不是固定的，这跟系统位数有关，32 位的虚拟机，指针是 32 位长，地址信息只需要 32 （即 4 字节），但是对于 64 位的虚拟机，指针是 64 位长，因此地址信息也需要扩增到 64 位（即 8 字节）。</p>
<p>32 位的虚拟机，理论上只能寻址到 4 GB 的内存空间（2^32 byte = 4 GB），而 64 位的虚拟机能寻址到更多地址。这样的提升是有代价的，一方面内存占用量变大了，原来只需要 4 个字节存储一个地址，现在需要 8 个字节了（如果不需要比 4GB 更多的内存，用这么大的空间是没有意义的），另一方面寻址时操作位数更长的指针，主内存和各级缓存移动数据时，占用的带宽也会增加。</p>
<p>Java 虚拟机为了处理这个问题，提出了<strong>指针压缩</strong>。</p>
<p>指针压缩的简易原理是这样的：32 位的指针，当然只能找到 4 GB 个内存位置，如果我有一块更大的内存区域，比如 10 GB，32 位的指针就不能指向这 10 GB 中的所有位置，但实际上并不需要找到这块内存中的所有位置，它只需要找到要操作的开始位置就可以了。<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html" target="_blank" rel="noopener">这意味着 32 位的指针可以引用 40 亿个对象，而不是 40 亿个字节。</a>Java 对象的大小如果一定是 8 字节的整数倍（这个后文有讲），那么就可以使原来只能寻址 4 GB 的内存扩大 8 倍，到 32 GB 的内存。</p>
<p>因此对于分配内存低于 4 GB 的虚拟机，默认开启指针压缩，指针大小就是 32 位长，对于分配内存在 4 - 32 GB 之间的虚拟机，可以开启指针压缩算法，使指针大小依旧维持在 32 位长，但是对于更大的内存，无法开启指针压缩，指针大小必须是 64 位长。（因此分配内存并不是越大越好，32 GB 处会有一个门槛）</p>
<p>指针压缩并非毫无缺陷，这毕竟是多出来的算法，会增加 JVM 的计算量。</p>
<p>总结：对象头中的地址信息大小，跟系统位数以及是否开启指针压缩有关，<code>32 位系统</code>、<code>开启了指针压缩的 64 位系统</code>的地址信息长 4 字节，<code>普通 64 位系统</code>的地址信息长 8 字节。</p>
<h2 id="数组大小"><a href="#数组大小" class="headerlink" title="数组大小"></a>数组大小</h2><p>数组大小并不是必须的，数组才有，非数组没有。</p>
<p>因为数组是 new 出来的，需要在堆上分配内存，在这个意义上讲，数组就是对象的一种。数组的长度是需要记录下来的，长度为 4 字节。</p>
<p>int 也是 4 字节，这就很容易让人联想在一起。Java 中 int 是有符号整型数，是有负值的，int 的最大值是 2^31 - 1，用二进制表示为 01111111111111111111111111111111。数组的理论最大长度，也应该是 int 的最大值。</p>
<p>实际的使用中可能会小一点。例如 ArrayList 内部维护的数组，它的最大长度是 <code>Integer.MAX_VALUE - 8</code>，注释称这是因为虚拟机的限制。又例如 HashMap 内部维护的数组，它的最大程度是 <code>1 &lt;&lt; 30</code>，这是 1 位运算之后能获得到的最大值（二进制为 01000000000000000000000000000000）。</p>
<br>

<h1 id="（还有一点需要提及）"><a href="#（还有一点需要提及）" class="headerlink" title="（还有一点需要提及）"></a>（还有一点需要提及）</h1><p>在计算完对象头和对象内容的大小之后，二者加起来并不一定是最终占内存的大小，还要考虑内存对齐的问题。</p>
<p>所有对象的字节大小，必须是 8 的整数倍，如果对象头+对象内容算出来是 15 字节，那么最终对象大小为 16 字节，如果是 20 字节，那么最终对象大小是 24 字节，总之如果不满 8 的整数倍，都填充到 8 的整数倍，填充的部分叫做<code>对齐填充</code>（Padding），实际上就是占位符。</p>
<p>对齐填充的原因在于，HotSpot 虚拟机的自动内存管理系统，要求对象的起始地址必须是 8 字节的整数倍（这样寻址更高效，而且实现了指针压缩），因此对象的大小也就必须是 8 字节的整数倍。</p>
<br>

<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>在博文<a href="http://blog.kail.xyz/post/2018-08-01/java/java-object-header_and_lock.html" target="_blank" rel="noopener">《Java Object Header 和 锁》</a>中找到了三种情况（32 位虚拟机、64 位虚拟机、64 位虚拟机开启指针压缩）下，对象头的具体存储内容，这部分内容比较难找到，备注如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位</span><br><span class="line">|----------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                    Object Header (64 bits)                             |        State       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|                  Mark Word (32 bits)                  |      Klass Word (32 bits)      |                    |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       Normal       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |      OOP to metadata object    |       Biased       |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|               ptr_to_lock_record:30          | lock:2 |      OOP to metadata object    | Lightweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|               ptr_to_heavyweight_monitor:30  | lock:2 |      OOP to metadata object    | Heavyweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line">|                                              | lock:2 |      OOP to metadata object    |    Marked for GC   |</span><br><span class="line">|-------------------------------------------------------|--------------------------------|--------------------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">64位</span><br><span class="line">|------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (128 bits)                                        |        State       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                         |    Klass Word (64 bits)     |                    |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | unused:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                       ptr_to_lock_record:62                         | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor:62                   | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                     | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">64位（开启指针压缩）</span><br><span class="line">|--------------------------------------------------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                            Object Header (96 bits)                                           |        State       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                  Mark Word (64 bits)                           |    Klass Word (32 bits)     |                    |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| unused:25 | identity_hashcode:31 | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Normal       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">| thread:54 |       epoch:2        | cms_free:1 | age:4 | biased_lock:1 | lock:2 |    OOP to metadata object   |       Biased       |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                         ptr_to_lock_record                            | lock:2 |    OOP to metadata object   | Lightweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                     ptr_to_heavyweight_monitor                        | lock:2 |    OOP to metadata object   | Heavyweight Locked |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br><span class="line">|                                                                       | lock:2 |    OOP to metadata object   |    Marked for GC   |</span><br><span class="line">|--------------------------------------------------------------------------------|-----------------------------|--------------------|</span><br></pre></td></tr></table></figure>

<br>

<hr>
<p>最后用一个例子检验上文中的内容，计算一个 HashMap 对象的大小。</p>
<p>HashMap 类不是数组，在 64 位开启指针压缩的情况下，对象头只包括 8 字节的标记字段和 4 字节的地址指针，总共 12 字节。</p>
<p>HashMap 类中分别有下列属性：</p>
<ul>
<li>entrySet （对象）</li>
<li>hashSeed （int）</li>
<li>loadFactor （float）</li>
<li>modCount （int）</li>
<li>size （int）</li>
<li>table （数组，当对象处理）</li>
<li>threshold （int）</li>
</ul>
<p>检查 HashMap 的所有父类，在 AbstractMap 中发现了两个新的属性：</p>
<ul>
<li>keySet （对象）</li>
<li>values （对象）</li>
</ul>
<p>算下来一共是 9 个属性，每个属性很巧都是 4 字节，一共是 9×4 = 36 字节，因此 HashMap 的对象内容为 36 字节。</p>
<p>HashMap 对象的对象头 12 字节 + 对象内容 36 字节总共是 48 字节，是 8 字节的倍数，无需对齐填充。</p>
<p>因此一个 HashMap 对象的大小是 48 字节。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap 与 TreeMap</title>
    <url>/2019/12/15/HashMap-%E4%B8%8E-TreeMap/</url>
    <content><![CDATA[<br>

<p>十二月的第三周，来补习 Java 基础，学习 HashMap 与 TreeMap 的原理。</p>
<p>上周看 HashMap 的迭代器源码看上头了，觉得真巧妙哈哈，顺便还看了一点 TreeMap 的源码（但是没写），也觉得挺精妙的。那么这周来学习这两种 map 的实现。</p>
<p>本次所看的 Java 源码均来自于 JDK 1.8，无视之前版本的实现。</p>
<hr>
<p>由于 HashMap 的实现需要红黑树的基础支持，因此我们先看 TreeMap，一个基于红黑树实现的 map。</p>
<h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>TreeMap：形式为 tree 的 map，确切地讲，这里的 tree 是 red black tree（红黑树）。</p>
<p>TreeMap 实现了 SortedMap 接口，因此是一个有排序的 map，表内每个元素在存储时都是按照规则排序的。</p>
<p>我们在使用 TreeMap 时，不论使用哪个方法，在内部基本都会使用到 TreeMap 的基本元素 Entry 类。Entry 本身的含义指键值对（key-value），这里是一个 TreeMap 自己定义和实现的类。从结构上看，TreeMap 对象就是由一个个的 Entry 对象所组成的。因此 TreeMap 在使用方法 get()、put()、remove()……时，实际上都是在操作它自己的一个个元素 Entry。</p>
<p>这里以 TreeMap 的 get() 方法为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法就是在调用 getEntry() 方法，根据 key 值获取一个基本存储元素：Entry。</p>
<p>TreeMap 的各个方法都在使用内部类 Entry，TreeMap 本身也就是由一个个的 Entry 对象组成的，因此我们先看看这个类的内部是什么样子。</p>
<br>

<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get、set方法等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TreeMap 内部自定义了 Entry 类，这个类实现了 Map.Entry 接口，也就是说，它是一个键值对（key-value）。</p>
<p>我们这里只需关注它的内部变量，其他的没必要关心（其他的是构造方法，get、set 方法，以及重写的 equals()、hashCode()、toString() 方法）。</p>
<p>Entry 类一共有六个成员变量：</p>
<ul>
<li>key  键</li>
<li>value  值</li>
<li>left  左节点</li>
<li>right  右节点</li>
<li>parent  父节点</li>
<li>color 颜色</li>
</ul>
<p>Entry 类除了 key 和 value 这两个所有 map 都必需的变量之外，还有四个成员变量，分别是左、右、父节点，以及一个布尔值变量：颜色。</p>
<p>成员变量里面有三个节点变量，以此能够猜出，这个类是一个节点类，比如链表里面的节点、树里面的节点等等，它能够从本节点找到其他的节点。而且变量里有左、右、父三个节点，看着就很像是二叉树的结构。</p>
<p>此外它还有一个布尔值变量：颜色。这个变量初见不是很理解，它有两种值，分别是红色（RED false）和黑色（BLACK true），默认是黑色的。这个布尔值变量，使得 Entry 类不光是二叉树的节点类，还是二叉树中红黑树的节点类，它在树节点之外还保留了另一种信息：类型。</p>
<br>

<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>写到这里必须要开始学习红黑树了。</p>
<p>我把基础设定为二叉树，二叉树及之前的内容不写了。我认为二叉树作为一种数据结构，它本身是没有功能的，只能算是有实现某些功能的潜质，比如有查找速度快的潜质。为了让二叉树能够真的查找速度变快，能快速地找到存储节点，需要给二叉树增加一些规则，比如存储时要按照某种顺序，分支的深度要有限制等等。</p>
<p>红黑树就是一种具有一些规则的二叉树，由于这些规则的限制，使得这种数据结构在查找存储内容时会快速很多。与红黑树作用类似的还有两种（我觉得看这两种也就够了叭），一种是二叉查找树（BST, Binary Search Tree），一种是平衡二叉树/ AVL 树（G. M. <font color="#32CD32"><strong>A</strong></font>delson-<font color="#32CD32"><strong>V</strong></font>elsky 和 E. M. <font color="#32CD32"><strong>L</strong></font>andis 发明的平衡二叉树）。当面试问到红黑树时，经常会被问到，既然有另外两种能够提高查询速度的二叉树了，为什么还需要红黑树（言下之意是问红黑树对比另外两种二叉树有什么不同），尤其是问红黑树相比于二叉查找树的优势。那么我从二叉查找树和 AVL 树开始写起，然后引到红黑树。</p>
<p>（这一部分基本上参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/72505589" target="_blank" rel="noopener">《记一次腾讯面试：有了二叉查找树、平衡树（AVL）为啥还需要红黑树？》</a>）</p>
<p>（以及所有的图片都来源于维基百科， 本周懒得画图hhh）</p>
<br>

<p><font color="#32CD32"><strong>二叉查找树</strong></font>给二叉树增加的规则是，左边比中间小，中间比右边小（左子树的节点值 &lt; 父节点值 &lt; 右子树的节点值），在存储的时候按照顺序存，找的时候就能很快地找到（因为有顺序了，不是漫无目的地找了）。</p>
<p>正常情况下，它是按照类似于二分查找法的思路去查询的。但是二叉查找树的规则约束性很有限，实际上即使按照规则，值依据链表的形式去存储也是合规的，但这样查询速度就又会慢了下来。</p>
<p><img src="/assets/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" alt="二叉搜索树"></p>
<br>

<p><font color="#32CD32"><strong>平衡二叉树</strong></font>在定义上有些模糊，我暂时认为，在通常情况下，平衡二叉树是二叉查找树的一种，即平衡二叉树的全称是【平衡二叉查找树】。在这种定义之下，平衡二叉树在二叉搜索树的基础之上，为二叉树增加了新的规则，它不光要求二叉树按照顺序存储，还要求二叉树要存储地更均衡一些，不能出现左子树一堆节点而右子树为空的情况（也就是刚才所说的类链表情况）。在维基百科里，平衡二叉树的英文名是 self-balancing binary search tree，自动平衡的二叉查找树。</p>
<p>平衡二叉树有好多种，最常被 cue 的是 AVL 树，因为它是所有平衡二叉树中最平衡的那种。AVL 树在二叉查找树的基础之上，为二叉树增加的规则是，二叉树的左右子树，最大深度的差不能超过 1。下图就是 AVL 树最不平衡的状态，存在左右子树高度差达到 1 的情况，但是你应该也会觉得：这又怎么样呢，差一点点就完美平衡了。</p>
<p><img src="/assets/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="1576491211135"></p>
<p>AVL 树是最为平衡的，排列有序的二叉树，因此它在查找节点时，查询速度是相当之快的，理论上应该是平衡二叉树中查询速度最快的。但是平衡是有代价的，存储得那么有序，找起来快，存起来、删起来也慢啊。AVL 树每次插入新的节点时，如果不平衡，是通过旋转来调整平衡的。我没兴趣去探索它具体的旋转过程，但是我大概知道结论：当插入/删除节点是，AVL 树会很频繁地旋转来调整，消耗很大。</p>
<br>

<p><font color="#32CD32"><strong>红黑树</strong></font>出现的意义就在于，它是平衡二叉树，但它不需要那么平衡，差不多就行，这样查询也快，插入也快。</p>
<p>红黑树为二叉树制定了五条规则（在数量上令小白发指）：</p>
<ol>
<li>每个节点有颜色，不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶子节点也是黑色的（NIL 节点）</li>
<li>中间的节点可以是红色的，但是红色节点不能连在一起（红色节点只能跟黑色节点相连）</li>
<li>（平衡的核心）从任意节点出发，到每个叶子节点，应途径数量一样的黑色节点。</li>
</ol>
<p><img src="/assets/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树"></p>
<p>边看图边思考上面的规则，主要是第四、五两条规则，会发现红黑树它的平衡之处就在于，受到这些规则约束的二叉树，深度就是差得再多，在最坏的情况下，也只会差一倍（从根到叶子的最长的可能路径不多于最短的可能路径的两倍长），这种二叉树大致上是平衡的。</p>
<p>红黑树插入节点时同样要通过旋转来调整，但是调整的次数比 AVL 树小了很多，它虽然比 AVL 树查得慢，但是它增改节点快，是一种不错的折中选择。</p>
<p>终于讲完了红黑树的引入部分。</p>
<br>

<h2 id="TreeMap-的-put-方法"><a href="#TreeMap-的-put-方法" class="headerlink" title="TreeMap 的 put() 方法"></a>TreeMap 的 put() 方法</h2><p>我这几个周看迭代器，看容器设计，感觉认识一个容器最直接、最迅速的方法，就是去看这个容器是怎么添加元素的，list 去看 add() 方法，map 去看 put() 方法。按照这种思路，去了解 TreeMap 的容器设计，应该首先去看 TreeMap 的 put() 方法，去看 TreeMap 怎么添加新的键值对。</p>
<p>从整体上看，TreeMap 的 put() 方法分三部分：</p>
<ol>
<li>如果是首次添加，初始化容器，并直接返回。</li>
<li>按照顺序<strong>直接</strong>插入新节点。</li>
<li>调整结构，以符合红黑树的规则。</li>
</ol>
<p>先把全部的代码展示出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;                                       |</span><br><span class="line">    Entry&lt;K,V&gt; t = root;                                             |</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;                                                 ■  若首次添加，初始化根节点</span><br><span class="line">        compare(key, key);                                           |</span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);                        |</span><br><span class="line">        size = <span class="number">1</span>;                                                    |</span><br><span class="line">        modCount++;                                                  |</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;                                                 |</span><br><span class="line">    &#125;                                                                |</span><br><span class="line">    <span class="keyword">int</span> cmp;                                                         |</span><br><span class="line">    Entry&lt;K,V&gt; parent;                                               |</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;                          |</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;                                               ■    如果有特定的Comparator比较器</span><br><span class="line">        <span class="keyword">do</span> &#123;                                                         | \  按照该Comparator的排序逻辑插入节点</span><br><span class="line">            parent = t;                                              |  \</span><br><span class="line">            cmp = cpr.compare(key, t.key);                           |   \</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                             |    \</span><br><span class="line">                t = t.left;                                          |    |</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)                                        |    |</span><br><span class="line">                t = t.right;                                         |    |</span><br><span class="line">            <span class="keyword">else</span>                                                     |    |</span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);                            |    |</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);                                         |    |</span><br><span class="line">    &#125;                                                                |    |</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                           |    ■  如果没有Comparator比较器</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)                                             |    |  按照默认逻辑排序（根据key的类型）</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                        |    |</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)                               |    |</span><br><span class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;   |    |</span><br><span class="line">        <span class="keyword">do</span> &#123;                                                         |    |</span><br><span class="line">            parent = t;                                              |    |</span><br><span class="line">            cmp = k.compareTo(t.key);                                |    |</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                             |    |</span><br><span class="line">                t = t.left;                                          |    |</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)                                        |    |</span><br><span class="line">                t = t.right;                                         |    |</span><br><span class="line">            <span class="keyword">else</span>                                                     |   /</span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);                            |  /</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);                                         | /</span><br><span class="line">    &#125;                                                                ■</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);                  |</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)                                                     |</span><br><span class="line">        parent.left = e;                                             |</span><br><span class="line">    <span class="keyword">else</span>                                                             |</span><br><span class="line">        parent.right = e;                                            |</span><br><span class="line">    fixAfterInsertion(e);                                            ■  调整结构，以符合红黑树规则</span><br><span class="line">    size++;                                                          |</span><br><span class="line">    modCount++;                                                      |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;                                                     |</span><br><span class="line">&#125;                                                                    |</span><br></pre></td></tr></table></figure>

<p>代码属于清晰简单的范畴，按代码的顺序简单阅读一下这段 put() 方法。</p>
<br>

<ol>
<li><p>初始化</p>
<p>put() 方法首先获取 TreeMap 对象的根节点，这个根节点的类型就是我们最开始时说的 Entry 类，是一个存储着键值对信息的红黑树节点。</p>
<p>如果发现没有根节点，就说明这个 TreeMap 对象从来没有执行过 put() 方法，没有存储任意一个键值对，那么在这种情况下，把本次 put() 方法带进来的键值对作为根节点保存起来，直接返回，不执行后续内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// TreeMap的key和value均不能为null，这里是在检查key是否是null</span></span><br><span class="line">        compare(key, key);</span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后续代码...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入节点</p>
<p>在拿到根节点之后，put() 方法就准备插入节点了。插入节点的这部分，并不关心红黑树的约束条件，也就是说如果插入之后不满足红黑树的条件了，也是没关系的。调整树的结构以符合红黑树的约束条件，这段逻辑在 put() 方法的最后一部分。</p>
<p>因此，插入节点时关注的，不在于插入前后是否都符合红黑树的要求，而在于找到插入点的位置。对于 TreeMap 而言，一切节点都是按照顺序存储的，找插入点，实际上就是在找新节点应该排在什么位置上，它应该插入到<code>左边的节点比它小，而右边的节点比它大</code>的位置处，当然了，前提是有一套计算顺序的规则。</p>
<p>根据有没有计算顺序的规则，put() 方法做了一层 if-else 的判断，如果有比较器，按比较器的来，如果没有比较器，按默认排序方式来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...找到根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmp;</span><br><span class="line">Entry&lt;K,V&gt; parent;</span><br><span class="line">Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line"><span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;                       <span class="comment">// 有比较器，按比较器排序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;                                   <span class="comment">// 没有比较器，按默认规则排序</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            t = t.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            t = t.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line"><span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">    parent.left = e;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    parent.right = e;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续代码...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="#32CD32"><strong>if</strong></font>-else：有 Comparator</p>
<p>说来又是我的知识盲区，我从来没有用过 Comparator 比较器，也是因为自己函数式编程写得少。</p>
<p>这里的 Comparator 对象，是 TreeMap 实例化时使用构造方法带进来的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有比较器，那么在插入节点时，按照二分查找法的思路执行。取父节点，计算大小关系（比较器的 compare() 方法），判断往左子树走还是往右子树走，直到再无子树。</p>
<p>这里的 Comparator 是自己实现的，意义就在于：自己指定了一套排序规则，让 TreeMap 中的元素按照这种规则存储。</p>
</li>
<li><p>if-<font color="#32CD32"><strong>else</strong></font>：无 Comparator</p>
<p>如果没有自己指定排序规则，那么 TreeMap 就会按照默认的方式进行排序。默认的排序方式是，让存储的 key-value 中的 key 提供排序规则，依照 key 的类型自带的排序规则进行排序。</p>
<p>具体来讲，就是 【treeMap.put(<font color="#CD32"><strong>key</strong></font>, value)】中的 key 需要实现 Comparable 接口。再换种说法解释，TreeMap 要求必须排序，如果你不主动提供排序规则，那就让 key 提供默认的排序规则（如果 key 没有排序规则，那只好报错）。</p>
<p>以最常见的情况举例：key 是 String 字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">treeMap.put(<span class="string">"str1"</span>, <span class="number">1</span>);</span><br><span class="line">treeMap.put(<span class="string">"str2"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这里有一处潜在的事情，那就是 String 类是实现了 Comparable 接口的，它有默认的排序规则。去看 String 类的结构体就能够发现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现 Comparable 接口，就必须重写 compareTo() 方法，也就是比较大小。String 类重写的 compareTo() 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑大意就是，字符逐个比较先后顺序，比到最后比字符串的长度。按照这种逻辑，”str1” &lt; “str2”（结果为 -1 小于 0）。</p>
<p>回看刚才向 treeMap 里 put 进两个键值对（”str1” -&gt; 1 和 “str2” -&gt; 2)，不管怎么插入，最终 treeMap 存储这两个键值对，都会是 key 为 “str1” 的键值对在前，因为在字符串的排序当中，它居前位。此时打印出 treeMap，总是会按照如下顺序输出：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;str1=1, str2=2&#125;</span><br></pre></td></tr></table></figure>

<p>如果 key 的类型并没有实现 Comparable 接口，没有重写 compareTo() 方法，在存入 TreeMap 时就会报错，抛出类型转换异常（ClassCastException）。</p>
</li>
</ul>
</li>
<li><p>调整树结构</p>
<p>这部分 TreeMap 抽出了一个单独的方法，用以调整插入新节点之后的树，调整成红黑树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// ...已插入新节点</span></span><br><span class="line"></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分是红黑树调整树结构的具体算法，枯燥、易忘、烧脑，正常人遇到这里都会绕开走……我只简单地看一遍，混个面熟就好。</p>
<p>插入的新节点默认是红色的，然后根据父节点和 uncle 节点判断左旋右旋之类的。</p>
<p>哎，找了个视频看，觉得麻烦得要命，算了算了，等自己强一点再回来看叭……下面是该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<br>

<p>TreeMap 的其他方法暂且就不看了，转 HashMap 去了。</p>
<br>

<hr>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap 就是跟 hash 走得特别近的 map。</p>
<p>TreeMap 是通过 key 按顺序找到存储位置的，HashMap 是通过 key 的 hashCode 计算算出来存储位置的。</p>
<br>

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>HashMap 通过【数组+链表+红黑树】的数据结构存储键值对，很精巧的一种设计。</p>
<p>// 图</p>
<p>大体的存储逻辑是这样的：</p>
<ol>
<li>先在数组里存：计算哈希值，并根据哈希值取余，得知存在数组的第几个格子中，存入。</li>
<li>有则转链表：存数组时，如果格子里面已经有数据了，则按链表的结构存（尾插法）。</li>
<li>过长则转红黑树：存链表时，如果链表过长（超过 8 个），将链表转成红黑树，之后再插入新元素，按红黑树存储。</li>
</ol>
<br>

<h2 id="HashMap-的-put-方法"><a href="#HashMap-的-put-方法" class="headerlink" title="HashMap 的 put() 方法"></a>HashMap 的 put() 方法</h2><p>跟 TreeMap 一样，我们了解 HashMap 也是通过 put() 方法。</p>
<p>put() 方法的源码只有三行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>HashMap 的 put() 方法调用了一个私有方法，所有的代码逻辑都装在私有方法里。</p>
<p>这么看肯定是看不出 HashMap 的存储逻辑，但是通过 putVal() 方法的结构体，还是能够看出些东西。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="#32CD32"><strong>hash</strong></font>：key 的类哈希值</p>
<p>调用 hash() 方法获得，将 key 的哈希值前后 16 位进行与运算，以扩大 key 的哈希值差异。这样做能够使 hashMap 在存储数据时，存储地更平均。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="#32CD32"><strong>key</strong></font>：键</p>
</li>
<li><p><font color="#32CD32"><strong>value</strong></font>：值</p>
</li>
<li><p><font color="#32CD32"><strong>onlyIfAbsent</strong></font>：key 重复时是否保留原数据。</p>
<p>true：保留原 value</p>
<p>false：使用新 value</p>
</li>
<li><p><font color="#32CD32"><strong>evict</strong></font>：留给子类 LinkedHashMap 使用的，但无论是 true 还是 false 在 LinkedHashMap 里结果都是一样的，哎懒得看了，之后有机会再看吧。</p>
</li>
</ul>
<br>

<p>看完结构体，来看 putVal() 的具体实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;  |</span><br><span class="line">   Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;                                       |</span><br><span class="line">   <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)                           ■  初始化（第一次的话）</span><br><span class="line">       n = (tab = resize()).length;                                              |</span><br><span class="line">   <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)                                    ■  如果没有hash碰撞，直接插入</span><br><span class="line">       tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);                                 | \</span><br><span class="line">   <span class="keyword">else</span> &#123;                                                                        |   ■ 如果发生hash碰撞...</span><br><span class="line">       Node&lt;K,V&gt; e; K k;                                                         |   |</span><br><span class="line">                                                                                 |   |</span><br><span class="line">       <span class="keyword">if</span> (p.hash == hash &amp;&amp;                                                     |   ■  处理key已存在的情况</span><br><span class="line">           ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))               |   | \</span><br><span class="line">           e = p;                                                                |   |  \</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)                                           |   |   ■  以红黑树的结构存储</span><br><span class="line">           e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);       |   |   | \</span><br><span class="line">       <span class="keyword">else</span> &#123;                                                                    |   |   |   ■  以链表的结构存储</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;                                |   |   |   |</span><br><span class="line">               <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;                                       |   |   |   |</span><br><span class="line">                   p.next = newNode(hash, key, value, <span class="keyword">null</span>);                     |   |   |   |</span><br><span class="line">                   <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)                        |   |   |   |</span><br><span class="line">                       treeifyBin(tab, hash);                                    |   |   |   |</span><br><span class="line">                   <span class="keyword">break</span>;                                                        |   |   |   |</span><br><span class="line">               &#125;                                                                 |   |   |   |</span><br><span class="line">               <span class="keyword">if</span> (e.hash == hash &amp;&amp;                                             |   |   |   |</span><br><span class="line">                   ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))       |   |   |  /</span><br><span class="line">                   <span class="keyword">break</span>;                                                        |   |   | /</span><br><span class="line">               p = e;                                                            |   |   |/</span><br><span class="line">           &#125;                                                                     |   |  /</span><br><span class="line">       &#125;                                                                         |   | /</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;                                                          |   ■  替换key已存在时的value</span><br><span class="line">           V oldValue = e.value;                                                 |   |</span><br><span class="line">           <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)                                |   |</span><br><span class="line">               e.value = value;                                                  |   |</span><br><span class="line">           afterNodeAccess(e);                                                   |   |</span><br><span class="line">           <span class="keyword">return</span> oldValue;                                                      |  /</span><br><span class="line">       &#125;                                                                         | /</span><br><span class="line">   &#125;                                                                             ■</span><br><span class="line">   ++modCount;                                                                   |</span><br><span class="line">   <span class="keyword">if</span> (++size &gt; threshold)                                                       ■  扩容内部数组（若有需要）</span><br><span class="line">       resize();                                                                 |</span><br><span class="line">   afterNodeInsertion(evict);                                                    ■  为子类LinkedHashMap提供</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;                                                                  |  HashMap这里只是空实现</span><br><span class="line">&#125;                                                                                |</span><br></pre></td></tr></table></figure>

<p>HashMap 的 putVal() 方法逻辑，跟 HashMap 的存储结构是完全契合的：</p>
<ol>
<li>初始化 hashMap（即第一次使用 put() 方法）</li>
<li>算出数组位置后，能插入数据就插进去</li>
<li>如果不能插进去，分三种情况分析<ol>
<li>key 已存在，将新的 value 替换掉旧的 value</li>
<li>数组位置内已经存了链表：链表长度超过 8 则转红黑树，没超过则尾插链表</li>
<li>数组位置内已经存了红黑树：红黑树插入数据</li>
</ol>
</li>
<li>hashMap 内部数据过多则扩容数组（默认下，过多的标志：size &gt; 数组长度 × 0.75）</li>
</ol>
<br>

<p>HashMap 里的 put() 方法里有很多可以看的地方，包括【链表转红黑树】、【数组扩容】、【hash 值和负载值等的位运算】等，大概看了几眼，时间赶就不详叙述了。</p>
<p>这周就看到这里吧。</p>
<br>

]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 入门</title>
    <url>/2020/06/07/MongoDB/</url>
    <content><![CDATA[<br>

<p>六月份到了，六月的第一周来写 MongoDB。</p>
<p>MongoDB 是一种面向文档的非关系型数据库，面向文档的意思是，把半结构化的数据存储为文档（XML、YAML、JSON 等），MongoDB 把数据存储为 BSON（<a href="http://bsonspec.org/" target="_blank" rel="noopener">Binary JSON, is a bin­ary-en­coded seri­al­iz­a­tion of JSON-like doc­u­ments</a>）格式。</p>
<p>有关面向文档，看到这么一篇知乎文章：《<a href="https://www.zhihu.com/question/28003788/answer/632972138" target="_blank" rel="noopener">常见 NoSQL 数据库的应用场景是怎么样的？</a>》</p>
<blockquote>
<p>在文档数据库中的“文档”和传统意义的“文档”没什么关系，它不是书、信或者文章，这里说的“文档”其实是一个数据记录，这个记录能够对包含的数据类型和内容进行“自我描述”。XML 文档、HTML 文档和 JSON 文档就属于这一类。文档数据库可以包含非常复杂的数据结构，比如嵌套对象并且不需要使用特定的数据模式，每个文档可以具有完全不同的结构。</p>
</blockquote>
<p>如果做一个简单映射，那么关系型数据库的<code>表</code>，就是 MongoDB 的<code>集合（Collection）</code>；关系型数据库的<code>行</code>，就是 MongoDB 的<code>文档（Document）</code>，关系型数据库的这两行数据：</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>NAME</th>
<th>AGE</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>22</td>
</tr>
</tbody></table>
<p>就是 MongoDB 中的这两个文档：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ID"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">"NAME"</span>:<span class="string">"张三"</span>,</span><br><span class="line">    <span class="attr">"AGE"</span>:<span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"ID"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"NAME"</span>:<span class="string">"李四"</span>,</span><br><span class="line">    <span class="attr">"AGE"</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h1><h2 id="SQL-术语和-MongoDB-术语之间的映射关系："><a href="#SQL-术语和-MongoDB-术语之间的映射关系：" class="headerlink" title="SQL 术语和 MongoDB 术语之间的映射关系："></a>SQL 术语和 MongoDB 术语之间的<a href="https://docs.mongodb.com/manual/reference/sql-comparison/" target="_blank" rel="noopener">映射关系</a>：</h2><table>
<thead>
<tr>
<th align="left">SQL Terms/Concepts</th>
<th align="left">MongoDB Terms/Concepts</th>
</tr>
</thead>
<tbody><tr>
<td align="left">database</td>
<td align="left">database</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">collection</td>
</tr>
<tr>
<td align="left">row</td>
<td align="left">document or BSON document</td>
</tr>
<tr>
<td align="left">column</td>
<td align="left">field</td>
</tr>
<tr>
<td align="left">index</td>
<td align="left">index</td>
</tr>
<tr>
<td align="left">table joins</td>
<td align="left">$lookup, embedded documents</td>
</tr>
<tr>
<td align="left">primary key</td>
<td align="left">primary key（在 MongoDB 中，primary key 是自动生成并设置为设置为 <code>_id</code> 字段的</td>
</tr>
<tr>
<td align="left">aggregation (e.g. group by)</td>
<td align="left">aggregation pipeline（聚合管道）</td>
</tr>
</tbody></table>
<br>

<h2 id="一个样例文档（Document）："><a href="#一个样例文档（Document）：" class="headerlink" title="一个样例文档（Document）："></a>一个样例文档（Document）：</h2><p>（对应着 SQL 中的一条数据）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _id: ObjectId("509a8fb2f3f4948bd2f983a0"),</span><br><span class="line">  user_id: "abc123",</span><br><span class="line">  age: 55,</span><br><span class="line">  status: 'A',</span><br><span class="line">  tags: ['test', '2020']</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>实际上有很多函数可用，例如删除相关的函数有 <code>delete</code>、<code>deleteOne</code>、<code>deleteMany</code>、<code>remove</code>、<code>findOneAndRemove</code>、<code>findAndModify()</code> 等，下面列出我自认为常用的，此外还可以参考<a href="https://docs.mongodb.com/manual/reference/sql-comparison/" target="_blank" rel="noopener">官方文档</a>（当页往下翻）。</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td>select * from user</td>
<td>db.user.find()</td>
</tr>
<tr>
<td></td>
<td>select name, age from user</td>
<td>db.user.find({},{name:1,age:1})</td>
</tr>
<tr>
<td></td>
<td>select * from user where name = ‘ZhangSan’</td>
<td>db.user.find({name:”ZhangSan”})</td>
</tr>
<tr>
<td></td>
<td>select * from user where name is not null</td>
<td>db.user.find({name:{$ne:null}})</td>
</tr>
<tr>
<td></td>
<td>select * from user where name like ‘%name%’</td>
<td>db.user.find({name:{$regex:”name”}})<br>db.user.find({name:/name/})</td>
</tr>
<tr>
<td></td>
<td>select * from user order by age desc</td>
<td>db.user.find().sort({age:-1})</td>
</tr>
<tr>
<td></td>
<td>select * from user group by age</td>
<td>参见聚合</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>增加</td>
<td>INSERT INTO user (name, age) VALUES (‘pz’, 23)</td>
<td>db.user.insert({name:”pz”, age:23})</td>
</tr>
<tr>
<td></td>
<td>插入多条</td>
<td>db.user.insertMany([<br>{name:”boy1”, age:20},<br>{name:”boy2”, age:18, tags:[“funny”]}<br>])</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>更改</td>
<td>UPDATE user SET age=21 WHERE age=20</td>
<td>db.user.updateMany({age:20},{$set:{age:21}})</td>
</tr>
<tr>
<td></td>
<td>UPDATE user SET age=21 WHERE age=20 limit 1</td>
<td>db.user.update({age:20},{$set:{age:21}})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>删除</td>
<td>delete from user where age = 20</td>
<td>db.user.deleteMany({age:20})</td>
</tr>
<tr>
<td></td>
<td>delete from user where age = 20 limit 1</td>
<td>db.user.delete({age:100})</td>
</tr>
</tbody></table>
<br>

<h2 id="聚合（aggregate）"><a href="#聚合（aggregate）" class="headerlink" title="聚合（aggregate）"></a>聚合（aggregate）</h2><p>聚合可以简单理解成高级操作，官方的解释有点绕：聚合处理数据并返回结果（Aggregation operations process data records and return computed results）。</p>
<p>聚合有三种类型，分别是聚合管道（Aggregate Pipeline）、Map-Reduce（一般不翻译）、单用途聚合操作（Single Purpose Aggregation Operations）。一般提到聚合，指的是第一种：聚合管道。</p>
<p>下面逐个学习这三种聚合。</p>
<br>

<h3 id="1-聚合管道"><a href="#1-聚合管道" class="headerlink" title="1. 聚合管道"></a>1. 聚合管道</h3><p>MongoDB 指的 pipeline 像是 Java 中的流运算，或者是 linux 系统中的管道，意思是文档（数据）经历一系列的节点（当然也可以是一个节点），一个节点接一个地处理文档，上个节点运算完的结果，作为下个节点的输入，最终输出一堆聚合文档，比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.user.aggregate(</span><br><span class="line">    [</span><br><span class="line">        <span class="comment">// name和age不能为null</span></span><br><span class="line">        &#123;</span><br><span class="line">            $match:&#123;name:&#123;$ne:<span class="keyword">null</span>&#125;, age:&#123;$ne:<span class="keyword">null</span>&#125;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 只输出name、age、tags字段</span></span><br><span class="line">        &#123;</span><br><span class="line">            $project:&#123;name:<span class="number">1</span>, age:<span class="number">1</span>, tags:<span class="number">1</span>&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 按照age倒序排序</span></span><br><span class="line">        &#123;</span><br><span class="line">            $sort:&#123;age:-<span class="number">1</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>aggregate</th>
<th>描述</th>
<th>样例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-project.html#pipe._S_out" target="_blank" rel="noopener">$project</a></td>
<td>指定字段</td>
<td>db.user.aggregate([     {         $project:{name:1, age:1}     } ])</td>
<td><code>_id</code> 默认指定，如果不想要，则需 <code>_id:0</code></td>
</tr>
<tr>
<td></td>
<td>指定字段（起别名）</td>
<td>db.user.aggregate([     {         $project:{alias:”$name”}     } ])</td>
<td>别名在冒号前，字段名在冒号后</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-match.html#pipe._S_lookup" target="_blank" rel="noopener">$match</a></td>
<td>匹配字段</td>
<td>db.user.aggregate([     {         $match:{age:{$gt:10}}     } ])<br>（年龄大于10岁）</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-count.html#pipe._S_collStats" target="_blank" rel="noopener">$count</a></td>
<td>计数</td>
<td>db.user.aggregate([     {         $count:”countNum”     } ])</td>
<td>冒号后代表展示字段名</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-group.html#pipe._S_graphLookup" target="_blank" rel="noopener">$group</a></td>
<td>分组</td>
<td>db.user.aggregate([     {         $group:{_id:”$age”,nameList:{$addToSet:”$name”}}     } ])（按年龄统计，获取名字列表）</td>
<td><code>_id</code> 必填，指定要分组的字段，字段均需要带<code>$</code>符号，更多操作可参考 <a href="https://www.cnblogs.com/shaosks/p/5760819.html" target="_blank" rel="noopener">这篇博文</a></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-sort.html#pipe._S_skip" target="_blank" rel="noopener">$sort</a></td>
<td>排序</td>
<td>db.user.aggregate([     {         $sort:{age:1}     } ])</td>
<td>1：升序、-1：降序<br>如果在 <code>$sort</code> 操作之前发生 <code>$project</code>、<code>$unwind</code>或 <code>$group</code>，则 <code>$sort</code> 不能使用任何索引。</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-lookup.html#pipe._S_listSessions" target="_blank" rel="noopener">$lookup</a></td>
<td>左连接</td>
<td>db.user.aggregate([     {         $lookup:{             from:”organization”,             localField:”organization_name”,             foreignField:”name”,             as:”orgInfo”         }     } ])</td>
<td><code>from</code>：要关联的集合（表）、<code>localField</code>：本集合字段、<code>foreignField</code>：要关联的字段、<code>as</code>：新字段名</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-limit.html#pipe._S_indexStats" target="_blank" rel="noopener">$limit</a></td>
<td>只取前几条</td>
<td>db.user.aggregate([     {         $limit:10     } ])</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-skip.html#pipe._S_sample" target="_blank" rel="noopener">$skip</a></td>
<td>跳过前N个文档</td>
<td>db.user.aggregate([     {         $skip:5     } ])</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-unwind.html#pipe._S_sortByCount" target="_blank" rel="noopener">$unwind</a></td>
<td>一个文档（数据）拆成多个文档</td>
<td>db.user.aggregate([     {         $unwind:”$tags”     } ])</td>
<td>注意 <code>$</code> 符号</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-sample.html#pipe._S_replaceRoot" target="_blank" rel="noopener">$sample</a></td>
<td>随机选N个文档</td>
<td>db.user.aggregate([     {         $sample:{size:10}     } ])</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-out.html#pipe._S_match" target="_blank" rel="noopener">$out</a></td>
<td>将结果保存成新表</td>
<td>db.user.aggregate([     {         $limit:10     },     {         $out:”test”     } ])<br>（将 user 表的前 10 条数据存入 test 表中</td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-bucket.html#pipe._S_addFields" target="_blank" rel="noopener">$bucket</a></td>
<td>分组</td>
<td>db.user.aggregate([     {         $bucket:{             groupBy:”$sort”,             boundaries:[5,8,10,12],             default:”other”,             output:{                 count:{$sum:1},                 titles:{$push:”$sort”}             }         }     } ])</td>
<td>难以描述，用得不多，现用现查</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-aggregation-graphLookup.html" target="_blank" rel="noopener">$graphLookup</a></td>
<td>递归往上查</td>
<td>{     $graphLookup:{         from:”user”,         startWith:”$parentId”,         connectFromField:”parentId”,         connectToField:”_id”,         as:”fatherList”     } }</td>
<td>注意 <code>startWith</code> 后面跟的内容带 <code>$</code> 符号，结果会按递归查到的顺序逆序排列</td>
</tr>
</tbody></table>
<p>还有一些别的，用到了再回来补。</p>
<br>

<h3 id="2-Map-Reduce"><a href="#2-Map-Reduce" class="headerlink" title="2. Map-Reduce"></a>2. Map-Reduce</h3><p>我目前用到的还不多，所以不想写了（hh），可以参考这篇文章<a href="https://www.jianshu.com/p/bb1c809dcf37" target="_blank" rel="noopener">《MongoDB Map-Reduce详细操作总结》</a>，写得很容易理解概念。</p>
<p>以后需要用到了再回来补。</p>
<br>

<h3 id="3-单用途聚合操作"><a href="#3-单用途聚合操作" class="headerlink" title="3. 单用途聚合操作"></a>3. 单用途聚合操作</h3><p>就是简化版的聚合管道，官方目前（Version 4.2）在文档中提到了三种，简单整理成下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>计数</td>
<td>select count(*) from user</td>
<td>db.collection.estimatedDocumentCount()</td>
</tr>
<tr>
<td></td>
<td></td>
<td>db.user.count()（废弃）</td>
</tr>
<tr>
<td>返回字段的所有值</td>
<td>（有点像）select name from user group by name</td>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-method-db.collection.distinct.html#db.collection.distinct" target="_blank" rel="noopener">db.user.distinct(“name”)</a>（不理解的话点击看官方文档）</td>
</tr>
</tbody></table>
<p>除了这三种应该还有的是方法，但是我分辨不出来是不是属于这一类，因此先不整理了。</p>
<br>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-eq.html#op._S_eq" target="_blank" rel="noopener">$eq</a></td>
<td>等于</td>
<td>db.user.find({name:{$eq:”pz”}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-ne.html#op._S_ne" target="_blank" rel="noopener">$ne</a></td>
<td>不等于</td>
<td>db.user.find({name:{$ne:null}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-gt.html#op._S_gt" target="_blank" rel="noopener">$gt</a></td>
<td>大于</td>
<td>db.user.find({age:{$gt:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-gte.html#op._S_gte" target="_blank" rel="noopener">$gte</a></td>
<td>大于等于</td>
<td>db.user.find({age:{$gte:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-lt.html#op._S_lt" target="_blank" rel="noopener">$lt</a></td>
<td>小于</td>
<td>db.user.find({age:{$lt:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-lte.html#op._S_lte" target="_blank" rel="noopener">$lte</a></td>
<td>小于等于</td>
<td>db.user.find({age:{$lte:10}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-in.html#op._S_in" target="_blank" rel="noopener">$in</a></td>
<td>匹配 array 中指定的任何值</td>
<td>db.user.find({age:{$in:[10,20]}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-nin.html#op._S_nin" target="_blank" rel="noopener">$nin</a></td>
<td>匹配 array 中指定的任何值之外</td>
<td>db.user.find({age:{$nin:[10,20]}})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-and.html#op._S_and" target="_blank" rel="noopener">$and</a></td>
<td>并且</td>
<td>db.user.find({$and:[{age:23},{name:”pz”}]})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-not.html#op._S_not" target="_blank" rel="noopener">$not</a></td>
<td>非</td>
<td>db.user.find({name:{$not:/name/}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-nor.html#op._S_nor" target="_blank" rel="noopener">$nor</a></td>
<td>都非</td>
<td>db.user.find({$nor:[{name:”pz”},{age:10}]})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-or.html#op._S_or" target="_blank" rel="noopener">$or</a></td>
<td>或</td>
<td>db.user.find({$or:[{name:”pz”},{age:10}]})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-exists.html#op._S_exists" target="_blank" rel="noopener">$exists</a></td>
<td>具有指定字段（包括null）</td>
<td>db.user.find({age:{$exists:true}})</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/type/#op._S_type" target="_blank" rel="noopener">$type</a></td>
<td>字段是指定类型</td>
<td>db.user.find({name:{$type:”string”}})</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-regex.html#op._S_regex" target="_blank" rel="noopener">$regex</a></td>
<td>匹配正则表达式</td>
<td>db.user.find({name:{$regex:”^name.*$”}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-expr.html#op._S_expr" target="_blank" rel="noopener">$expr</a></td>
<td>允许在查询语言中使用聚合表达式</td>
<td>db.user.find({$expr:{$gt:[“$age”,10]}})</td>
</tr>
<tr>
<td><a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-mod.html#op._S_mod" target="_blank" rel="noopener">$mod</a></td>
<td>指定字段是取模成功的</td>
<td>db.user.find({age:{$mod:[10,0]}})</td>
</tr>
</tbody></table>
<p>剩下的用到再补，英文文档参考<a href="https://docs.mongodb.com/manual/reference/operator/query/" target="_blank" rel="noopener">《Query and Projection Operators》</a>，汉化文档（机翻，版本 v3.6）参考<a href="https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query.html#%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%8A%95%E5%BD%B1%E6%93%8D%E4%BD%9C%E5%91%98" target="_blank" rel="noopener">《查询和投影操作员》</a>。</p>
<hr>
<h1 id="Spring-Data-MongoDB"><a href="#Spring-Data-MongoDB" class="headerlink" title="Spring Data MongoDB"></a>Spring Data MongoDB</h1><p>数据库连接、事务之类的操作就先不学习了，本篇主要学习 CRUD。</p>
<br>

<p>Spring 操作 MongoDB 的类有两种（在我的工作中），分别是 <code>MongoTemplate</code> 和 <code>ReactiveMongoTemplate</code>，前者是普通操作数据库，后者是响应式操作数据库（响应式以后应该会写博文），操作这两个类的 API 几乎是完全相同的，区别只在返回值上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条数据，返回这个数据</span></span><br><span class="line">Object insert1 = mongoTemplate.insert(object);</span><br><span class="line"><span class="comment">// 插入一条数据，返回一个Mono</span></span><br><span class="line">Mono&lt;Object&gt; insert2 = reactiveMongoTemplate.insert(object);</span><br></pre></td></tr></table></figure>

<p>下文以 <code>MongoTemplate</code> 为例，学习 Spring Data MongoDB（其实是一样的，区别只在响应式上）。</p>
<br>

<h2 id="普通操作"><a href="#普通操作" class="headerlink" title="普通操作"></a>普通操作</h2><p>作为 Spring Data 中的一族，Spring Data Mongo 的普通操作（CRUD）跟其他 ORM 框架操作很相近，用过几次就很熟悉了，这里不详细用语言描述了，只整理表格如下（表格下有备注）：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>方法</th>
<th>样例（方法返回值不写了，写了不直观）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>查</td>
<td>find</td>
<td>mongoTemplate.find(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.find(query, User.class, “user”);</td>
<td>指定表名，用于表和输出结果不匹配的情况</td>
</tr>
<tr>
<td></td>
<td>findById</td>
<td>mongoTemplate.findById(id, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findById(id, User.class, “user”);</td>
<td>指定表名，同find</td>
</tr>
<tr>
<td></td>
<td>findOne</td>
<td>mongoTemplate.findOne(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findOne(query, User.class, “user”);</td>
<td>指定表名，同find</td>
</tr>
<tr>
<td></td>
<td>findAll</td>
<td>mongoTemplate.findAll(User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findAll(User.class, “user”);</td>
<td>指定表名，同find</td>
</tr>
<tr>
<td></td>
<td>findDistinct</td>
<td>mongoTemplate.findDistinct(“name”, User.class, String.class)</td>
<td>查指定字段（一共有四种，就写了两种）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.findDistinct(query, “name”, User.class, String.class)</td>
<td></td>
</tr>
<tr>
<td>计数</td>
<td>count</td>
<td>mongoTemplate.count(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.count(query, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.count(query, UserDto.class, “user”);</td>
<td>指定输出类、表名</td>
</tr>
<tr>
<td>插入</td>
<td>insert</td>
<td>mongoTemplate.insert(user);</td>
<td>单条插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.insert(user, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.insert(userList, “user”);</td>
<td>批量插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.insert(userList, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>insertAll</td>
<td>mongoTemplate.insertAll(userList);</td>
<td></td>
</tr>
<tr>
<td>保存</td>
<td>save</td>
<td>mongoTemplate.save(user);</td>
<td>只能保存单条数据，有则更新，无则插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.save(user, “user”);</td>
<td></td>
</tr>
<tr>
<td>更新</td>
<td>updateFirst</td>
<td>mongoTemplate.updateFirst(query, update, User.class);</td>
<td>修改第一条</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateFirst(query, update, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateFirst(query, update, UserDto.class, “user”);</td>
<td>指定输出类、表名</td>
</tr>
<tr>
<td></td>
<td>updateMulti</td>
<td>mongoTemplate.updateMulti(query, update, User.class);</td>
<td>修改所有</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateMulti(query, update, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.updateMulti(query, update, UserDto.class, “user”);</td>
<td>指定输出类、表名</td>
</tr>
<tr>
<td>更新或插入</td>
<td>upsert</td>
<td>mongoTemplate.upsert(query, update, User.class);</td>
<td>有则更新，无则插入</td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.upsert(query, update, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.upsert(query, update, User.class, “user”);</td>
<td></td>
</tr>
<tr>
<td>存在</td>
<td>exists</td>
<td>mongoTemplate.exists(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.exists(query, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.exists(query, User.class, “user”);</td>
<td>第二个参数没有意义，可以为null，<br>查询时以第三个参数为依据</td>
</tr>
<tr>
<td>删除</td>
<td>remove</td>
<td>mongoTemplate.remove(user);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(user, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(query, User.class);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(query, “user”);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>mongoTemplate.remove(query, User.class, “user”);</td>
<td></td>
</tr>
</tbody></table>
<p>备注：</p>
<ol>
<li><p>查询时常用到 <code>Query</code> 和 <code>Criteria</code> 类，这两个类我懒得写了，贴一点代码吧，看一看就懂了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line">Query query = Query.query(Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line">Criteria criteria = Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>)</span><br><span class="line">                .and(<span class="string">"age"</span>).is(<span class="number">23</span>)</span><br><span class="line">                .and(<span class="string">"height"</span>).gt(<span class="number">170</span>);</span><br><span class="line">Query query = <span class="keyword">new</span> Query(criteria);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法3</span></span><br><span class="line">Criteria criteria = Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>);</span><br><span class="line">Query query = <span class="keyword">new</span> Query();</span><br><span class="line">query.addCriteria(criteria);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Update</code> 类是跟 <code>Query</code> 同等地位的类，用于 MongoDB 的更新操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于&#123;$set: &#123;name: "pz"&#125;&#125;，内部Java实现是return new Update().set(key, value);</span></span><br><span class="line">Update update = Update.update(<span class="string">"name"</span>, <span class="string">"pz"</span>);</span><br><span class="line"></span><br><span class="line">Update update = <span class="keyword">new</span> Update();</span><br><span class="line"><span class="comment">// 相当于&#123;$set: &#123;name: "pz"&#125;&#125;</span></span><br><span class="line">update.set(<span class="string">"name"</span>, <span class="string">"pz"</span>);</span><br><span class="line"><span class="comment">// 相当于&#123;$push: &#123;tags: "IT"&#125;&#125;，即tags字段（列表）增加一个元素"pz"</span></span><br><span class="line">update.push(<span class="string">"tags"</span>, <span class="string">"IT"</span>);</span><br><span class="line"><span class="comment">// 相当于&#123;$inc: &#123;age: 2&#125;&#125;，即age字段增加2</span></span><br><span class="line">update.inc(<span class="string">"age"</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>find 还有几种方法：<code>findAndModify</code>、<code>findAndRemove</code>、<code>findAndReplace</code>、<code>findAllAndRemove</code>，我觉得没什么用，没整理。</p>
</li>
</ol>
<br>

<h2 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h2><p>Spring Data MongoDB 涉及到聚合相关的类有四个，分别是：</p>
<ul>
<li><p><code>Aggregation</code>：代表着 MongoDB 的 aggregate（聚合），例如下面这个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于db.user.aggregate([...])</span></span><br><span class="line">mongoTemplate.aggregate(aggregation, User.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>TypedAggregation</code>：是 Aggregation 的子类，在 Aggregation 的基础上增加了类型，来指定是对哪张表进行聚合操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定操作user表的aggregate</span></span><br><span class="line">TypedAggregation&lt;User&gt; typedAggregation = Aggregation.newAggregation(User.class, operations);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AggregationOperation</code>：聚合的具体操作，有很多子类，对应着一个个的 <code>MongoDB aggregation pipeline operation</code>，举例而言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于&#123;$project: &#123;a: 1, b: 1, thing2: $thing1&#125;&#125;</span></span><br><span class="line">Aggregation.project(<span class="string">"a"</span>, <span class="string">"b"</span>).and(<span class="string">"thing1"</span>).as(<span class="string">"thing2"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AggregationResults</code>：聚合查询结果（非响应式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AggregationResults&lt;User&gt; result = mongoTemplate.aggregate(typedAggregation, User.class);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>举一个例子，把 <code>Aggregation</code>、<code>AggregationOperation</code>、<code>AggregationResults</code> 串起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// db.user.aggregate([</span></span><br><span class="line"><span class="comment">//   &#123;$match: &#123;name: "pz"&#125;&#125;,</span></span><br><span class="line"><span class="comment">//   &#123;$project: &#123;name: 1, age: 1, tags: 1&#125;&#125;,</span></span><br><span class="line"><span class="comment">//   &#123;$limit: 1&#125;</span></span><br><span class="line"><span class="comment">// ])</span></span><br><span class="line">AggregationResults&lt;User&gt; result = mongoTemplate.aggregate(</span><br><span class="line">        Aggregation.newAggregation(</span><br><span class="line">                Aggregation.match(Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>)),</span><br><span class="line">                Aggregation.project(<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"tags"</span>),</span><br><span class="line">                Aggregation.limit(<span class="number">1</span>)</span><br><span class="line">        ),</span><br><span class="line">        <span class="string">"user"</span>,     <span class="comment">// 数据库表</span></span><br><span class="line">        User.class  <span class="comment">// 输出类型</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>学习 Spring Data MongoDB 聚合，主要是学习 <code>AggregationOperation</code> 的所有子类，把各种聚合操作都熟悉之后，用 <code>Aggregation.newAggregation()</code> 组合在一起执行就可以了。</p>
<p>有关聚合的所有操作，基本都有两种创建方式：静态工厂方法和构造方法，官方推荐使用静态工厂方法创建，而非构造方法（尽管背后实现是完全相同的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 官方推荐，这样更易于阅读</span></span><br><span class="line">ProjectionOperation projectionOperation1 = Aggregation.project();</span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line">ProjectionOperation projectionOperation2 = <span class="keyword">new</span> ProjectionOperation();</span><br></pre></td></tr></table></figure>

<p>接下来一个个 <code>AggregationOperation</code> 说，把常用的聚合操作学习完。</p>
<br>

<h3 id="1-ProjectionOperation"><a href="#1-ProjectionOperation" class="headerlink" title="1. ProjectionOperation"></a>1. ProjectionOperation</h3><p>指定字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $project:&#123;</span></span><br><span class="line"><span class="comment">//       name:1,</span></span><br><span class="line"><span class="comment">//       age:1,</span></span><br><span class="line"><span class="comment">//       idDelete:"$is_deleted",</span></span><br><span class="line"><span class="comment">//       _id:0,</span></span><br><span class="line"><span class="comment">//       nickName:1</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">ProjectionOperation projectionOperation = Aggregation.project(<span class="string">"name"</span>, <span class="string">"age"</span>)</span><br><span class="line">        .and(<span class="string">"is_deleted"</span>).as(<span class="string">"idDelete"</span>)</span><br><span class="line">        .andExclude(<span class="string">"_id"</span>)</span><br><span class="line">    	.andInclude(<span class="string">"nickName"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>and()</code> 需要配合 <code>as()</code> 一起用，表示别名，不能单独使用（因为返回类型不一样）</li>
<li><code>andInclude()</code> 和 <code>and()</code> 的区别是，前者单独使用，后者配合 <code>as()</code> 使用 </li>
</ul>
<br>

<h3 id="2-MatchOperation"><a href="#2-MatchOperation" class="headerlink" title="2. MatchOperation"></a>2. MatchOperation</h3><p>查询（相当于 Query）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $match:&#123;</span></span><br><span class="line"><span class="comment">//         name:"pz",</span></span><br><span class="line"><span class="comment">//         age:&#123;$gt: 20&#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Criteria criteria = Criteria.where(<span class="string">"name"</span>).is(<span class="string">"pz"</span>).and(<span class="string">"age"</span>).gt(<span class="number">20</span>);</span><br><span class="line">MatchOperation matchOperation = Aggregation.match(criteria);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="3-LookupOperation"><a href="#3-LookupOperation" class="headerlink" title="3. LookupOperation"></a>3. LookupOperation</h2><p>联表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $lookup:&#123;</span></span><br><span class="line"><span class="comment">//         from:"user",</span></span><br><span class="line"><span class="comment">//         localField:"name",</span></span><br><span class="line"><span class="comment">//         foreignField:"username",</span></span><br><span class="line"><span class="comment">//         as:"userInfo"</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">LookupOperation lookupOperation1 = Aggregation.lookup(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"username"</span>, <span class="string">"userInfo"</span>);</span><br><span class="line"><span class="comment">// 还有一种方式，更直观</span></span><br><span class="line">LookupOperation lookupOperation2 = LookupOperation.newLookup()</span><br><span class="line">        .from(<span class="string">"user"</span>)</span><br><span class="line">        .localField(<span class="string">"name"</span>)</span><br><span class="line">        .foreignField(<span class="string">"username"</span>)</span><br><span class="line">        .as(<span class="string">"userInfo"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="4-SortOperation"><a href="#4-SortOperation" class="headerlink" title="4. SortOperation"></a>4. SortOperation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $sort:&#123;age: 1, grade: -1&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Sort sort = Sort.by(<span class="string">"age"</span>).and(Sort.by(<span class="string">"grade"</span>).descending());</span><br><span class="line">SortOperation sortOperation = Aggregation.sort(sort);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="5-LimitOperation"><a href="#5-LimitOperation" class="headerlink" title="5. LimitOperation"></a>5. LimitOperation</h3><p>取前 N 条</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $limit:10</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">LimitOperation limitOperation = Aggregation.limit(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="6-CountOperation"><a href="#6-CountOperation" class="headerlink" title="6. CountOperation"></a>6. CountOperation</h3><p>计数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $count:"countNum"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">CountOperation countNum = Aggregation.count().as(<span class="string">"countNum"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="7-UnwindOperation"><a href="#7-UnwindOperation" class="headerlink" title="7. UnwindOperation"></a>7. UnwindOperation</h3><p>拆分字段，常见于联表查询之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $lookup:&#123;</span></span><br><span class="line"><span class="comment">//         from:"user",</span></span><br><span class="line"><span class="comment">//         localField:"name",</span></span><br><span class="line"><span class="comment">//         foreignField:"username",</span></span><br><span class="line"><span class="comment">//         as:"userInfo"</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;,</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $unwind:"$userInfo"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">LookupOperation lookupOperation = Aggregation.lookup(<span class="string">"user"</span>, <span class="string">"name"</span>, <span class="string">"username"</span>, <span class="string">"userInfo"</span>);</span><br><span class="line">UnwindOperation unwindOperation = Aggregation.unwind(<span class="string">"userInfo"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="8-SkipOperation"><a href="#8-SkipOperation" class="headerlink" title="8. SkipOperation"></a>8. SkipOperation</h3><p>跳过前 N 条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $skip: 100</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">SkipOperation skipOperation = Aggregation.skip(<span class="number">100L</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="9-SampleOperation"><a href="#9-SampleOperation" class="headerlink" title="9. SampleOperation"></a>9. SampleOperation</h3><p>随机取样 N 条数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    $sample: 10</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">SampleOperation sampleOperation = Aggregation.sample(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="10-GroupOperation"><a href="#10-GroupOperation" class="headerlink" title="10. GroupOperation"></a>10. GroupOperation</h3><p>合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $group:&#123;</span></span><br><span class="line"><span class="comment">//         _id: "$appid",</span></span><br><span class="line"><span class="comment">//         list: &#123;$addToSet: "$account"&#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">GroupOperation groupOperation = Aggregation.group(<span class="string">"appid"</span>)</span><br><span class="line">        .addToSet(<span class="string">"account"</span>).as(<span class="string">"list"</span>);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="11-GraphLookupOperation"><a href="#11-GraphLookupOperation" class="headerlink" title="11. GraphLookupOperation"></a>11. GraphLookupOperation</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     $graphLookup:&#123;</span></span><br><span class="line"><span class="comment">//         from:"user",</span></span><br><span class="line"><span class="comment">//         startWith:"$parentId",</span></span><br><span class="line"><span class="comment">//         connectFromField:"parentId",</span></span><br><span class="line"><span class="comment">//         connectToField:"_id",</span></span><br><span class="line"><span class="comment">//         as:"fatherList"</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">GraphLookupOperation operation4 = Aggregation.graphLookup(<span class="string">"user"</span>).startWith(<span class="string">"parentId"</span>)</span><br><span class="line">        .connectFrom(<span class="string">"parentId"</span>).connectTo(<span class="string">"_id"</span>).as(<span class="string">"fatherList"</span>);</span><br></pre></td></tr></table></figure>

<br>

<p>这篇就先写到这里了。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>从 lock 到 AQS 再到 ReentrantLock</title>
    <url>/2020/04/05/Lock/</url>
    <content><![CDATA[<br>

<p>四月的第一周（实际上学习了两周有余），来学习另一种并发锁 Lock。</p>
<p>自 JDK 5 起，Java 类库中新提供了 java.util.concurrent 包（通常简称为 JUC 包），本周要学习的 Lock 接口，尤其是 ReentrantLock 类均出自该包当中。</p>
<hr>
<p>Java 中有两种对并发资源加锁的方式，除了上次写过的 synchronized 之外，还有本次要学习的 Lock。synchronized 是 JVM 通过底层实现的，是物理攻击，而 Lock 是通过 JDK 纯粹在软件层面上实现的，是魔法伤害，这周来学习魔法伤害。</p>
<br>

<p>Lock 类本身是一个接口，对锁进行了规范，Lock 接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock 接口一共规范给定了 6 个方法。</p>
<br>

<p>其中最为常用的，是 <code>lock()</code> 方法和 <code>unlock()</code> 方法，这两个方法必须成对出现，否则就有可能出现异常，使用逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如已经创建了一个lock对象</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用 lock 上锁，与使用 synchronized 上锁的效果是相同的，但在使用上从大括号代码块变为 try 代码块，并且一定要使用 finally 语句为 lock 对象解锁。</p>
<p>阿里巴巴的 Java 代码规约中指出：</p>
<blockquote>
<p>锁【lock.lock】必须紧跟try代码块，且unlock要放到finally第一行。</p>
<p>……</p>
<p>说明一：如果在lock方法与try代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。<br>说明二：如果lock方法在try代码块之内，可能由于其它方法抛出异常，导致在finally代码块中，unlock对未加锁的对象解锁，它会调用AQS的tryRelease方法（取决于具体实现类），抛出IllegalMonitorStateException异常。<br>说明三：在Lock对象的lock方法实现中可能抛出unchecked异常，产生的后果与说明二相同。</p>
</blockquote>
<p>已经说得非常清晰了。</p>
<br>

<p>Lock 接口规定了四种上锁，除了上文说到的最传统的 <code>lock()</code> 方法之外，还有以下三种：</p>
<ul>
<li><code>lockInterruptibly()</code> 会处理线程中断的上锁</li>
<li><code>tryLock()</code> 尝试上锁并立即返回，上锁成功则 true，上锁失败则 false</li>
<li><code>tryLock(long time, TimeUnit unit)</code> 尝试一段时间上锁后返回，上锁成功则 true，上锁失败则 false</li>
</ul>
<p>除以上上锁方法之外，最后还有一个方法 <code>newCondition()</code>，该方法用于协调线程，这个后面再提。</p>
<hr>
<p>写到这里，必须来补充学习两点其他的内容：线程中断、AQS，这两点是接下来要学习的基础。</p>
<h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><p>去年写过一篇文章学习线程，但基本只局限在线程的创建上，对线程的使用逻辑仍是知之甚少。这次学习 Lock 锁需要简单学习下线程的状态，以及线程中断的逻辑。</p>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/Thread.State.html" target="_blank" rel="noopener">通常意义上</a>线程有六种状态，但依我来看线程实际上只有两种状态：可运行状态、不可运行状态。</p>
<ul>
<li>可运行状态：线程可以运行，但是并不一定正在运行，细分的话可以分为<code>正在运行</code>和<code>等待运行</code>两种状态。</li>
<li>不可运行状态：线程不能运行，可能是主动的（主动等待），也可能是被动的（要用的资源被锁住了）。细分的话能分为三种状态：无限期等待状态、限期等待状态、阻塞状态，前两种是线程自己发起的，第三种是线程被迫的。</li>
</ul>
<p>（下图主要参考《<a href="https://www.zhihu.com/question/56494969/answer/154053599" target="_blank" rel="noopener">Java 线程运行怎么有第六种状态？》</a>、<a href="https://www.uml-diagrams.org/examples/java-6-thread-state-machine-diagram-example.html" target="_blank" rel="noopener">《Java 6 Thread States and Life Cycle》</a>）</p>
<p><img src="/assets/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt="线程状态"></p>
<p>对各个状态分别进行解释：</p>
<ul>
<li><p><code>New</code> 新增：线程刚刚创建（例如 <code>Thread t = new Thread()</code>），还没有执行代码</p>
</li>
<li><p><code>Runnable</code> 可运行：线程可以运行（例如 <code>thread.start()</code>），但并不代表一定在运行，是否正在运行要看虚拟机和 CPU 的线程调度情况。</p>
<p>CPU 将时间划分为 10-20 ms 的一个个时间片，在每一个时间片中执行一条线程，到时间就切换（切换地太快导致似乎在并行执行多条线程），这被称为 CPU 在调度线程。在 <code>Runnable</code> 状态下，每一条线程都有可能会被执行，但是执行和切换的速度都很快，非要分出来是在执行还是在等待并没有太大的意义。</p>
<ul>
<li><code>Ready</code> 等待运行：等待 CPU 调度</li>
<li><code>Running</code> 正在运行：CPU 正在执行</li>
</ul>
</li>
<li><p><code>Waiting</code> 无限期等待：线程主动等待，并且不设置等待结束的时间，直到被其他线程“唤醒”（例如 <code>thread.join()</code>）。</p>
</li>
<li><p><code>Timed Waiting</code> 限期等待：线程主动等待，但是设置一个等待的时长，到时间就自动唤醒（例如 <code>thread.sleep(sleepTime)</code>），在等待的这段时间也可以被其他线程“唤醒”。</p>
</li>
<li><p><code>Blocked</code> 阻塞等待：线程被动等待，因为抢锁失败了，被迫等着（例如使用 synchronized 同时让多条线程获取资源，总有线程会被迫等待）。</p>
</li>
</ul>
<br>

<p>有关线程状态还可以剖析地更深一些：</p>
<ul>
<li>Java 的 Thread 类看似是一个寻常的 Java 对象，实际上可以视为对底层系统操作线程的封装，因此使用 Thread 类时不能完全按照面向对象的常规思维来思考，而是要以底层硬件的实现逻辑来思考。</li>
<li>上文我将线程分为了可运行状态和不可运行状态，细分析的话，这实际上是指 CPU 有没有为线程分配时间片。在另外的地方（线程和进程的区别）学习到，线程是操作系统能够调度的最小单位，“能调度的最小单位“这种说法，就是指 CPU 划分出一个个时间片，每一个时间片”调度“一个线程。可运行状态指的是 CPU 能够调度线程，而不可运行状态指的是 CPU 不能调度线程，比如某一个线程中执行 <code>Thread.sleep(sleepTime)</code> 方法，那么这个线程进入 <code>Timed Waiting</code> 状态，在这种状态下 CPU 不再调度该线程，直到该线程休眠时间结束，回到 <code>Runnable</code> 状态，CPU 才可以调度该线程，这个行为被称作线程的“挂起”。</li>
<li>线程通过 <code>sleep(time)</code> 和 <code>wait(time)</code> 方法都可以进入 <code>Timed Waiting</code> 状态，CPU 都不再会调度该线程，但是 sleep 的一方不会释放锁，wait 的一方会释放锁。其他线程如果需要正在 sleep 的线程的资源，将一直阻塞到那个线程醒来再释放资源。</li>
<li>只有使用 synchronized 才能导致线程进入 <code>Blocked</code> 状态，线程从 <code>Waiting</code> 状态无法直接进入 <code>Runnable</code> 状态，只能先进入 <code>Blocked</code> 状态去获取锁。（顺便一提，进入 <code>Waiting</code> 状态的 wait()、notify()、notifyAll() 方法，只能在 synchronized 代码块中使用）</li>
</ul>
<br>

<p>我们终于要写到中断了。</p>
<p>线程中断，这里的“中断”是一个颇有迷惑性的词语，它并不是指线程就此停止，而是指线程收到了一个“中断信号”，线程应该根据这个信号来自行了断一些事情（但是收到中断信号也可以不处理）。</p>
<p>比如，线程 1 向线程 2 发送了一条中断信息，线程 2 的中断状态发生了改变，线程 2 根据中断状态来进行逻辑处理。所以我认为，中断是线程间通信的一种方式，通信的内容是“建议另一条线程停止行为”，但是线程并不一定采取意见，即使采取意见也绝不是终止线程，而是停止某个一直重复运行的行为，继续执行后续的代码。</p>
<p>我目前所见，中断有两种使用场景：</p>
<ol>
<li><p>线程根据中断状态，停止某个循环（例如下面这段伪代码）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(还没中断)&#123;</span><br><span class="line">    循环执行</span><br><span class="line">&#125;</span><br><span class="line">中断了，进行后续操作</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程，但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 当前线程休眠1秒</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 线程中断，不让继续休眠了，处理后续的业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的用法是，当线程处于不可运行状态时（暂停 CPU 调度），以异常的形式，强制让线程处理中断，以恢复回到可运行状态（CPU 可调度）。虽然这是在处理异常，但实际上并不是指程序有什么错误，而是代表一种强制手段：必须要对中断进行处理。再换句话说，这是一种恢复线程状态，停止发呆的一种机制。</p>
</li>
</ol>
<p>线程中断有三个相关方法：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>public void interrupt()</td>
<td>中断线程</td>
</tr>
<tr>
<td>public boolean isInterrupted()</td>
<td>查看线程是否中断</td>
</tr>
<tr>
<td>public static boolean interrupted()</td>
<td>静态方法，查看当前线程是否中断的同时，清除中断状态<br>即如果线程中断，执行之后将不再处于中断状态</td>
</tr>
</tbody></table>
<p>中断的源码，以及阻塞状态下的线程抛出中断异常的原理，这里暂不考究了。在此只掌握到两点即可：</p>
<ol>
<li>线程中断不代表线程活动终止</li>
<li>线程中断的基本原理，是给线程的中断标志位赋 true</li>
</ol>
<br>

<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>AQS 可以算是 JUC 包的核心，一大片并发类，包括本周要学习的 ReentrantLock 锁，都是以 AQS 为内核，不了解 AQS 则无法继续学习。</p>
<p>AQS 的全称是 AbstractQueuedSynchronizer（抽象队列同步器，中文一般简称“队列同步器”），它的作用正如其名，是一个队列，需要同步的线程们在队列里排队，每次让一个线程占用资源，剩下的线程在队列同步器里待命。这样的设计实现了这种效果：当多个线程争抢资源时，保证只会有一条线程在运行，其他线程都在等待队列里等候安排。</p>
<p>打开 AQS 接口看源码，会看到多如牛毛的方法，初识 AQS 如果从这些方法着手，就可以准备去世了，因此我们从 AQS 的成员变量着手，对 AQS 进行猜测性学习。</p>
<p>以下代码部分，基本全部参考自<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">《一行一行源码分析清楚 AbstractQueuedSynchronizer》</a>，这篇博文写的真的非常好，学习 AQS 必看（主要也是因为 AQS 的代码太神奇了，自己看完全看不懂……Doug Lea 这老爷子我服了）。</p>
<br>

<p>AQS 重要的成员变量有四个，分别是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头结点，你直接把它当做【当前持有锁的线程】可能是最好理解的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span></span><br><span class="line"><span class="comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代表当前持有独占锁的线程（该变量继承自父类），举个最重要的使用例子</span></span><br><span class="line"><span class="comment">// 因为锁可以重入，reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span></span><br><span class="line"><span class="comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>

<p>AQS 接口中定义了一个内部类：Node，这个类是 AQS 队列的基本构成元素，即并发线程们在 AQS 队列里等候时，都是装在这个 Node 对象里排序的。Node 类源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标识节点当前在共享模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">// 标识节点当前在独占模式下</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span></span><br><span class="line">    <span class="comment">// 代表此线程取消了争抢这个锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本文不分析condition</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 同样的不分析，略过吧</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// =====================================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span></span><br><span class="line">    <span class="comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span></span><br><span class="line">    <span class="comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 前驱节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 后继节点的引用</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 这个就是线程本尊</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Node 类的代码容易看得人一头雾水，初学时应当将其视为一个普通的链表节点，它必须需要</p>
<ul>
<li>Node prev：指向前个节点</li>
<li>Node next：指向后个节点</li>
<li>Thread Thread：本节点需要存储的内容</li>
</ul>
<p>除此之外该节点还有一个状态位：</p>
<ul>
<li>int waitStatus：节点状态，在之后的代码中很重要</li>
</ul>
<p>Node 类定义的其他内容不用太过纠结，看之后的代码会懂。</p>
<p>根据学习这个类，以及参考学习其他 AQS 相关的博文，可以大概知道 AQS 队列的基本结构和设计逻辑是这样的：</p>
<p><img src="/assets/AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="AQS数据结构"></p>
<p>看图应该就能明白 AQS 的数据结构，需要注意的是，head 并不在 AQS 的阻塞队列当中。</p>
<br>

<p>以下部分是 AQS 的源码分析，同样基本参考自<a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">《一行一行源码分析清楚 AbstractQueuedSynchronizer》</a>这篇文章，这部分的内容很难，可以不看，不会影响到 Lock 接口的学习。</p>
<p>之前的代码中说过，使用 Lock 接口上锁的基本步骤是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();		--&gt; AQS#acquire()</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();	--&gt; AQS#release()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，lock() 和 unlock() 方法的原理，是使用 AQS 的 acquire() 和 release() 方法实现的，因此我们来粗略地学习这两个方法，并大致了解 AQS 的原理。（以下代码说明均为简略版，查看详细代码说明请参见上述博文）</p>
<ol>
<li><p>上锁（新线程加入队列）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">                                       <span class="comment">// 如果是首次进入队列的节点，那么尝试获取锁</span></span><br><span class="line">                                       <span class="comment">// 如果不是首次进入队列，那么调整一下队列（之前的节点可能超时退出了）</span></span><br><span class="line">         <span class="comment">/* 先尝试获取一次锁 */</span>           ┌-----------------------------------------------------┐</span><br><span class="line">         <span class="comment">/* 如果能拿到，就不用排队了 */</span>    |                 <span class="comment">/* 把线程包装成node，并加入阻塞队列 */</span>   |</span><br><span class="line">         ┌----------------------┐      |                ┌---------------------------┐        |</span><br><span class="line">    <span class="keyword">if</span> ( |   !tryAcquire(arg)   |  &amp;&amp;  | acquireQueued( | addWaiter(Node.EXCLUSIVE) |, arg)) |</span><br><span class="line">         └----------------------┘      |                └---------------------------┘        |</span><br><span class="line">                                       └-----------------------------------------------------┘</span><br><span class="line">        <span class="comment">// 线程已经进入队列了</span></span><br><span class="line">        <span class="comment">// 阻塞线程，耐心等吧</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>解锁（老线程执行完毕，传唤下一个线程）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放线程</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>AQS 的具体实现代码，我自认为是又长又难的，因此不把全部代码整理出来了，只在此记录一些点吧：</p>
<ul>
<li>AQS 中有大量的方法，是为了处理并发的，例如队列还是空的，同时有两个线程进来申请锁，如何来让一个线程拿到锁，另一个线程去队列里排队等候。AQS 解决并发问题的原理是 CAS（CAS 的原理去看上篇介绍 synchronized 的博文），AQS 去调用 JDK5 刚刚出现的 sun.misc.Unsafe 类里面的方法，这个类对 CPU 的 CAS 指令进行了封装。</li>
<li>进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。当占用锁的线程结束，调用 unlock() 方法，此时 AQS 会去队列里唤醒排在最前面的节点线程。</li>
<li>AQS 接口确定了队列同步的主要逻辑，也就是上锁时线程先尝试获取锁，失败则加入队列；解锁时队列先尝试解除锁，如果解锁成功则唤醒后继节点。但是<code>尝试获取锁</code>和<code>尝试解除锁</code>这两个操作，都是交由子类去实现的。这就使得 AQS 框架确立了基础的并发队列机制，但锁的形式可以有各种不同。实际上每个锁（每个 AQS 接口的实现类）就是在重写 AQS 的 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，其他的都依赖于 AQS 接口代码。</li>
<li>AQS 有两个很重要的变量，分别是队列的状态 state，以及队列节点的状态 waitStatus。<ul>
<li>state：0 代表锁没有被占用，1 代表有线程正在占用锁，1 往上代表有线程正在重入占用锁</li>
<li>waitStatus：0 代表初始化，大于 0 代表该节点取消了等待，-1 代表后继节点需要被唤醒</li>
</ul>
</li>
</ul>
<p>先写到这里吧。</p>
<br>

<hr>
<p>接下来首先学习最常用的锁：ReentrantLock。</p>
<p>ReentrantLock 的字面意义是可重入锁，代表线程可以多次执行 lock() 方法占有锁，不会导致死锁问题。</p>
<p>ReentrantLock  允许公平锁，只要在构造方法中传入 true（<code>new ReentrantLock(true)</code>）即可。公平锁的意思是，当多个线程获取锁时，按照先来后到的顺序，先申请锁的线程一定先得到锁，后申请锁的线程一定后得到锁。如果是非公平锁，那么各个线程获取到锁的顺序是“随机”的。对于 ReentrantLock 的非公平锁而言，后到的线程可以先试着获取一次锁，获取到了就直接返回，获取不到就跟公平锁一样在后面排队。ReentrantLock 实现公平锁和非公平锁的方式，是在内部维护两种 AQS 队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁（Sync是一个AQS队列）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 公平锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>经过刚才对 AQS 的学习，我们知道学习锁实际上只需要看 <code>tryAcquire()</code> 和 <code>tryRelease()</code> 方法，其他都交由 AQS 接口就可以了。</p>
<ol>
<li><p>上锁 <code>tryAcquire()</code></p>
<ul>
<li><p>公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class="line"><span class="comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// state == 0 此时此刻没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class="line">        <span class="comment">// 看看有没有别人在队列中等了半天了</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class="line">            <span class="comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span></span><br><span class="line">            <span class="comment">// 因为刚刚还没人的，我判断过了</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class="line">    <span class="comment">// 这里不存在并发问题</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class="line">    <span class="comment">// 回到上面一个外层调用方法（AQS的acquire()方法）继续看:</span></span><br><span class="line">    <span class="comment">// if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class="line">    <span class="comment">//     selfInterrupt();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>非公平锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了nonfairTryAcquire()方法，往下看</span></span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 与公平锁相比，只有这里有区别</span></span><br><span class="line">        <span class="comment">// 非公平锁不会先判断AQS队列中是否有等候的节点，而是直接试着获取一次锁</span></span><br><span class="line">        <span class="comment">// 如果这次尝试获取不到，则和公平锁一样尾插队列</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>公平锁和非公平锁只有两点区别：</p>
<ol>
<li><p>非公平锁实际上会先 CAS 获取一次锁，如果失败则调用 AQS 的 acquire() 方法（这段上面没提）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非公平锁的lock()方法（会先CAS获取一次锁，获取不到再走AQS接口）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平锁的lock()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在首次试着获取锁失败的情况下，非公平锁会在 tryAcquire() 方法中再试着获取一次锁，但是公平锁会严格地按照先来后到的顺序获取</p>
</li>
</ol>
<p>可以总结出来，非公平锁比公平锁多尝试获取了两次锁，如果成功就不用进入队列了。这样可以提高并发的线程吞吐量，但是有可能导致先等待的线程一直获取不到锁。</p>
</li>
<li><p>解锁 <code>tryRelease()</code></p>
<p>公平锁和非公平锁，共用一套解锁方法，也就是 <code>Lock#unlock() -&gt; AQS#release() -&gt; Lock#tryRelease() -&gt; AQS#unparkSuccessor()</code>，其中 tryRelease() 方法是交由实现类 ReentrantLock 去重写的（不明白的话回到上面看一看 AQS 的解锁逻辑）。ReentrantLock 重写的 tryRelease() 方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 是否完全释放锁</span></span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 处理重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 作为可重入锁，每次上锁就使 AQS 队列的状态（初始化是 0）增加 1，解锁使状态减少 1，如果 AQS 队列的状态变为 0 了，就代表没有线程持有锁。</p>
</li>
</ol>
<br>

<hr>
<p>学习得越深入，越感觉锁是一个无底洞，至少还需要再学习 ReentrantReadWriteLock、Semaphore、CountDownLatch、CyclicBarrier、Condition 等内容，本篇承载不了那么多，暂时先写到这里。后续的内容容我先消化一段时间，然后再回来补上。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC 原理</title>
    <url>/2020/10/30/Spring-MVC-%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<br>

<p>十月的尾巴赶出来一篇吧，这周学习 Spring MVC 的原理。</p>
<p>十月份是放松的一个月，国庆出游，节后迎接朋友，还没怎么学习就过去了，回到生活的常态了，认真学习。</p>
<hr>
<p>我一直不太清楚 Spring 官方文档的结构和入口，比如，似乎根本就不存在 Spring MVC 这个模块，它被包含在 Spring Web Flow 或是 Web on Servlet Stack 的模块中，而且这两个模块我也搞不懂是什么关系。</p>
<p>我大致梳理出来这么一个逻辑：Spring MVC 并不在 Spring 的顶层结构中，Spring Web 才是顶层的设计，Spring MVC 只是 Web 中的一种解决方案，如果不用它，还可以使用 Struts 等其他的网络应用框架（但是现在大家都在使用 Spring MVC）。这种逻辑跟 Spring 的设计调性有关，它们希望做得更开放包容一些。</p>
<p>我在去年刚入行时学习 Spring 全家桶，就反复看到这张奇丑无比的图（为什么行业的审美这么低……）：</p>
<p><img src="/assets/SpringMVC%E4%B8%91%E5%9B%BE.JPG" alt="SpringMVC丑图"></p>
<p>当时连 Java 的语法都写得不利索，按照这个学习更是像趟沼泽似的一脚深一脚浅。如今回来看就豁然开朗了很多。</p>
<p>Spring MVC 的核心中转站是 DispatcherServlet，网络请求的接收、执行、渲染视图、返回等，它跟 Spring 接触的全过程，都发生在这个类当中。这篇文章说是学习 Spring MVC 的原理，其实也只是学习这个 DispatcherServlet 类。</p>
<p>在学习这部分时，发现了写得非常好的博客，记录一下：《<a href="https://blog.csdn.net/andy_zhang2007/category_9285198.html" target="_blank" rel="noopener">安迪源文-专栏-Spring MVC 分析</a>》。</p>
<hr>
<p>dispatcher 的意思是调度员，因此 DispatcherServlet 类是一个用于调度、中转的类，这是 Spring MVC 的前端控制器。它调用了很多个方法，把一个请求从接收到返回的所有方法逐个执行完毕，这中间一共有 5 个步骤，下面一个个步骤过。</p>
<p>以下分析基于 spring-webmvc-5.2.9.RELEASE 版本。</p>
<h1 id="1-进入-DispatcherServlet-之前"><a href="#1-进入-DispatcherServlet-之前" class="headerlink" title="-1. 进入 DispatcherServlet 之前"></a>-1. 进入 DispatcherServlet 之前</h1><p>Spring MVC 的底层使用的是 Tomcat。一个 HTTP 请求，将首先到达 Tomcat，再又 Tomcat 转发给 Spring MVC 去处理。</p>
<p>一个 HTTP 请求根据 Java EE 的网络协议，将首先进入到 Servlet 接口中，就是 Tomcat，Tomcat 将这个请求处理后，封装出两个对象：<code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>，最终交付给 Spring MVC，进入到 DispatcherServlet 类中。</p>
<p>进入 DispatcherServlet 类之前的动作，需要理解网络通信和 Tomcat 的设计，这部分暂且忽略，以后再学习。</p>
<p>最终我们进入到 DispatcherServlet 类中，调用 <code>doDispatch(...)</code> 方法，这个方法有两个参数，分别是 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>。</p>
<h1 id="0-DispatcherServlet-类"><a href="#0-DispatcherServlet-类" class="headerlink" title="0. DispatcherServlet 类"></a>0. DispatcherServlet 类</h1><p>任何 Spring MVC 的教程帖，包括官方文档，都会重点说 DispatcherServlet 类。它被称为 Spring MVC 的前端控制器，这是因为它是所有 HTTP 请求的总中转站。这个类在 JavaDoc 中是这么描述的：</p>
<blockquote>
<p>Central dispatcher for HTTP request handlers/controllers……</p>
</blockquote>
<p>我们这篇只关注 DispatcherServlet 类的一个方法：<code>doDispatch(...)</code>。</p>
<p>Spring 框架接到 HTTP 请求后，将会执行 DispatcherServlet 类的 <code>doDispatch(...)</code> 方法，用来做分发（dispatch）。后端 Java 应用有那么多的接口，这个 HTTP 请求到底是访问哪一个接口，得找出来，并且得执行这个接口，分发就是指找到并执行这个接口（把这个请求分发出去）。</p>
<p>Spring MVC 把处理请求的对象称为 <code>handler</code>，与之相关的概念还有 <code>HandlerExecutionChain</code> 和 <code>HandlerAdapter</code>，它们都跟 <code>handler</code> 有关，下文讲到了再说。</p>
<p><code>doDispatch(...)</code> 方法按顺序做了这些事情：</p>
<ol>
<li>找出 handler</li>
<li>找出负责执行 handler 的 handlerAdapter</li>
<li>处理缓存</li>
<li>执行 handler</li>
<li>渲染视图结果</li>
</ol>
<p>首先将这部分代码贴在下面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异步请求的 manager</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// handler 处理的结果</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否是上传文件的请求，如果是，转换 request</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            <span class="comment">// boolean 变量：是否是上传文件的请求（request 有没有发生过转换）</span></span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ① 找出能处理该请求的 handler —————————— */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">// 如果没找到 handler，response 返回 404 异常（在 noHandlerFound(...) 方法中）</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ② 获取 HandlerAdapter，用以执行 handler —————————— */</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ③ 处理缓存（允许的话可以直接返回） —————————— */</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="comment">// 默认情况下 lastModified 是 -1</span></span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="comment">// 由于 lastModified 是 -1，checkNotModified(...) 方法什么都没做，最后返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ④ handler 开始处理请求 —————————— */</span></span><br><span class="line">            <span class="comment">// 前置拦截</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行 handler，获取结果 modelAndView</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是异步请求，直接返回，response 将一直保持打开状态</span></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 modelAndView 不为空，但 view 为空时，根据 request 设置默认的 view</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后置拦截</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* —————————— ⑤ 解析、渲染 mv（或者是异常） —————————— */</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-找出能处理该请求的-handler"><a href="#1-找出能处理该请求的-handler" class="headerlink" title="1. 找出能处理该请求的 handler"></a>1. 找出能处理该请求的 handler</h1><p>（省略了一些声明变量、检查上传文件的代码）</p>
<p><code>doDispatch(...)</code> 方法做的第一件事，是找到请求要分发到哪个接口上。</p>
<p>Spring MVC 将处理用户请求的接口叫做 handler，它可能是程序员开发的 Controller 方法，也有可能是框架自动配置出的某个方法。</p>
<p>我们首先需要找到这个方法，也就是找到 handler，这一步是执行 <code>getHandler(...)</code> 方法。如果没有找到这个方法，那么就可以直接返回 404 了，返回 404 的过程是在执行 <code>noHandlerFound(...)</code> 方法。这里很简单，直接看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————— ① 找出能处理该请求的 handler —————————— */</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="comment">// 如果没找到 handler，response 返回 404 异常（在 noHandlerFound(...) 方法中）</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这第一步可以拆成两个部分，怎么找到 handler 的，以及如果找不到是怎么返回 404 的。</p>
<ol>
<li><p><code>getHandler(...)</code> 方法</p>
<p>首先寻找 handler，从 handlerMappings 中进行遍历寻找能够匹配的 handler，如果找不到就返回 null。</p>
<p>handlerMappings 是一个 <code>List&lt;HandlerMapping&gt;</code>，它在首个请求进来时进行初始化，把所有的 handler 都包装起来加入到一个 List 中，之后每当有请求进来就遍历这个 List，逐个匹配。如果匹配上了，就通过这个 handlerMapping 获取 handler。</p>
<p>需要注意的是，这里获取到的 handler 的类型，实际上是 HandlerExecutionChain，它在 handler 的基础上增加了若干个 interceptor（拦截器），可以实现类似 AOP 的效果。有关这个类的设计，我们在最后面详述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// handlerMappings：</span></span><br><span class="line">    <span class="comment">// 这是一个 List&lt;HandlerMapping&gt;，装着所有的 handler，应用启动的时候进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 handlerMappings</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了合适的 handler，包装成 HandlerExecutionChain 对象</span></span><br><span class="line">            <span class="comment">// HandlerExecutionChain 除了包含 handler 外，还包含拦截器（HandlerInterceptor 列表）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// mapping.getHandler(...) 这个方法比较深，主要做了这几件事：</span></span><br><span class="line">            <span class="comment">//  1. 获取 url</span></span><br><span class="line">            <span class="comment">//  2. 通过 RequestCondition 的设计，比对接口参数（如路径、头部信息、请求参数等）</span></span><br><span class="line">            <span class="comment">//  3. 比对参数找到 handler 后，将 handler 转换成 HandlerExecutionChain 对象</span></span><br><span class="line">            HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handlerMappings 的初始化是在 DispatcherServlet 的 <code>initHandlerMappings(...)</code> 方法内完成的，在默认情况下，会从容器（以及祖先容器）获取所有类型为 <code>HandlerMapping</code> 的 <code>bean</code> 组件，记录到 <code>handlerMappings</code> 并排序。这个过程可以参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/87694206" target="_blank" rel="noopener">Spring MVC DispatcherServlet 策略初始化 – initHandlerMappings</a>》</p>
</li>
<li><p><code>noHandlerFound(...)</code> 方法</p>
<p>（按照常理来想）如果没有对应的接口，寻找 handler 时会找不到，从而进入到 <code>noHandlerFound(...)</code> 方法，返回 404 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">noHandlerFound</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pageNotFoundLogger.isWarnEnabled()) &#123;</span><br><span class="line">        pageNotFoundLogger.warn(<span class="string">"No mapping for "</span> + request.getMethod() + <span class="string">" "</span> + getRequestUri(request));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.throwExceptionIfNoHandlerFound) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoHandlerFoundException(request.getMethod(), getRequestUri(request), <span class="keyword">new</span> ServletServerHttpRequest(request).getHeaders());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是 404</span></span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是神奇的是，Spring MVC 提供了一个 handler，它的路径匹配是 <code>\**</code>，也就是对所有路径都匹配，因而每次有请求进来，都可以找到 handler，不会出现 handler 为 null 的情况，也就不会进入到 <code>noHandlerFound(...)</code> 方法中。它会在更晚的地方，handler 开始处理接口的时候去处理，最终返回 404。</p>
<p>这种情况我还不是很确定，但并不关乎核心内容，因此暂且放过了。</p>
</li>
</ol>
<h1 id="2-找出负责执行-handler-的-handlerAdapter"><a href="#2-找出负责执行-handler-的-handlerAdapter" class="headerlink" title="2. 找出负责执行 handler 的 handlerAdapter"></a>2. 找出负责执行 handler 的 handlerAdapter</h1><p>获取 handler 之后并不是直接执行它的，负责执行 handler 的类是 HandlerAdapter，也就是说一个请求的真正执行，是由 HandlerAdapter 来处理的。这是单一职责原则的体现，有关这个类的具体设计见本文最后。</p>
<p>获取 handlerAdapter 只要一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————— ② 获取 HandlerAdapter，用以执行 handler —————————— */</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>

<p>跟进去看 <code>getHandlerAdapter(...)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="comment">// 自己写的接口，默认的 handlerAdapter 是 RequestMappingHandlerAdapter</span></span><br><span class="line">            <span class="comment">// 这个类对 @RequestMapping 的方法提供支持</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认情况下是不可能的，只要不瞎改源码瞎扩展</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler + <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也比较简单，遍历 handlerAdapters，找到合适的 handlerAdapter。</p>
<p>对于自己在 Controller 中写的接口（使用 @RequestMapping 注解的方法），默认的 handlerAdapter 是 RequestMappingHandlerAdapter 的实现类。</p>
<p>要遍历的 handlerAdapters 是 DispatcherServlet 的一个成员变量，它跟 handlerMappings 一样，都是在第一个请求进来时进行加载，加载的方法是 <code>initHandlerAdapters(...)</code>。</p>
<h1 id="3-处理缓存"><a href="#3-处理缓存" class="headerlink" title="3. 处理缓存"></a>3. 处理缓存</h1><p>第三步是处理缓存相关的事情，这一部分主要跟 HTTP 的 304 状态码相关，先贴代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————— ③ 处理缓存（允许的话可以直接返回） —————————— */</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">    <span class="comment">// 默认情况下 lastModified 是 -1</span></span><br><span class="line">    <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">// 由于 lastModified 是 -1，checkNotModified(...) 方法什么都没做，最后返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的实现，这里什么都没做，也就是说默认情况下，自己写的接口是不会使用缓存机制的。</p>
<p>关于 HTTP 的 304 状态码，last-modified 的含义，HTTP 缓存的概念，可以参考这篇文章《<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP 缓存</a>》。</p>
<h1 id="4-执行-handler"><a href="#4-执行-handler" class="headerlink" title="4. 执行 handler"></a>4. 执行 handler</h1><p>在 DispatcherServlet 中，执行 handler 分五步走</p>
<ol>
<li>前置拦截</li>
<li>执行 handler</li>
<li>考虑处理异步请求</li>
<li>考虑设置默认 view</li>
<li>后置拦截</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————— ④ handler 开始处理请求 —————————— */</span></span><br><span class="line"><span class="comment">// 前置拦截</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 handler，获取结果 modelAndView</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是异步请求，直接返回，response 将一直保持打开状态</span></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 modelAndView 不为空，但 view 为空时，根据 request 设置默认的 view</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置拦截</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>前置拦截</p>
<p>前文有说过，真正执行 handler 的是 handleAdapter，这个类是在 handler 的基础上增加了若干个 interceptor，起到前后拦截的作用。第一步，就是遍历 interceptors 进行前置拦截，来看 <code>mappedHandler.applyPreHandle(processedRequest, response)</code> 这行代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 interceptors 是否不为空</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 interceptors</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 让每个 interceptor 执行 preHandle(...) 方法，执行前置拦截方法</span></span><br><span class="line">            <span class="comment">// 具体前置拦截执行内容，由 interceptor 自己定义</span></span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 只有在 preHandle(...) 方法返回 false 的情况下才会执行下面（也就是说前置拦截中途失败了）</span></span><br><span class="line">                <span class="comment">// 这个方法会执行 interceptor 的 afterCompletion(...) 方法，然后请求直接返回</span></span><br><span class="line">                <span class="comment">// 意思是如果前置执行失败了，那么 handler 就不执行了，处理完一些操作请求就直接返回了</span></span><br><span class="line">                triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 handler</p>
<p>处理完前置拦截的 interceptor 们之后，就可以正式执行 handler 了，对应于我们自己的业务代码，就是去执行 <code>@RequestMapping</code> 注解的 Controller 方法。</p>
<p>执行 Controller 方式是通过反射实现的，步骤很深，就不细研究了。主要的思路是，从 handler 中获取 handlerMethod（也就是 Controller 方法），从 request 中获取接口参数，然后使用反射调用方法，获取结果，包装进 response 里。具体的执行细节可以去看 <code>RequestMappingHandlerAdapter</code> 类中的 <code>invokeHandlerMethod(...)</code> 方法。</p>
<p>执行 handle 方法，接口返回的是 ModelAndView，这是 MVC 中的 M（Model）和 V（View），但是对于我们自己编写 Controller 方法而言（使用 RestController），handle 方法返回的 ModelAndView 是 null，因为并没有必要返回视图，结果直接被封装进 response 里了。这里涉及到 HTTP 协议和返回体相关的知识，以后再补吧（怎么这么多要补的……）</p>
</li>
<li><p>考虑处理异步请求</p>
<p>如果请求是异步的，那么可以提前返回，之后再异步传回请求结果。</p>
<p>判断请求是否异步的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConcurrentHandlingStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.asyncWebRequest.isAsyncStarted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑设置默认 view</p>
<p>如果  ModelAndView 对象不为 null，但是对象内部的 view 部分是空的，那么考虑设置默认的 view。</p>
<p>这个方法并没有执行，因为 ModelAndView 对象此时是 null，方法直接就返回了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyDefaultViewName</span><span class="params">(HttpServletRequest request, @Nullable ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 ModelAndView 对象不为空，但是 view 为空，那么考虑设置默认的 view</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">        String defaultViewName = getDefaultViewName(request);</span><br><span class="line">        <span class="keyword">if</span> (defaultViewName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mv.setViewName(defaultViewName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后置拦截</p>
<p>跟前置拦截的过程差不多，但是这次是从后往前遍历执行拦截方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 interceptors 不为空</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="comment">// 从后往前遍历每个 interceptor</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="comment">// 执行每个 interceptor 的 postHandle(...) 方法</span></span><br><span class="line">            interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="5-渲染视图结果"><a href="#5-渲染视图结果" class="headerlink" title="5. 渲染视图结果"></a>5. 渲染视图结果</h1><p>执行到这里时（<code>processDispatchResult(...)</code> 方法），有三种可能：</p>
<ol>
<li><p>执行正常，且不需要 ModelAndView（RestController 直接返回了 JSON/XML 数据）</p>
<p><code>processDispatchResult(...)</code> 什么都没执行，逛一圈就返回了。</p>
</li>
<li><p>执行正常，且需要 ModelAndView</p>
<p>将 ModelAndView 渲染进 response 里（也就是渲染视图结果）</p>
</li>
<li><p>执行异常</p>
<p>将异常转换为 ModelAndView 对象（转换成视图对象），然后渲染进 response 里（如果转换不了就再抛出去异常）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果执行 handler 发生了异常，将 mv 转换为异常情况下的 mv</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ModelAndViewDefiningException 类型的异常，可以直接获取 mv</span></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是其他异常，需要找一个 HandlerExceptionResolver 处理异常获取 mv</span></span><br><span class="line">        <span class="comment">// 也有可能这里也处理不了，那就再抛异常出去</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析、渲染 mv</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// render：渲染</span></span><br><span class="line">        <span class="comment">// 将 mv 解析渲染进 response 中</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"No view rendering, null ModelAndView returned."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步并发相关，不懂，略</span></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理每个 interceptor 的完成拦截逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个方法在第四步处理 handler 的第一步前置拦截时看到过，如果前置拦截发生了异常，就会执行这个方法，然后直接返回</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>doDispatch(...)</code> 方法的五步就都看完了。</p>
<hr>
<p>Spring MVC 设计了很多接口类，将各自的职责摘得很干净，这里学习其中几个类的设计。</p>
<h1 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h1><p><code>doDispatch(...)</code> 方法在第一步获取的 handler，它的类型是 HandlerExecutionChain。这个类在 handler 的基础上，还有若干个 HandlerInterceptor 对象，在 handler 执行的前后起到拦截的效果。</p>
<p>HandlerExecutionChain 的内部有两部分：</p>
<ul>
<li>handler：实际执行请求方法</li>
<li>interceptors：在 handler 的前后做拦截方法，起到类似 AOP 的效果</li>
</ul>
<p>官方在 Javadoc 中对 HandlerExecutionChain 的描述有这么一句，可以感受一下：</p>
<blockquote>
<p>a handler and any interceptors for this request.</p>
</blockquote>
<p>interceptors 是 HandlerInterceptor 接口对象的集合，这个接口定义了三个方法，具体的实现可能由框架提供，也可能由开发人员提供。这三个方法会在 <code>doDispatch(...)</code> 方法的第四步执行 handle 时被调用，分别是：</p>
<ul>
<li><p>preHandle(…)</p>
<p>前置拦截方法，按照 interceptors 的顺序逐个执行，方法有返回值，如果返回 false 则不会执行 handle 方法，调用 afterCompletion(…) 后返回</p>
</li>
<li><p>postHandle(…)</p>
<p>后置拦截方法，按照 interceptors 的顺序，倒序逐个执行，方法没有返回值</p>
</li>
<li><p>afterCompletion(…)</p>
<p>完成后拦截方法（完成既指正常完成，也指异常完成，总之一定会执行），方法没有返回值</p>
</li>
</ul>
<p>学习该类可参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/99286145?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160386981019724836749805%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160386981019724836749805&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-3-99286145.first_rank_ecpm_v3_pc_rank_v2&utm_term=HandlerExecutionChain&spm=1018.2118.3001.4187" target="_blank" rel="noopener">Spring MVC : 概念模型 HandlerExecutionChain</a>》。</p>
<h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><p>在 <code>doDispatch(...)</code> 方法的第一步获取 handler 的过程中，匹配 handler 是通过 HandlerMapping 来实现的。</p>
<p>HandlerMapping 代表着【请求 URL】到【请求处理器】之间的映射，在首个请求进入 Spring MVC 之后，框架将整理出 handlerMappings 集合，然后 DispatcherServlet 会为每个请求遍历 handlerMappings，询问哪个请求处理器能够处理当下的请求。</p>
<p>HandlerMapping 接口只定义了一个方法 <code>getHandler(request)</code>，它的接收参数是一个请求，它返回一个 handler。如果返回的 handler 不为 null，就代表它可以处理这个请求，这个返回的 handler 也就是上面所说的 HandlerExecutionChain 的实例对象。</p>
<p>学习该类可参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/88061102" target="_blank" rel="noopener">Spring MVC : HandlerMapping 和 HandlerAdapter 简介 : 概念和如何工作</a>》。</p>
<h1 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h1><p>在 <code>doDispatch(...)</code> 方法获取到 handler 之后，并不是使用它直接执行请求方法的，而是又找到 HandlerAdapter 对象，使用它来处理请求，执行请求方法。</p>
<p>HandlerAdapter 抽象了对【请求处理器】的【真正执行】，这使得 DispatcherServlet 可以无视 handler 的执行细节，当要支持更多的 handler 类型时，只需要实现 HandlerAdapter 接口就可以了。</p>
<p>学习该类可参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/98845094" target="_blank" rel="noopener">DispatcherServlet 请求处理主逻辑 : 2. 选择 Handler 对应的 HandlerAdapter</a>》。</p>
<br>

<p>本周先学习到这里吧。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 的时间类</title>
    <url>/2019/10/01/%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
    <content><![CDATA[<br>

<p>此篇是十月第一周的内容，拖延症太严重了，不得已鸽掉了九月。</p>
<p>分四个部分讲，分别是 Java 基础时间类、Java sql 时间类、Joda Time 时间类、 <code>java.time</code> 时间类。</p>
<p>既然本篇主讲时间，就顺便把我的博文更新的周数算法讲一下：每月1日所在的周，是本月的第一周，如果这周的前几天属于上一个月，则这几天归入到本月所在周中，例如 2019 年 10 月 1 日是周二，则该周是 10 月的第一周，同时 9 月 30 日也算作 10 月的第一周，而不属于 9 月的第六周。这种周数算法的原因在于，我喜欢一点点任务透支的感觉，以及重新开始的感觉。本周数算法从 10 月起正式生效，之前的博文既往不咎。</p>
<hr>
<h1 id="Java-基础时间类"><a href="#Java-基础时间类" class="headerlink" title="Java 基础时间类"></a>Java 基础时间类</h1><p>Java 的基础时间类有三个，分别是 <code>java.util</code> 包下的 <font color="#32CD32"><strong>Date</strong></font> 类和 <font color="#32CD32"><strong>Calendar</strong></font> 类，以及 <code>java.text</code> 包下的  <font color="#32CD32"><strong>SimpleDateFormat</strong></font> 类。</p>
<p>简单提两嘴这两个包，<code>java.util</code> 包是 Java 的实用工具类库包，包含 Java 的集合类、时间类、事件模型类等；<code>java.text</code> 包是跟文本、格式化打交道的包，比如处理时间、数字等。这两个包都是 Java 的上古基础包。</p>
<br>

<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>Date 类是 Java 里时间类中的老爹，它出场早，脾气倔，在保留着日期和时间最基本用法的同时，总能用其偏执的使用思路让人觉得拧巴。但是在程序员懒得找其他替代品时，它又几乎是第一选择，因为它的确是足够基础，当然了，使用时还要容忍它的反人类。</p>
<p>Date 类有两种构造函数，一种是获取当前时间，一种是根据你的输入时间来实例化时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fastTime = var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Date 类有很多方法，大部分均已标记 <code>@Deprecated</code> （已废弃），剩下的几个基本只有一个方法能用：<code>getTime()</code> ，而这个方法非常硬核，它 get 到的 Time 不是年月日，而是一个 <code>long</code> 类型的毫秒数，表示在格林尼治时间 1900 年开始之后，经过了多少毫秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date.getTime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印结果：1569456444308</span></span><br></pre></td></tr></table></figure>

<p>Date 类的反人类处</p>
<ul>
<li>Date 类计算年份时，是跟 1900 年进行比较的，比如今年（2019 年）对于 Date 类而言，它是 119 年，当调用 <code>getYear()</code> 方法时（该方法已被官方建议不要使用），它会说这是 119 年。</li>
<li>Date 类计算月份是，是从 0 开始计算的，因此这个月（9 月）对于 Date 类而言，它是 8 。</li>
<li><code>getDay()</code> 方法是获取当周的第几天， <code>getDate()</code> 方法是获取当月的第几天（这两个方法也已被遗弃）。</li>
<li>Date 类自己的一切 <code>getXXX()</code> 方法，实际上只剩下了 <code>getTime()</code> 方法，表示获取当前时间（精确到毫秒）与 1900 年 1 月 1 日 0 时 0 分 0 秒这一瞬间（包含时差），中间间隔的毫秒数，其他获取年月日等时间的方法均被遗弃，官方建议使用 Calendar 类。</li>
<li>Date 类的 <code>getTime()</code> 方法是指获取毫秒数，比如现在时间的 <code>getTime()</code> 的值为 1569454704886 ，太硬核了。更硬核的是，Date 类的构造函数只剩下两种能用，一种是无参构造（得到当下的时间），另一种是以刚才的那个毫秒数为参数。</li>
<li>Date 类的值不是 final 的，是可以在实例化之后通过 <code>setTime()</code> 改变值的，非线程安全。</li>
<li>当调用 Date 类的 <code>toString()</code> 方法时，它会打印出例如 <code>Tue Sep 10 00:00:00 CST 2019</code> （中国标准时间 2019 年 9 月 10 日 0 时 0 点 0 分）的值，你发现这里包含时区信息 CST，但令人无语的是，这个时区信息是 Date 类在调用 <code>toString()</code> 方法时，根据系统时区动态打印的。换句话说，刚才那个时间的程序在中国执行，时区是 CST，在美国执行，那时区就是 PDT。</li>
</ul>
<br>

<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><p>calendar 是日历的意思，因此见名知意，Calendar 类是用来跟年月日等时间打交道的类。</p>
<p>Calendar 类本身是一个抽象类，它代表着日历类的标准与规范，有 GregorianCalendar 类（格林尼治日历时间）等实现类。实例化一个 Calendar 类，如果不使用子类，那就要通过工厂方法获得了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Calendar类的实例化方法</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面这种是错误的</span></span><br><span class="line">Calendar calendar = <span class="keyword">new</span> Calendar();</span><br></pre></td></tr></table></figure>

<p>这里通过 <code>Calendar.getInstance()</code> 获得的，是一个 GregorianCalendar 对象。</p>
<p>Calendar 类最实用的方法是它的 <code>get()</code> 方法，用这个方法获取年、月、日、周、小时等等 17 类不同的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取calendar的年份信息 如2019</span></span><br><span class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取calendar的月份信息 如9</span></span><br><span class="line"><span class="keyword">int</span> month = calendar.get(Calendar.MONTH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取calendar的当月天数信息，如10</span></span><br><span class="line"><span class="keyword">int</span> date = calendar.get(Calendar.DATE);</span><br></pre></td></tr></table></figure>

<p>上面诸如 <code>Calendar.YEAR</code> 之类的值，其实是 Calendar 类定义的常量值，<code>Calendar.YEAR</code> 其实就是 1，换句话说，下面两行代码是一样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> year1 = calendar.get(Calendar.YEAR);</span><br><span class="line"><span class="keyword">int</span> year2 = calendar.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>通过 Calendar 类的 <code>get()</code> 方法能得到 17 类不同的时间信息，这 17 个常量值列在下面：</p>
<table>
<thead>
<tr>
<th>常量名</th>
<th>常量值</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>ERA</td>
<td>0</td>
<td>纪元（0：BC 即公元前，1：AD 即公元后）</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>2</td>
<td>月</td>
</tr>
<tr>
<td>WEEK_OF_YEAR</td>
<td>3</td>
<td>本年第几周</td>
</tr>
<tr>
<td>WEEK_OF_MONTH</td>
<td>4</td>
<td>本月第几周</td>
</tr>
<tr>
<td>DATE</td>
<td>5</td>
<td>本月第几日</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>5</td>
<td>本月第几日，与 DATE 完全相同</td>
</tr>
<tr>
<td>DAY_OF_YEAR</td>
<td>6</td>
<td>本年第几日</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>7</td>
<td>本周第几日</td>
</tr>
<tr>
<td>DAY_OF_WEEK_IN_MONTH</td>
<td>8</td>
<td>当前月第几周</td>
</tr>
<tr>
<td>AM_PM</td>
<td>9</td>
<td>上午/下午（0：AM 即上午，1：PM 即下午）</td>
</tr>
<tr>
<td>HOUR</td>
<td>10</td>
<td>当天第几个小时（12 小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>11</td>
<td>当天第几个小时（24 小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>12</td>
<td>当小时第多少分钟</td>
</tr>
<tr>
<td>SECOND</td>
<td>13</td>
<td>当分钟第多少秒</td>
</tr>
<tr>
<td>MILLISECOND</td>
<td>14</td>
<td>当秒第多少毫秒</td>
</tr>
<tr>
<td>ZONE_OFFSET</td>
<td>15</td>
<td>距 GMT 时区偏移时间（以毫秒为单位，mdzz）</td>
</tr>
<tr>
<td>DST_OFFSET</td>
<td>16</td>
<td>夏令时偏移时间（以毫秒为单位）</td>
</tr>
</tbody></table>
<p>具体的使用可以参考这一篇文章：<a href="https://blog.csdn.net/cqx13763055264/article/details/81088635" target="_blank" rel="noopener">《Calendar的基本使用和属性说明》</a>，整理得很细致。</p>
<p>Calendar 类相比于 Date 类更为先进的地方是，它可以通过人类能理解的方式设置和变更时间，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置了一个时间：2019年9月1日0时0分0秒</span></span><br><span class="line">calendar.set(<span class="number">2019</span>, Calendar.JANUARY, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把时间往前12个月</span></span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把时间往后8个月（但是只改变月份，不改变其他年份等其他时间）</span></span><br><span class="line">calendar.roll(Calendar.MONTH, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<p>但让人依旧无语的是，Calendar 类的月份也是从 0 开始的。此外 Calendar 类不支持格式化。</p>
<br>

<h2 id="SimpleDateFormat"><a href="#SimpleDateFormat" class="headerlink" title="SimpleDateFormat"></a>SimpleDateFormat</h2><p>SimpleDateFormat 类是一个【格式化】和【解析日期】的工具类，即 <code>Date -&gt; Text</code> 或者 <code>Text -&gt; Date</code>，而且能够按照要求格式转换，如输出 <code>2019-09-10 12:00:00</code> 这种时间文本。</p>
<p>下面就是最常见的用法，声明好格式之后，使用 <code>format()</code> 方法把时间转换成字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss zzz"</span>);</span><br><span class="line">String dateStr = simpleDateFormat.format(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dateStr : "2019-09-26 23:49:26 CST"</span></span><br></pre></td></tr></table></figure>

<p>另一种常见的用法是把字符串转换成时间，但是要异常处理，毕竟是处理字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss zzz"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Date date = simpleDateFormat.parse(<span class="string">"2019-09-26 23:49:26 CST"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// date.toString() : Thu Sep 26 23:49:26 CST 2019</span></span><br></pre></td></tr></table></figure>

<p>字母与时间的对应关系如下（<a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html" target="_blank" rel="noopener">数据来源</a>）：</p>
<table>
<thead>
<tr>
<th>字母</th>
<th>日期或时间元素</th>
<th>表示</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>G</code></td>
<td>Era 标志符</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener">Text</a></td>
<td><code>AD</code></td>
</tr>
<tr>
<td><code>y</code></td>
<td>年</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#year" target="_blank" rel="noopener">Year</a></td>
<td><code>1996</code>; <code>96</code></td>
</tr>
<tr>
<td><code>M</code></td>
<td>年中的月份</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#month" target="_blank" rel="noopener">Month</a></td>
<td><code>July</code>; <code>Jul</code>; <code>07</code></td>
</tr>
<tr>
<td><code>w</code></td>
<td>年中的周数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>27</code></td>
</tr>
<tr>
<td><code>W</code></td>
<td>月份中的周数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>D</code></td>
<td>年中的天数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>189</code></td>
</tr>
<tr>
<td><code>d</code></td>
<td>月份中的天数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>F</code></td>
<td>月份中的星期</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td>星期中的天数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener">Text</a></td>
<td><code>Tuesday</code>; <code>Tue</code></td>
</tr>
<tr>
<td><code>a</code></td>
<td>Am/pm 标记</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#text" target="_blank" rel="noopener">Text</a></td>
<td><code>PM</code></td>
</tr>
<tr>
<td><code>H</code></td>
<td>一天中的小时数（0-23）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>k</code></td>
<td>一天中的小时数（1-24）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>24</code></td>
</tr>
<tr>
<td><code>K</code></td>
<td>am/pm 中的小时数（0-11）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>h</code></td>
<td>am/pm 中的小时数（1-12）</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>12</code></td>
</tr>
<tr>
<td><code>m</code></td>
<td>小时中的分钟数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>s</code></td>
<td>分钟中的秒数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>55</code></td>
</tr>
<tr>
<td><code>S</code></td>
<td>毫秒数</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#number" target="_blank" rel="noopener">Number</a></td>
<td><code>978</code></td>
</tr>
<tr>
<td><code>z</code></td>
<td>时区</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#timezone" target="_blank" rel="noopener">General time zone</a></td>
<td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code></td>
</tr>
<tr>
<td><code>Z</code></td>
<td>时区</td>
<td><a href="https://aisia.moe/java6api-cn/java/text/SimpleDateFormat.html#rfc822timezone" target="_blank" rel="noopener">RFC 822 time zone</a></td>
<td><code>-0800</code></td>
</tr>
</tbody></table>
<p>虽然使用 SimpleDateFormat 类能进行文本处理了，但是使用起来还是挺不方便的，而且还要考虑异常处理，此外它还线程不安全。</p>
<hr>
<h1 id="java-sql-包中的时间类"><a href="#java-sql-包中的时间类" class="headerlink" title="java.sql 包中的时间类"></a><code>java.sql</code> 包中的时间类</h1><p>在 java 中有一个与数据库相对应的类包，是 <code>java.sql</code> 包，该包下有三个对应数据库时间类型的类，分别是 <font color="#32CD32"><strong>Date</strong></font> 类、 <font color="#32CD32"><strong>Time</strong></font> 类和 <font color="#32CD32"><strong>TimeStamp</strong></font> 类，这是三个废物类，一无是处。</p>
<p>这三个类是与数据库中的时间数据类型完全对应的：</p>
<table>
<thead>
<tr>
<th>数据库的时间类型</th>
<th>java.sql 时间类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>Date</td>
<td>2019-09-01</td>
</tr>
<tr>
<td>TIME</td>
<td>Time</td>
<td>12:00:00</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>Timestamp</td>
<td>2019-09-01 12:00:00.000</td>
</tr>
</tbody></table>
<p>说这三个类废物，不是没有根据的：</p>
<ol>
<li>这三个时间类的构造方法都只有一种（另一种官方废弃不建议使用），那就是【当下时间距离 1970 年 1 月 1 日 0 时 0 分 0 秒 0 毫秒】的毫秒数，反人类。</li>
<li>这三个时间类没有诸如 <code>getDate()</code> 之类获取时间的方法，它们有什么方法呢，只有转换成别的时间类的方法 ：)</li>
<li>除了这三个类之外，别的时间类也可以对接数据库。</li>
</ol>
<p>一无是处。</p>
<br>

<hr>
<h1 id="Joda-Time-时间类"><a href="#Joda-Time-时间类" class="headerlink" title="Joda Time 时间类"></a>Joda Time 时间类</h1><p>从上面两部分的时间类看得出，用 JDK 自带的时间类编程，还是比较痛苦的：其一，想完成某个需求，可能需要好几个时间类同时使用；其二，上述时间类还存在着许多例如月份从 0 开始计数、时区信息伪造等暗坑。</p>
<p>这种痛苦的局面在 JDK 8 得到了解决，因为 JDK 8 设计了全新的时间类，但是低版本的 JDK 依旧痛苦。想解决这种痛苦，就要使用第三方类库，Joda Time 就是一个优秀的第三方时间类库。</p>
<p>此外想吐槽的一点是，Joda Time 有一种死心塌地的备胎感，因为它的官网在所有地方都在反复提及：如果使用 JDK 8 及其之后的版本，应该使用 JDK 8 提供的 <code>java.time</code> 包中的时间类，不要使用 Joda Time。真是让人感动，当然我猜这是因为 Joda Time 的作者参与了 JDK 8 的 <code>java.time</code> 包的设计，人家暗中备胎转正了。</p>
<br>

<p><code>org.joda.time</code> 包下的类，大致可以分为三种：</p>
<ol>
<li>时间类（类似于上文的 Date 类）</li>
<li>格式化与解析类（类似于上文的 SimpleDateFormat 类）</li>
<li>时间跨度类</li>
</ol>
<p>时间类就是真正用来记录如 <code>2019-10-07 22:48:03</code> 这类时间的类，格式化与解析类是把时间类型和字符串类型进行相互转换的类，时间跨度类是记录如 <code>2年零3个月</code> 这类间隔时间的类。</p>
<p>接下来逐个类型讲解。</p>
<br>

<h2 id="Joda-Time-的时间类"><a href="#Joda-Time-的时间类" class="headerlink" title="Joda Time 的时间类"></a>Joda Time 的时间类</h2><p>首先要注意：<font color="#FF0000"><strong>Joda Time 所设计的时间类，统统都不可改变（immutable）</strong></font>，跟 String 是一样的，一经实例化，不得改变其值，从源头上实现了线程安全。当需要改变时间时，Joda Time 会返回一个全新的 Joda 实例，也跟 String 的设计是一样的。</p>
<p><code>org.joda.time</code> 包下有五个常用的时间类，以表格形式列在下面：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
<th>示例（2019 年 10 月 1 日 12 时整）</th>
</tr>
</thead>
<tbody><tr>
<td>DateTime</td>
<td>日期+时间（含时区信息）</td>
<td>2019-10-01T00:00:00.000+08:00</td>
</tr>
<tr>
<td>Instant</td>
<td>日期+时间（格林威治时间，存疑）</td>
<td>2019-10-01T12:00:00.000Z</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>日期+时间（不含时区信息）</td>
<td>2019-10-01T12:00:00.000</td>
</tr>
<tr>
<td>LocalDate</td>
<td>日期（不含时区信息）</td>
<td>2019-10-01</td>
</tr>
<tr>
<td>LocalTime</td>
<td>时间（不含时区信息）</td>
<td>12:00:00.000</td>
</tr>
</tbody></table>
<p><font color="#32CD32"><strong>Instant</strong></font> 类是指时间轴上一个确定的时间点（精确到微妙），但是我自认为用处实在是不多，还是其他四个类：<font color="#32CD32"><strong>DateTime</strong></font> 类、<font color="#32CD32"><strong>LocalDateTime</strong></font> 类、<font color="#32CD32"><strong>LocalDate</strong></font> 类、<font color="#32CD32"><strong>LocalTime</strong></font> 类使用比较频繁，如果需要时区信息则使用第一个，如果不需要时区信息，那就使用后面三个以“Local”开头的类。</p>
<p>以上五个时间类，使用方法可以用随心所欲来形容，你想怎么用就怎么用。以 <font color="#32CD32"><strong>DateTime</strong></font> 类为例，介绍 Joda Time 时间类的主要用法：</p>
<ol>
<li><p>得到一个时间对象</p>
<p>有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前时间</span></span><br><span class="line">DateTime dateTime1 = <span class="keyword">new</span> DateTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意一种时间类的实例，自动转换</span></span><br><span class="line">DateTime dateTime2 = <span class="keyword">new</span> DateTime(dateTime1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动填写年月日时间等信息，有9种填写规则</span></span><br><span class="line">DateTime dateTime3 = <span class="keyword">new</span> DateTime(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自1970年1月1日0日整之后的毫秒数</span></span><br><span class="line">DateTime dateTime4 = <span class="keyword">new</span> DateTime(<span class="number">1569902400000L</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用静态方法，读取一个字符串转换成时间</span></span><br><span class="line">DateTime dateTime5 = DateTime.parse(<span class="string">"2019-10-01T12:00:00.000+08:00"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取时间信息</p>
<p>同样有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前月份</span></span><br><span class="line"><span class="keyword">int</span> monthOfYear = dateTime.getMonthOfYear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当天过了多少秒</span></span><br><span class="line"><span class="keyword">int</span> secondOfDay = dateTime.getSecondOfDay();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取自1970年1月1日0时之后过了多少微秒</span></span><br><span class="line"><span class="keyword">long</span> millis = dateTime.getMillis();</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改时间信息（会返回一个全新的 DateTime 实例）</p>
<p>再次有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 天数 + 1（plus)</span></span><br><span class="line">DateTime plusDateTime = dateTime.plusDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小时数 - 10（minus）</span></span><br><span class="line">DateTime minusDateTime = dateTime.minusHours(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置月份为 8 月（with）</span></span><br><span class="line">DateTime withDateTime = dateTime.withMonthOfYear(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他操作</p>
<p>再再次有超级多的方法，以下只列举几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该时间是否比当下时间早</span></span><br><span class="line"><span class="keyword">boolean</span> beforeNow = dateTime.isBeforeNow();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对比另一个时间（随意一个时间类的实例），判断是否在其之后</span></span><br><span class="line"><span class="keyword">boolean</span> afterTime = dateTime.isAfter(dateTime2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成废物的java.util.date类</span></span><br><span class="line">Date date = dateTime.toDate();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我知道你懒得看，你只要知道，Joda Time 几乎无所不能，使用时随心所欲，就可以了。</p>
<br>

<h2 id="Joda-Time-的格式化与解析类"><a href="#Joda-Time-的格式化与解析类" class="headerlink" title="Joda Time 的格式化与解析类"></a>Joda Time 的格式化与解析类</h2><p>Joda Time 的格式化与解析类，常用的有三个类，分别是 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类、<font color="#32CD32"><strong>DateTimeFormat</strong></font> 类和 <font color="#32CD32"><strong>DateTimeFormatterBuilder</strong></font> 类。其实不使用这三个类，也可以实现时间解析与格式化处理，直接用字符串指定好样式就可以了，使用这三个类是为了简便和统一操作。</p>
<ol>
<li><p><font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类</p>
<p>时间解析与格式化处理类，用于日期和时间与字符串之间的转换。</p>
<p>当<code>时间类 -&gt; 字符串</code>时，使用时间类的<code>toString(DateTimeFormatter formatter)</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormat.fullDateTime();</span><br><span class="line">String dateTimeStr = dateTime.toString(dateTimeFormatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dateTimeStr: "2019年10月1日 星期二 下午01时00分00秒 CST"</span></span><br></pre></td></tr></table></figure>

<p>当<code>字符串 -&gt; 时间类</code>时，使用时间类的静态方法<code>parse(String str, DateTimeFormatter formatter)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTime dateTime = DateTime.parse(<span class="string">"2019年10月1日 星期二 下午01时00分00秒 CST"</span>, dateTimeFormatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dateTime.toString: "2019-10-01T13:00:00.000-05:00"</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><font color="#32CD32"><strong>DateTimeFormat</strong></font> 类</p>
<p>这是 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类的工厂类，提供各种创建  <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类的实例方法。</p>
<table>
<thead>
<tr>
<th>工厂方法名</th>
<th>示例（ 2019 年 10 月 1 日 13 时整）</th>
</tr>
</thead>
<tbody><tr>
<td>fullDateTime()</td>
<td>2019年10月1日 星期二 下午01时00分00秒 CST</td>
</tr>
<tr>
<td>fullDate()</td>
<td>2019年10月1日 星期二</td>
</tr>
<tr>
<td>fullTime()</td>
<td>下午01时00分00秒 CST</td>
</tr>
<tr>
<td>longDateTime()</td>
<td>2019年10月1日 下午01时00分00秒</td>
</tr>
<tr>
<td>longDate()</td>
<td>2019年10月1日</td>
</tr>
<tr>
<td>longTime()</td>
<td>下午01时00分00秒</td>
</tr>
<tr>
<td>mediumDateTime()</td>
<td>2019-10-1 13:00:00</td>
</tr>
<tr>
<td>mediumDate()</td>
<td>2019-10-1</td>
</tr>
<tr>
<td>mediumTime()</td>
<td>13:00:00</td>
</tr>
<tr>
<td>shortDateTime()</td>
<td>19-10-1 下午01:00</td>
</tr>
<tr>
<td>shortDate()</td>
<td>19-10-1</td>
</tr>
<tr>
<td>shortTime()</td>
<td>下午01:00</td>
</tr>
<tr>
<td>forPattern(String pattern)</td>
<td>自定义格式</td>
</tr>
<tr>
<td>forStyle(String style)</td>
<td>按样式，建议阅读<a href="https://www.joda.org/joda-time/apidocs/org/joda/time/format/DateTimeFormat.html#forStyle-java.lang.String-" target="_blank" rel="noopener">官方API</a></td>
</tr>
<tr>
<td>patternForStyle(String style, Locale locale)</td>
<td>根据地区告知样式内容，返回一个样式字符串<br>如样式是”MM”且地区为中国时，返回：yyyy’年’M’月’d’日’ EEEE ahh’时’mm’分’ss’秒’ z</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p><font color="#32CD32"><strong>DateTimeFormatterBuilder</strong></font> 类</p>
<p>这个类是用作生成复杂时间样式的类，可以自由拼接时间，自由指定间隔样式等等，例如“十月 01 日 星期二 下午”。这个类本身是可以改变的（非线程安全），但是它可以转换成 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类，此时就是不能改变的（线程安全）。</p>
<p>本类的操作跟 StringBuilder 类几乎是一致的，使用场景不多，用起来也比较顺手，只贴出一段代码示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatterBuilder dateTimeFormatterBuilder = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">    .appendEraText()              <span class="comment">// 纪元（由于是Text，不需要自己指定精度）</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)           <span class="comment">// 分隔（此处用空格分隔）</span></span><br><span class="line">    .appendYear(<span class="number">4</span>, <span class="number">4</span>)             <span class="comment">// 年（参数表示数字精度，最少4位，最多四位）</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)</span><br><span class="line">    .appendMonthOfYear(<span class="number">2</span>)         <span class="comment">// 月份</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)</span><br><span class="line">    .appendDayOfMonth(<span class="number">2</span>)          <span class="comment">// 日</span></span><br><span class="line">    .appendLiteral(<span class="string">' '</span>)</span><br><span class="line">    .appendDayOfWeekText()        <span class="comment">// 周几</span></span><br><span class="line">    .appendLiteral(<span class="string">" 该天已度过"</span>) <span class="comment">// 分隔（此处用语句分隔）</span></span><br><span class="line">    .appendFractionOfDay(<span class="number">2</span>, <span class="number">2</span>)    <span class="comment">// 当天已过去多少百分比</span></span><br><span class="line">    .appendLiteral(<span class="string">"%"</span>);</span><br><span class="line">DateTimeFormatter dateTimeFormatter = dateTimeFormatterBuilder.toFormatter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印示例：公元 2019 10 01 星期二 该天已度过54%</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<br>

<h2 id="Joda-Time-的时间跨度类"><a href="#Joda-Time-的时间跨度类" class="headerlink" title="Joda Time 的时间跨度类"></a>Joda Time 的时间跨度类</h2><p>Joda Time 设计了三个类，用来表示时间跨度，分别是 <font color="#32CD32"><strong>Duration</strong></font> 类、<font color="#32CD32"><strong>Period</strong></font> 类和 <font color="#32CD32"><strong>Interval</strong></font> 类。</p>
<ul>
<li><font color="#32CD32"><strong>Duration</strong></font> 类保存了一个精确的毫秒数，比如你设置它为一天，它会记录下这是 86400 秒（如有毫秒会精确到小数点后三位）。</li>
<li><font color="#32CD32"><strong>Period</strong></font> 类保存了一段时间，例如 1 年 10 个月 1 小时 1 毫秒（它记录成 P1Y10MT-1H-0.001S）</li>
<li><font color="#32CD32"><strong>Interval</strong></font> 类保存了一个开始时刻和一个结束时刻，因而也能够表示一段时间。</li>
</ul>
<p>我觉得官方 API 的说明对理解很有帮助：</p>
<blockquote>
<p>Duration: An immutable duration specifying a length of time in milliseconds.</p>
<p>Period: An immutable time period specifying a set of duration field values.</p>
<p>Interval: Interval is the standard implementation of an immutable time interval.</p>
</blockquote>
<p>虽然在我测试和学习之后，感觉这三个类有蛮多道道，也有设计精巧的地方，但我认为，这三个类没有太多的应用场景，时间跨度不是一个常见的需求，用到的时候看一看方法名就能大致猜到了，不写了。</p>
<br>

<hr>
<h1 id="java-time-包中的时间类"><a href="#java-time-包中的时间类" class="headerlink" title="java.time 包中的时间类"></a><code>java.time</code> 包中的时间类</h1><p>当我们迎来 JDK 8 时，我们再也不需要 Joda Time 之类的第三方类库了，因为官方给我们提供了全新的时间类，这些类都属于 <code>java.time</code> 包下。</p>
<p>官方提供的全新时间类，仍然可以分成三种类型：</p>
<ol>
<li>时间类（类似于上文的 Date 类）</li>
<li>格式化与解析类（类似于上文的 SimpleDateFormat 类）</li>
<li>时间跨度类</li>
</ol>
<p>当一个个类接触下去之后，你会发现 JDK 8 所提供的 <code>java.time</code> 包中的时间类，和 Joda Time 是何其相似，相似到你觉得简直像是 Joda Time 备胎转正，我猜想这跟 Joda Time 的作者参与到 <code>java.time</code> 包的开发中有关。</p>
<p>我感觉这两个类库的设计，最主要的区别在于，Joda Time 习惯于 new 一个对象出来，而 <code>java.time</code> 习惯于用静态工厂方法实例化一个对象出来。</p>
<br>

<h2 id="java-time-包的时间类"><a href="#java-time-包的时间类" class="headerlink" title="java.time 包的时间类"></a><code>java.time</code> 包的时间类</h2><p><code>java.time</code> 包中的时间类设计，几乎与 Joda Time 一模一样，也是有五个类。</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>作用</th>
<th>示例（2019 年 10 月 1 日 12 时整）</th>
</tr>
</thead>
<tbody><tr>
<td>ZonedDateTime</td>
<td>日期+时间（含时区信息）</td>
<td>2019-10-01T00:00:00.000+08:00[Asia/Shanghai]</td>
</tr>
<tr>
<td>Instant</td>
<td>日期+时间（格林威治时间，存疑）</td>
<td>2019-10-01T12:00:00.000Z</td>
</tr>
<tr>
<td>LocalDateTime</td>
<td>日期+时间（不含时区信息）</td>
<td>2019-10-01T12:00:00.000</td>
</tr>
<tr>
<td>LocalDate</td>
<td>日期（不含时区信息）</td>
<td>2019-10-01</td>
</tr>
<tr>
<td>LocalTime</td>
<td>时间（不含时区信息）</td>
<td>12:00:00.000</td>
</tr>
</tbody></table>
<p>你若将 <code>java.time</code> 包与 Joda Time 所表示时间的五个类进行比较，你会发现，后四个类的类名、作用、具体示例是一模一样的，完全相同，只有第一个【包含时区信息的日期+时间】的类，两个是稍有不同的。</p>
<p>在 Joda Time 中类名是 <font color="#32CD32"><strong>DateTime</strong></font>，而在 <code>java.time</code> 包中是 <font color="#32CD32"><strong>ZonedDateTime</strong></font>，更明显地表现出这是一个跟时区有关系的类，这两个类通过 <code>toString()</code> 方法打印出来，也仅仅是最末尾相差了一处地区信息：[Asia/Shanghai]，除此之外，分毫未差。</p>
<p>这五个类在使用上也几乎没什么区别，最主要的的区别只有一处，那就是：JDK 8 的 <code>java.time</code> 包中的时间类，不再具有 public 的构造方法，而只有类静态方法。</p>
<p>也就是说，通过类构造方法实例化对象，是错误的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误！</span></span><br><span class="line">LocalDate localDate = <span class="keyword">new</span> LocalDate();</span><br></pre></td></tr></table></figure>

<p>因为这个类构造方法是私有（private）的，不对外公开。</p>
<p>实例化对象，需要使用类静态方法（有很多个静态方法，这里只展示两个有代表性的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法 now() 当前时间</span></span><br><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法 of()  构造时间</span></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<br>

<h2 id="java-time-包的格式化与解析类"><a href="#java-time-包的格式化与解析类" class="headerlink" title="java.time 包的格式化与解析类"></a><code>java.time</code> 包的格式化与解析类</h2><p><code>java.time</code> 包省去了 <font color="#32CD32"><strong>DateTimeFormat</strong></font> 类，将其方法合并到 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 类中，实例化一个 <font color="#32CD32"><strong>DateTimeFormatter</strong></font> 对象也就只能用这个类自己的静态工厂方法，但是使用起来和 Joda Time 并没有什么太大的区别。</p>
<p><code>java.time</code> 包保留了 <font color="#32CD32"><strong>DateTimeFormatterBuilder</strong></font> 类，使用起来跟 Joda Time 也是几乎完全一样。</p>
<p>这部分不写了，具体的内容可以参考这篇文章：<a href="https://www.twle.cn/c/yufei/java8/java8-basic-datetime-format-api.html" target="_blank" rel="noopener">《Java 8 新日期时间 API ( 下 ) - 格式化》</a></p>
<br>

<h2 id="java-time-包的时间跨度类"><a href="#java-time-包的时间跨度类" class="headerlink" title="java.time 包的时间跨度类"></a><code>java.time</code> 包的时间跨度类</h2><p><code>java.time</code> 包去除掉了 Joda Time 中鸡肋的 <font color="#32CD32"><strong>Interval</strong></font> 类（保存一个开始时间和一个结束时间），保留下了另外两个类：<font color="#32CD32"><strong>Duration</strong></font> 类和 <font color="#32CD32"><strong>Period</strong></font> 类。</p>
<p>跟 Joda Time 的设计稍微不同，<font color="#32CD32"><strong>Duration</strong></font> 类保存了一个精确到纳秒的时间（例如 5 小时零 1 纳秒是 PT5H0.000000001S），但是 <font color="#32CD32"><strong>Period</strong></font> 类是一致的，仍然是保存一段时间。在使用上，<font color="#32CD32"><strong>Duration</strong></font> 类更偏向于时间（time），而 <font color="#32CD32"><strong>Period</strong></font> 类更偏向于日期（calendar）。</p>
<p>具体的方法、使用的逻辑，与 Joda Time 如出一辙，那就写到这里吧。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/07/31/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<br>

<p>这周看完线程池，然后并发相关的学习就先告一段落。</p>
<hr>
<p>本周最后要学习的类是 ThreadPoolExecutor，它从 Executor 接口一层层继承下来，因此总共要学习四个类。主要的学习来源是<a href="https://www.javadoop.com/post/java-thread-pool" target="_blank" rel="noopener">《深度解读 java 线程池设计思想及源码实现》</a>，这篇文章写得很好，但是需要结合源码慢慢阅读。</p>
<p><img src="/assets/ThreadPoolExecutor1.png" alt="ThreadPoolExecutor1"></p>
<p>要学习的四个线程池类，前三个类的方法截图如下，结构还是比较清晰的：</p>
<p><img src="/assets/ThreadPoolExecutor%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="ThreadPoolExecutor继承关系"></p>
<p>下面分别记述吧。</p>
<hr>
<h1 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h1><p>Executor 是一个接口，只有一个方法，就是执行一个 Runnable。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是线程池最核心的方法，我们平常使用线程池，在拿到线程池对象之后，也只需要使用这个方法了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">executor.execute(() -&gt; System.out.println(<span class="string">"runnable正在执行"</span>));</span><br></pre></td></tr></table></figure>

<p>这个方法要看到最后才能看到实现，具体的实现还是很复杂的，也很精妙。</p>
<hr>
<h1 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h1><p>ExecutorService 也是一个接口，继承自 Executor 接口，新定义了许多方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，已提交的继续，不接受新的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池，已提交的尝试停止，不接受新的</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池已关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 shutdown / shutdownNow 后，且所有任务结束，返回true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 shutdown / shutdownNow 后，设置一个超时时间，判断线程池是否在超时时间内关闭（该超时时间不影响关闭，只是设置等待时间）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 callable 任务</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 runnable 任务，并把 result 设置为future的返回值</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 runnable 任务，future的返回值将是null</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一堆任务</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一堆任务，并设置超时时间</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一堆任务，只要有一个完成就返回，剩下的继续执行</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一堆任务，只要有一个完成就返回，剩下的继续执行，并设置超时时间</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常来讲，我们使用线程池时，拿到的对象都是这个接口的实现，因为这个接口中的大部分方法已经足够我们使用了。就比如最常见的 Executors，使用 Executors 工厂方法获取线程池，拿到的对象很多都是 ExecutorService 接口实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService1 = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">ExecutorService executorService2 = Executors.newSingleThreadExecutor();</span><br><span class="line">ExecutorService executorService3 = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>

<p>简单回顾一下：</p>
<ul>
<li>Executor 类只有一个方法，<code>execute()</code>，执行任务，没有返回。</li>
<li>ExecutorService 类新定义了很多方法，其中有 <code>submit()</code>，执行任务，有返回（通过 Future 类获取返回值）。</li>
</ul>
<hr>
<h1 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h1><p>AbstractExecutorService 是一个抽象类，继承自 ExecutorService 接口，实现了父类的 <code>submit()</code>、<code>invokeAny()</code>、<code>invokeAll()</code> 方法。</p>
<p>实现的方法中，其中比较重要的是 <code>submit()</code> 方法，我们刚刚提过，这个方法执行任务，有返回值。意思是说，在执行 <code>submit()</code> 方法方法之后，可以获得一个 Future 对象，这就是线程执行任务的返回值，可以通过 Future 的 <code>get()</code> 方法一直等到任务结束拿回任务结果。Future 的具体使用不在这里详细叙述，在此只关注实现。</p>
<p>AbstractExecutorService 的 <code>submit()</code> 方法有三种，主要的思想都是将【任务】和【返回值】封装成一个 Future 对象，然后返回这个 Future 对象。这里引入了 RunnableFuture 接口，这是一个同时继承 Runnable 和 Future 的接口，即让 Runnable 有了返回值。FutureTask 类实现了这个接口，<code>submit()</code> 方法也主要是通过这个类实现提交任务、返回值的。</p>
<p>下面是 RunnableFuture 接口和它的实现类 FutureTask 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runnable 是没有 future 的，这里是组合，让 runnable 也有返回值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面直接附上 AbstractExecutorService 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把 runnable 包装成 futureTask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把 callable 包装成 futureTask</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * runnable -&gt; runnableFuture -&gt; 提交任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * runnable -&gt; runnableFuture -&gt; 提交任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * callable -&gt; runnableFuture -&gt; 提交任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * （后面两个 invokeAny 方法的具体实现）</span></span><br><span class="line"><span class="comment">     * 提交一堆任务，一个结束就返回，如果 没有返回/超时 就抛异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任务不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">        <span class="keyword">if</span> (ntasks == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// future 列表（用于返回前，取消其他任务）</span></span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 this 包装成 ecs，内部有一个阻塞队列，用于记录所有的 future</span></span><br><span class="line">        ExecutorCompletionService&lt;T&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 定义一个异常，如果本方法没有得到任何结果，可以抛出最后遇到的异常</span></span><br><span class="line">            ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 超时时间</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">            <span class="comment">// 任务迭代器</span></span><br><span class="line">            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先提交一个任务，其他任务在后面的for循环里提交（任务数-1，正在执行的任务数+1）</span></span><br><span class="line">            futures.add(ecs.submit(it.next()));</span><br><span class="line">            --ntasks;</span><br><span class="line">            <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取刚刚提交任务的 future（从上面 ecs 内部的阻塞队列中获取）</span></span><br><span class="line">                Future&lt;T&gt; f = ecs.poll();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果最初提交的任务没有执行完，这里拿不到 future</span></span><br><span class="line">                <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 未执行任务√   -&gt; 再提交一个任务</span></span><br><span class="line">                    <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        --ntasks;</span><br><span class="line">                        futures.add(ecs.submit(it.next()));</span><br><span class="line">                        ++active;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 未执行任务× 正在执行任务×   -&gt; 循环终止</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 未执行任务× 正在执行任务√ 设置超时√   -&gt; 重新获取 future，超时抛异常</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                        <span class="keyword">if</span> (f == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                        nanos = deadline - System.nanoTime();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 未执行任务× 正在执行任务√ 设置超时×   -&gt; 阻塞等待 future</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        f = ecs.take();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果在多次循环之后，拿到了 future</span></span><br><span class="line">                <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    --active;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 返回 future，并把异常包装成 ee（ExecutionException）</span></span><br><span class="line">                        <span class="keyword">return</span> f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                        ee = eex;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                        ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不是很确定为什么 ee 会是 null</span></span><br><span class="line">            <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">                ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有返回任何 future，那么抛出去异常</span></span><br><span class="line">            <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 方法退出之前，取消其他的任务</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不设置超时的 doInvokeAny()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置超时时间的 doInvokeAny()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一堆任务，全部结束一起返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 任务集合不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// future 列表，用于最后全部结束后返回</span></span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将所有的任务包装成 runnableFuture，全部加入 future 列表，全部开始执行</span></span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逐一等待所有的 future 完成</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 主动阻塞等到所有的 future 完成</span></span><br><span class="line">                        <span class="comment">// 忽略两类异常，但还会抛出 InterruptedException 异常</span></span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException | ExecutionException ignore) &#123;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没完成，撤销还没执行完的任务</span></span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                    futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一堆任务，设置超时时间，</span></span><br><span class="line"><span class="comment">     * 最终返回所有任务列表，但是不一定执行完，有可能被中断或取消等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 任务不能为空</span></span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 超时时长</span></span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="comment">// future 列表，用于最后返回</span></span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把所有任务包装成 runnableFuture</span></span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">                futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 截止时间和任务数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逐个执行任务，每执行一个，检查一下时间，超时直接返回任务列表（不管有没有执行完）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                execute((Runnable)futures.get(i));</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逐个阻塞获取 future，每查一个，检查一下时间，超时直接返回任务列表（不管有没有执行完）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                        <span class="keyword">return</span> futures;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 逐一取消所有任务，如果任务没完成就会被取消</span></span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                    futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p>ThreadPoolExecutor 就是我们今天要学习的线程池，它有很多代码，我们挑着学。</p>
<p>从整体上讲，ThreadPoolExecutor 有两个最重要的设计，一是设定了一个线程池的内部状态数，二是通过内部类 Worker 来执行池中的任务。</p>
<h2 id="内部状态数"><a href="#内部状态数" class="headerlink" title="内部状态数"></a>内部状态数</h2><p>ThreadPoolExecutor 内部维护了一个 AtomicInteger（并发安全的 Integer），这个数字是线程池的内部状态数，它是一个 int 数字，长 32 位，其中高 3 位是状态位，低 29 位是线程的数量，具体可以看这部分代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ———————————————————— 线程池的内部状态 ———————————————————— */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个并发int，是线程池的内部状态数，其中高3位代表线程池的状态，后29位代表线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 这个数字是29(32-3)，是移位用的，可以看下面的五个状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 以下有五个状态，存储在线程池内部状态数 ctl 的高三位，例如 RUNNING：111 00000000000000000000000000000</span></span><br><span class="line">    <span class="comment">// 分别是：【运行】、【接收×继续√】、【接收×继续×】、【所有任务销毁后，执行钩子方法terminated()】、【terminated()方法结束】</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="comment">// 线程池的线程数容量，最多有 2^29-1 个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 下面有三个方法，分别是用来：获取状态、获取线程数、获取内部状态数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类Worker"><a href="#内部类Worker" class="headerlink" title="内部类Worker"></a>内部类Worker</h2><p>ThreadPoolExecutor 有一个内部类 Worker，这个类继承自 AQS，实现了 Runnable 接口，这一继承一实现特别巧妙，这个后面再说。</p>
<p>Worker 类实际上就是一个封装的线程，线程池按顺序执行批量任务，实际上就是内部有一些 Worker 对象，每个 Worker 对象就是一个线程，这些 worker 各自执行任务，执行完一个去任务队列里再拿一个。从这个意义上去理解，线程池其实就是 Worker 池，池中的所有 Worker 按顺序执行丢进池子里的任务。</p>
<p>想要更深地理解 Worker，就要去读 ThreadPoolExecutor 的其他源码了，尤其是构造方法和 <code>execute()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个内部类 Worker，是一个封装过的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正的执行线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程的时候可以同时指定第一个要执行的任务，如果为null，就去任务队列里拿</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程执行完的任务数量</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Worker构造方法，传入首个任务（可以是null），创建线程，设置AQS状态</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// （重写 Runnable 的 run 方法）调用外部的 runWorker() 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>我先把剩下的所有代码扔上来吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ———————————————————— 线程池的构造方法 ———————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数非法</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">// 必须有这几个参数</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不懂</span></span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="comment">// 核心线程数</span></span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="comment">// 最大线程数，线程池允许创建的最大线程数</span></span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="comment">// 任务队列，里面装着所有 runnable</span></span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="comment">// 空闲线程存活时间，默认指的是核心线程外的线程，一直没事干就会被回收</span></span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="comment">// 线程池，用于生成线程</span></span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="comment">// 拒绝策略，如果线程池满了，来了新任务应该采用什么策略</span></span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是终于提到的 <code>execute()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ———————————————————— execute 方法 ———————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个任务</span></span><br><span class="line"><span class="comment"> * 1. 如果核心线程数不满，创建 worker 去执行任务</span></span><br><span class="line"><span class="comment"> * 2. 如果核心线程数满了，放到 workQueue 等待 worker 空闲下来去执行任务</span></span><br><span class="line"><span class="comment"> * 中途失败，采用 handle 的拒绝策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 任务不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果核心线程数不满，调用 addWorker() 方法，直接返回</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 这个方法很长，具体实现见下文</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当代码执行到这里，说明核心线程数超了，或者 addWorker 失败了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果线程池 RUNNING，先把任务加到 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 如果线程池不是 RUNNING，workQueue 删除刚才的任务，采用拒绝策略</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果线程池 RUNNING，为了避免 worker 全部关闭，检查一下 worker 的数量，全部关闭时再创建一个</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果任务加入 workQueue 失败（容量满了），再试着 addWorker</span></span><br><span class="line">    <span class="comment">// 此时将创建以 maximumPoolSize 为边界的非核心 worker，再失败就拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个worker</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本方法使用到了线程池的如下属性：</span></span><br><span class="line"><span class="comment"> * - ctl(AtomicInteger) 线程池的内部状态数，高三位是线程池状态</span></span><br><span class="line"><span class="comment"> * - workQueue          任务队列</span></span><br><span class="line"><span class="comment"> * - mainLock           全线程池的公共锁</span></span><br><span class="line"><span class="comment"> * - workers(HashSet)   用于存储所有的worker</span></span><br><span class="line"><span class="comment"> * - largestPoolSize    用于记录 workers 中的个数的最大值，可以知道线程池的大小曾经达到的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两个入参：firstTask【准备提交给线程的任务，可null】，core【核心线程/最大线程】</span></span><br><span class="line"></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻译一下：</span></span><br><span class="line">        <span class="comment">// if (rs == STOP || rs == TIDYING || rs == TERMINATED      如果线程池处于 STOP,TIDYING,或TERMINATED 这三种状态</span></span><br><span class="line">        <span class="comment">//      || rs == SHUTDOWN &amp;&amp; firstTask != null              如果线程池处于 SHUTDOWN 状态，并且有新任务</span></span><br><span class="line">        <span class="comment">//      || rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())           如果线程池处于 SHUTDOWN 状态，并且【任务队列】空了</span></span><br><span class="line">        <span class="comment">//                                                          那么失败，返回false</span></span><br><span class="line">        <span class="comment">// 换种角度思考：</span></span><br><span class="line">        <span class="comment">// 如果线程池处于 SHUTDOWN 状态，并且没有 firstTask，并且【任务队列】不为空，那么是可以创建 Worker 的</span></span><br><span class="line">        <span class="comment">// 这种情况下是指，线程池关闭了，但是已提交的任务还没执行完毕，那么创建 Worker 继续执行</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                        firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 线程数超了，不能创建</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// CAS线程数+1，如果成功，那么就可以退出循环出去创建 Worker 了</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果线程池状态变更，到外层循环</span></span><br><span class="line">            <span class="comment">// 如果线程池状态不变，在本层循环</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到此，检验结束，可以创建 Worker 了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 【是否已启动worker】、【是否已把worker添加到HashSet中】</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个 worker，并拿到里面的线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 上锁，这是全线程池的锁，避免线程池在执行下面代码时被关闭（关闭也是用这个锁）</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 重新获取线程池的状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果线程池的状态是 RUNNING，或者虽然是 SHUTDOWN，但是没有 firstTask，并且潜在地【任务队列】不为空</span></span><br><span class="line">                <span class="comment">// 那么把 worker 装入 HashSet 中</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// worker 里的线程不可能已经启动</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 把 worker 存进 workers(HashSet) 中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 记录 workers 的最大容量</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 【是否已把worker添加到HashSet中】√</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 启动任务</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 线程启动之后，得到CPU的调度后，会再调用线程的run方法，去执行 runnable，而这里的 runnable 对象是 worker</span></span><br><span class="line">                <span class="comment">// 也就是说，在线程启动之后，（未知时间）会调用 runWorker 方法，也就是真正执行任务的方法，往后看</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，减掉</span></span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * worker 开始执行任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// worker 的 【wt：线程】和【task：任务】</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环获取任务，直到 workQueue 为空</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程池状态 &gt;= STOP 时线程阻塞，否则线程开启（这么复杂是为了避免 shutdownNow 造成的线程阻塞）</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP)))</span><br><span class="line">                    &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 钩子方法，留给需要的子类实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 当当当当，执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 钩子方法，留给需要的子类实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 重置任务为 null，进行下一次循环（获取任务执行...）</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中途没有被中断</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 执行到这里，要不然是没任务了，要不然是异常了，让后续代码处理</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒得写了，列一些点吧：</p>
<ul>
<li>线程池的构造方法中，会指定很多参数，corePoolSize 指的是核心线程数，实际上也就是核心 Worker 数。当线程池执行 <code>execute(runnable)</code> 方法时，扔进来一个 runnable 任务，会首先判断 Worker 的数量是否达到了核心线程数，如果不到就去创建一个 Worker 对象。核心线程数内的所有 Worker 对象都不会被销毁，执行完任务就去任务队列里面拿，任务队列空了就等。</li>
<li>当核心线程数满了，即有 corePoolSize 个 Worker 对象了，那么加入任务队列 workQueue 中，这是一个 AQS 阻塞队列（线程安全），当有 Worker 执行完任务后，会自己来 workQueue 里拿一个任务执行。</li>
<li>如果核心线程数满了，任务队列也满了，再加进来的任务，会按照最大线程数 maximumPoolSize 的大小继续创建 Worker，比如核心线程数是 10，最大线程数是 20，那么在已经有了 10 个 Worker 对象、并且任务队列也满了的情况下，可以继续创建 Worker 对象（每新加一个任务就新创建一个，直到再新创建 10 个达到最大的 20 个）。核心线程数之外的 Worker 对象，将在没有任务的可执行的情况下被销毁掉。</li>
<li><code>execute(runnable)</code> 方法的主要作用，就是创建 Worker，启动 Worker 中的线程，这个线程在启动之后（调用 <code>start()</code> 方法），将由 CPU 去调度，如果分到时间片，那么将调用起线程的 <code>run()</code> 方法，去执行 runnable 任务。而我们上面提过了，Worker 对象实现了 Runnable 接口，线程执行的那个 Runnable 对象，实际上就是 Worker 对象（这个设计太绝了！），由此实现了让 Worker 执行任务的目的。</li>
</ul>
<p>就写到这里吧。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Condition、CountDownLatch、CyclicBarrier 和 Semaphore</title>
    <url>/2020/07/15/Condition%E3%80%81CountDownLatch%E3%80%81CyclicBarrier-%E5%92%8C-Semaphore/</url>
    <content><![CDATA[<br>

<p>这周我们啃完 AQS。</p>
<hr>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>Condition 类可以看做 Java 重新实现了一遍 <code>object.wait()</code> 和 <code>object.notify()</code>，使用起来两者的思路是一致的，都是在执行 <code>wait</code>/<code>await</code> 或者 <code>notify</code>/<code>signal</code> 方法前需要获取锁，调用 <code>wait</code>/<code>await</code> 会将锁打开，并将线程包装存起来，调用 <code>notify</code>/<code>signal</code> 会将线程唤起，一直等到它获取到锁，然后继续运行。</p>
<p>看 Condition 类的源码能够更加理解这套使用思路的原因。</p>
<p>下面是 Condition 的代码，首先是 <code>await()</code> 方法（只分析了无参方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————————————————— 主方法 —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 线程中断，抛异常出去</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 将本线程包装起来，放入 condition 队列的末尾</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// 解锁，记录解锁前的 AQS 状态</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="comment">// 中断状态，这里要联合下面才能理解，总体上有三种值：</span></span><br><span class="line">    <span class="comment">// 0：没有中断</span></span><br><span class="line">    <span class="comment">// THROW_IE（-1）：发生中断，且在 signal 前</span></span><br><span class="line">    <span class="comment">// REINTERRUPT（1）：发生中断，且在 signal 后</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果不在 AQS 阻塞队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程被唤醒了，有以下几种可能</span></span><br><span class="line">        <span class="comment">//  1.（正常情况）signal 使自己进入 AQS 阻塞队列，等到前置节点执行完毕，唤醒自己</span></span><br><span class="line">        <span class="comment">//  2. signal 时，前置节点取消等待</span></span><br><span class="line">        <span class="comment">//  3. signal 时，CAS 设置前置节点的状态，从 0 修改为 -1 失败</span></span><br><span class="line">        <span class="comment">//  4. 中断</span></span><br><span class="line">        <span class="comment">//  5. 假唤醒</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从 while 出来时，已经确保节点在 AQS 阻塞队列中了</span></span><br><span class="line">    <span class="comment">// 判断是否需要阻塞（判断的时候抢一次锁），即判断是否发生了中断</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">// 如果中断不是 signal 前发生，那么设为 signal 后发生</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">// 如果中断发生在 signal 前，没有断开 condition 条件队列，那么断开后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果发生中断了，那么根据情况处理</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 中断在 signal 前，抛出中断异常</span></span><br><span class="line">        <span class="comment">// 中断在 signal 后，再次中断线程</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————— addConditionWaiter —————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前线程包装成结点，插入到 condition 队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 condition 队列尾结点</span></span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果尾结点失效了，清除所有失效结点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前线程包成结点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果尾结点为空，代表没有 condition 队列为空，设置头结点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="comment">// 否则插入尾结点后</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新设置尾结点</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清除所有失效结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————— fullyRelease —————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解开当前线程的所有锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// failed 记录的是，有没有解锁失败</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 记录当前 AQS 状态（本线程上了几把重入锁，state就是几）</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 解锁，并唤起 AQS 后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 condition 的方法，必然需要先拿到锁，</span></span><br><span class="line">            <span class="comment">// 执行到这里，应该能够把一开始拿到的锁全部解开，</span></span><br><span class="line">            <span class="comment">// 但是没有，说明出现了异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果解锁失败（抛出来异常），那么本 condition 节点取消</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本线程全解锁，并唤醒 AQS 的后继线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试本线程解锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤起 AQS 后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解锁成功以后，唤醒 AQS 下一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————— isOnSyncQueue —————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断节点是否在 AQS 阻塞队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是在 condition 队列中，则不在 AQS 队列里</span></span><br><span class="line">    <span class="comment">// 如果 prev 是 null，说明不在 AQS 阻塞队列中（否则会有前置节点）</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果 next 不是 null，说明在 AQS 阻塞队列中（后继节点）</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 在 AQS 队列中寻找（从后往前找），返回是否找到</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 队列从后往前找，找到指定节点为止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后开始</span></span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="comment">// 一直往前找，找到返回 true，没找到返回 false</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————————— checkInterruptWhileWaiting ——————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取节点的线程状态（没有中断、在signal前中断、在signal后中断）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程没有中断：返回 0</span></span><br><span class="line">    <span class="comment">// 线程中断，是在 signal 之前的，返回 THROW_IE</span></span><br><span class="line">    <span class="comment">// 线程中断，是在 signal 之后的，返回 REINTERRUPT</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程发生中断，判断是在signal前还是后</span></span><br><span class="line"><span class="comment"> * true:在signal之前  false:在signal之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS 修改状态，从 -2 改为 0</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果改成功了，说明原来 -2，中断发生在 signal 之前</span></span><br><span class="line">        <span class="comment">// 加入阻塞队列（也就是说，中断也会加进阻塞队列）</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行到这里，说明中断发生在 signal 之后</span></span><br><span class="line">    <span class="comment">// while 一直执行，直到节点加入到 AQS 阻塞队列中（因为有可能 signal 没执行完）</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断节点是否在 AQS 阻塞队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从后往前找，判断节点是否在 AQS 队列中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————————— reportInterruptAfterWait ——————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理中断</span></span><br><span class="line"><span class="comment"> * 如果发生在 signal 前，抛异常，如果发生在 signal 后，再次中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br></pre></td></tr></table></figure>

<br>

<p>然后贴一下 <code>signal()</code> 方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————————————————— 主方法 —————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 signal() 方法必须首先获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 获取 condition 队列首个节点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果非空，唤醒它</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————— isHeldExclusively —————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否在持有锁（ReentrantLock的重写实现）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断 AQS 的持锁线程是否是当前线程</span></span><br><span class="line">    <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————— doSignal —————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒 condition 队列的首个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 判断 condition 队列是否只有自己，如果是，队列尾节点置空</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 first 节点取消等待，并且队列不为空，唤醒下一个</span></span><br><span class="line">    <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 condition 队列节点转移到 AQS 队列中</span></span><br><span class="line"><span class="comment"> * 如果返回 false，代表节点在 condition 中取消等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 节点状态从 condition 转为初始化（如果失败说明已经取消，之间返回false）</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 尾插插入 AQS 队列，并拿到 AQS 队列的倒数第二个节点（不达目的 CAS 不罢休）</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="comment">// 拿到前置节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前置节点状态 &gt; 0，表示前置节点取消了等待，直接唤醒前一个节点</span></span><br><span class="line">    <span class="comment">// 如果前置节点的状态 &lt;= 0，那么把前置节点的状态设为 -1（可以唤醒后继节点）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">// 如果前置节点取消等待，或者 CAS 设置状态失败，唤醒前置节点</span></span><br><span class="line">        <span class="comment">// 这里结合 await() 方法继续看</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————————————————————————————— */</span></span><br></pre></td></tr></table></figure>

<p>过程还是很繁琐的，尤其是 <code>await()</code> 方法，看得我要吐了。</p>
<p>跟上一篇文章一样，本篇也整理了流程图，下图是最简单情况下的 condition 节点变化图（不考虑中断、锁的争抢、且锁是公平锁）：</p>
<p><img src="/assets/AQS_Condition.jpg" alt="AQS_Condition"></p>
<p>顺便附带一下测试上图的代码吧，一共起了四个线程，第一个 <code>await()</code>，第二个 <code>signal()</code>，后面两个打酱油，模拟 AQS 阻塞队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 起 1 个线程，调用 condition.await() 方法</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"condition唤醒"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再起 1 个线程，调用 condition.signal() 方法</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再起 2 个线程，在 AQS 队列里阻塞</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 什么也不做</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch 的意思是 <code>带有倒数功能的栅栏</code>，有两个核心方法：<code>await()</code> 和 <code>countDown()</code>，前者是等待，后者是倒数。</p>
<p>举一个使用的例子：首先创建一个栅栏，然后一堆线程执行了 <code>await()</code> 方法，被堵在了栅栏门口，被迫等待。这个栅栏开始时有一个数字 N，每执行一次 <code>countDown()</code> 方法（任何线程任何时候都可以），栅栏的数字 N 就会减一，一直到 N 被减为 0，栅栏口打开，所有的线程继续执行。</p>
<p>画了一张图，描述了一下 CountDownLatch 的使用场景：</p>
<p><img src="/assets/CountDownLatch_diagram.jpg" alt="CountDownLatch_diagram"></p>
<p>CountDownLatch 的源码相对简单很多：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ——————————————————— 构造方法 ——————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// count 必须大于 0</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————————————————— sync ——————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部维护一个 AQS 队列，老套路</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把 count 数字设置为 AQS 队列的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...（略）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 设置队列状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————————————————— countDown ——————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * countDown -1，如果减到 0，唤醒 AQS 队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 试着将 AQS state 减一，并返回是否 countDown 到 0</span></span><br><span class="line">    <span class="comment">// 如果已经到 0，不再减一，返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒 AQS 队列</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 AQS 队列的 state 减一</span></span><br><span class="line"><span class="comment"> * 重写 AQS 的 tryReleaseShared 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒第一个需要被唤醒的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果头结点需要唤醒后继节点</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// CAS 设置 head 的状态失败，那再来一遍循环</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 唤醒 h 的后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个节点（头结点），唤醒它的后继节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果后继节点为 null 或取消，从后往前找到一个需要被唤醒的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果找到了一个需要被唤醒的节点，唤醒它</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ——————————————————— await ——————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 countDown 到 0，直接返回，否则去休眠，等被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 首先判断是否已经 countDown 到 0 了，如果已经减到 0，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果没减到 0，唤醒自己及之后的整个队列</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断 state 是否减到 0</span></span><br><span class="line"><span class="comment"> * 如果减到了 0 返回 1，如果没减到 0 返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * countDown 到 0，直接返回，否则挂起线程，直到被唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个节点</span></span><br><span class="line">    <span class="comment">// 将该节点的 nextWaiter 指向 Node.SHARED（空节点）</span></span><br><span class="line">    <span class="comment">// 将该节点插入到阻塞队列末尾</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 判断是否已经 countDown 到 0</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 当 countDown 到 0 时，会进入下面的判断体中</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 唤醒 node 的后继节点（后继节点也会执行到这里，会链式唤醒所有）</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 首次进来，会设置前置节点为 -1，本循环结束</span></span><br><span class="line">            <span class="comment">// 再次进来，会判断可以休眠                       然后休眠</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果休眠过程中返回 false，说明发生中断，响应中断异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒下一个节点</span></span><br><span class="line"><span class="comment"> * 翻译名字：设置头，并传播(propagate)下去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存头结点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="comment">// 重新设置头结点（实际上这个头结点，是某阻塞节点的前置节点）</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 唤醒下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> || (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            <span class="comment">// 在 signal 里也是在调用这个方法</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把节点设置为头</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————— */</span></span><br></pre></td></tr></table></figure>

<p>CountDownLatch 的原理是，依旧维护一个 sync 队列（AQS 队列）,在 countDown 到 0 之前，所有 <code>await()</code> 的线程都包装成节点，按顺序阻塞在 sync 队列中。当 CountDownLatch 内部的计数器 count 减到 0 时，唤醒头结点（一个空节点），让空节点唤醒后继节点，后继节点醒来再唤醒它的后继，链式地叫醒所有。</p>
<p>画一张简图，描述一下内部队列在阻塞时的数据结构（就不画流程图了）：</p>
<p><img src="/assets/CountDownLatch_sync.jpg" alt="CountDownLatch_sync"></p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier 字面上的意思是周期性的栅栏，好像跟 CountDownLatch 相像，但其实还是不太一样的。</p>
<p>CyclicBarrier 的作用是凑齐一波线程就放行一波，否则线程们都等待。比如初始化的时候，设置 CyclicBarrier 为每 10 个线程一组，那么前 9 个线程出现时，都会挡在 CyclicBarrier 的栅栏前，被迫等待，直到第 10 个线程出现，10 个线程一起放行。之后重复这个行为，循环往复。</p>
<p>CountDownLatch 是外部改变栅栏的计数，countDown 一次，栅栏计数减 1，直到减到 0 栅栏打开。而对于 CyclicBarrier，被挡在栅栏外的线程数量是决定因素，凑够线程数，栅栏打开。</p>
<p><img src="/assets/CyclicBarrier_diagram.jpg" alt="CyclicBarrier_diagram"></p>
<p>CyclicBarrier 的源码就相对简单很多了，就是对 Condition 的简单使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ————————————————————— 基础信息 ————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部一个锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内部一个由锁生成的 Condition</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 预设线程数，当达到这个数时，栅栏打开</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 倒数，当该数减到 0 时，栅栏打开，初始化值设为 parties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每当栅栏将打开时，最后一个抵达的线程会执行这个 Runnable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代，一代线程，每次 count 到 0 或者 broken 时，将会生成新的一代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 栅栏是否破裂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ————————————————————— 构造方法 ————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化 parties、count、barrierCommand</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ————————————————————— await ————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主流程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 先获取锁</span></span><br><span class="line">    <span class="comment">// 如果是最后一个线程，叫醒其他线程</span></span><br><span class="line">    <span class="comment">// 如果不是最后一个线程，睡</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">// 最后一个线程会进入这个分支（count减到0）</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 由最后一个抵达的线程触发 Runnable</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">// 不带时间等待</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    <span class="comment">// 带时间等待</span></span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 CyclicBarrier 被打破了</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当最后一个线程抵达时，它会 signal 所有休眠线程，并重置 generation</span></span><br><span class="line">            <span class="comment">// 此时 generation 会变成新的一代，然后返回休眠前 count 的值</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤起所有 await 的线程，重置 count，重置 generation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ————————————————————— reset ————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 打破 generation，唤起所有休眠线程（唤起后将抛出 BrokenBarrierException）</span></span><br><span class="line">        breakBarrier();</span><br><span class="line">        <span class="comment">// 重置 generation 和 count</span></span><br><span class="line">        nextGeneration();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将本代设为 broken，唤起所有休眠线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————— */</span></span><br></pre></td></tr></table></figure>

<p>不细说了，简单到我上我也行（膨胀了膨胀了）。</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>Semaphore 直译是信号，这是个不太容易理解的名字，实际上它的作用更像是一个资源池。例如创建一个容量为 10 的 Semaphore，如果有超过 10 个线程过来，那么就只能阻塞，一直等到有之前的线程释放资源，让容量空出来一个，才可以再运行。</p>
<p>再回来看 Semaphore 的意思：信号。它指的是，给线程一个信号，告知线程资源数量是否足够，你是否可以运行，如果已经满员了，那么你只能在我内部的阻塞队列里排队等候。</p>
<p>画一张简图描述一下这个类的作用：</p>
<p><img src="/assets/Semaphore_diagram.jpg" alt="Semaphore_diagram"></p>
<p>Semaphore 类主要使用两个方法：<code>acquire()</code> 和 <code>release()</code>，前者是申请资源，后者是归还资源。但 <code>release()</code> 方法有点奇怪，即使并没有申请过资源也是可以调用的，而且它会无节制地使资源数 +1，甚至超过最初设置的资源数量。例如下面这四行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">semaphore.release();</span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure>

<p>初始化一个 Semaphore，容量设为 10，但是在 <code>release()</code> 了 3 次之后，容量变成了 13，可以同时有 13 个线程申请到锁然后运行。</p>
<br>

<p>这个类的代码跟 Condition 类有点类似，总体上讲还是比较容易的，直接看代码就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ———————————————————————— 基本信息 ———————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AQS 阻塞队列，老套路</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AQS 阻塞队列的构造方法，传 permits 进去，设为 AQS 的状态(state)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...(略)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平阻塞队列，老套路</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...(略)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公平阻塞队列，老套路</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...(略)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————— 构造方法 ———————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双参数构造函数</span></span><br><span class="line">    <span class="comment">// 前者 permits（即 AQS 的状态 state）</span></span><br><span class="line">    <span class="comment">// 后者是否公平</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单参数构造函数，默认非公平锁</span></span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————— acquire ———————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一次共享锁</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取共享锁（响应中断）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 试着获取一次共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果没获取到，</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * （公平锁）尝试获取共享锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果阻塞队列中，有节点排在自己前面</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 执行到这里时，自己就是最前面的节点</span></span><br><span class="line">        <span class="comment">// 获取 AQS 的状态</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">// 如果获取到锁，还剩多少资源可用</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">// 如果获取锁后资源够用，就 CAS 设置一遍（CAS 失败就循环重来）</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取锁，获取不到就阻塞，与 Condition 完全相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ———————————————————————— release ———————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本方法会为 AQS 的状态 +1，调用多少次就加多少次，永无上限（并不是最多 permits）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// AQS 状态 +1</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 AQS 的状态 +1（甚至会超过 permits）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试解锁，跟 Condition 完全一致</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————————————————————————————————— */</span></span><br></pre></td></tr></table></figure>

<hr>
<p>代码学习得很顺利，基本熟知了 JUC 框架的各种实现，但是不太理解为什么要这么设计，沉淀一段时间再回来想吧。</p>
<p>下周学习线程池。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC 初探</title>
    <url>/2020/05/27/IOC/</url>
    <content><![CDATA[<br>

<p>本文是对<a href="https://www.javadoop.com/post/spring-ioc" target="_blank" rel="noopener">《Spring IOC 容器源码分析》</a>的总结，我对照这篇文章和 Spring 源码进行学习之后，精要化出一些结论。如果时间紧迫可以参考本篇文章，如果时间充裕，更建议对照那篇文章过一遍源码（那篇文章写于2017年，和最新的源码稍有一点点出入，没关系）。</p>
<p>我之前写过一篇介绍 IOC 概念的文章，现在回看想掐死自己……一副什么都不懂却特别跳的样子，气人。</p>
<p>这里重新简要写一下 IOC 的概念：IOC 是控制反转（Inversion of Control）的缩写，控制指的是“控制对象的获得”，比如当需要一个对象的时候，怎么获得这个对象：</p>
<ul>
<li>常见的“控制”思路，是什么时候需要对象就什么时候 new 一个出来，对象没有创建就无法继续下去，“new 对象”控制了后续代码</li>
<li>“控制反转”的思路，是什么时候需要对象就什么时候向资源池要，因为代码需要，所以才向资源池要对象，后续代码控制了对象的获得。</li>
</ul>
<p>细品一下“控制对象的获得”这几个字就能理解了，可以简单理解为先后顺序。如果先 new 对象再写后续代码，或者是工厂方法获得对象，等等，都使得获取过程要靠自身实现，代码高耦合不便于维护。所以 IOC 的思想是资源由资源池管理，需要的时候让第三方资源池提供。</p>
<p>在 Spring 中 IOC 向资源池要对象，资源池指的是 <code>beanDefinitionMap</code>，这篇文章要学习的内容，就是 <code>beanDefinitionMap</code> 加载资源的初始化过程，也就是 Bean 读取和装载的过程。</p>
<p>（尽管现在使用 IOC 都是通过注解 @AutoWired，但本文仍以最原始的解析 xml 文件来展开。）</p>
<hr>
<p>通过 <code>ClassPathXmlApplicationContext</code>，将 xml 文件解析成一个个的 Bean，只需要一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br></pre></td></tr></table></figure>

<p>这个构造方法实际上是在调用另一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个构造方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(parent);</span><br><span class="line">   <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">   setConfigLocations(configLocations);</span><br><span class="line">   <span class="comment">// 核心方法</span></span><br><span class="line">   <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 <code>ClassPathXmlApplicationContext</code>，主要就是在调用 <code>refresh()</code> 方法，叫 refresh 的原因是它会销毁原来的 ApplicationContext，用以重建。这个方法海纳百川，内容量爆炸，我们只看前三个方法（足够理解 IOC 了）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 加锁，否则 refresh() 没结束，又来一次 refresh() 就出事了</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备（包括记录启动时间、设置”已启动“状态，处理配置文件的占位符）</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 创建 Bean 工厂（包括初始化 BeanFactory、加载 Bean、注册 Bean 等）</span></span><br><span class="line">      <span class="comment">// 这一步结束时，Bean 实例尚未创建</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们今天的重点，是第二个方法创建 BeanFactory（<code>obtainFreshBeanFactory()</code>），这个方法能往里扒快 20 层，主要功能是创建 BeanFactory、从 xml 文件中读取信息并解析成多个 BeanDefinition、把所有 Bean 注册到 <code>beanDefinitionMap</code> 中。</p>
<p>但是我们还是从第一个方法开始。</p>
<hr>
<h1 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a>prepareRefresh()</h1><p>记录时间、状态、校验数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录启动时间</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">// 设置“已启动”状态（这两个都是 AtomicBoolean 类型）</span></span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打日志</span></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         logger.debug(<span class="string">"Refreshing "</span> + getDisplayName());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 处理配置文件的占位符（默认空实现，交由子类）</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验配置文件（比如校验 xml 配置文件）</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Store pre-refresh ApplicationListeners...</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Reset local application listeners to pre-refresh state.</span></span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">      <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Allow for the collection of early ApplicationEvents,</span></span><br><span class="line">   <span class="comment">// to be published once the multicaster is available...</span></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过。</p>
<hr>
<h1 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory()"></a>obtainFreshBeanFactory()</h1><p>这个方法会创建 Bean 工厂，注册 Bean，是最为重要的一个方法。</p>
<p>我在看博文和源码时，是边学习边截图代码用 PS 拼图的，本想把这部分代码整理成一张大图，结果里面有二十多个子方法，一层层剥进去十几层，PS 画布长八米多……因此用图片做直观学习是不太现实了。</p>
<p>本方法按顺序依次实现了下面这些内容：</p>
<ol>
<li>销毁旧的所有 Bean，关闭旧的 BeanFactory</li>
<li>创建一个新的 BeanFactory</li>
<li>经过一系列步骤，读取 xml 配置文件</li>
<li>解析 Bean 定义，生成一个个的 BeanDefinition 的实例</li>
<li>根据名字，把所有的 Bean 注册在 beanDefinitionMap 里</li>
<li>注册事件等后续</li>
</ol>
<p>按照顺序一点点把代码搬上来。</p>
<h2 id="1-销毁旧的-Bean-和-BeanFactory"><a href="#1-销毁旧的-Bean-和-BeanFactory" class="headerlink" title="1. 销毁旧的 Bean 和 BeanFactory"></a>1. 销毁旧的 Bean 和 BeanFactory</h2><p>如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory（这里销毁的是当前 ApplicationContext 的旧 BeanFactory ，BeanFactory 是可以多个的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* AbstractRefreshableApplicationContext.java</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 已经加载过 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      <span class="comment">// 销毁所有 Bean</span></span><br><span class="line">      destroyBeans();</span><br><span class="line">      <span class="comment">// 关闭 BeanFactory</span></span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-创建一个新的-BeanFactory"><a href="#2-创建一个新的-BeanFactory" class="headerlink" title="2. 创建一个新的 BeanFactory"></a>2. 创建一个新的 BeanFactory</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// ...（销毁旧的 Bean 和 BeanFactory）</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 BeanFactory，默认指定 DefaultListableBeanFactory</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建的新的 BeanFactory 类型是 DefaultListableBeanFactory，<code>createBeanFactory()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactory 的继承关系如图（图片源于学习博文）：</p>
<p><img src="/assets/BeanFactory.png" alt="BeanFactory"></p>
<p>从继承关系可以看到，这个 DefaultListableBeanFactory 是所有 BeanFactory 的集大成者，实现了</p>
<ul>
<li>可以获取多个 Bean（最顶层 BeanFactory 接口的方法都是获取单个 Bean 的）</li>
<li>可以将各个 BeanFactory 设置为父子关系</li>
<li>可以自动装配 Bean（Autowire）</li>
</ul>
<p>在创建了一个 BeanFactory 之后，紧接着给它设置了三个属性（代码不贴了）：</p>
<ul>
<li>设置序列化 ID（使用 applicationContext 的 ID）</li>
<li>设置是否允许 BeanDefinition 覆盖</li>
<li>设置是否允许循环引用</li>
</ul>
<p>BeanDefinition 覆盖的默认配置是：在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。循环引用的意思是：A 依赖 B，而 B 依赖 A；或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>
<h2 id="3-经过一系列步骤，读取-xml-配置文件"><a href="#3-经过一系列步骤，读取-xml-配置文件" class="headerlink" title="3.  经过一系列步骤，读取 xml 配置文件"></a>3.  经过一系列步骤，读取 xml 配置文件</h2><p>这块我都不想贴代码了，一系列步骤的意思就是一系列步骤，往里扒到吐血的那种。</p>
<p>总体上走了这些流程（这些都是指读取 xml 数据）：</p>
<ol>
<li>创建一个 XmlBeanDefinitionReader 并设置参数，用于读取 xml 数据</li>
<li>读取 Resource[] 资源数组，遍历逐一处理</li>
<li>把 Resource 包装成 EncodedResource</li>
<li>创建一个 Set（ThreadLocal），逐一装入 EncodedResource，检查是否重复加入</li>
<li>将 EncodedResource 读出 InputStream，再转换成 InputSource</li>
<li>将 InputSource 转换成 Document（是 w3c 定义的接口，代表着 xml 的节点）</li>
<li>创建 DocumentReader，用以解析 Document（实际上是解析 Document 中的 Element）。</li>
<li>DocumentReader 内部创建了 BeanDefinitionParserDelegate，用以负责解析 Bean 定义</li>
<li>解析 Bean 定义（看下一部分），并最终将所有的 Bean （实际上是 BeanDefinition）都装入到 BeanFactory 的 beanDefinitionMap 中，这是一个 ConcurrentHashMap。</li>
</ol>
<h2 id="4-解析-Bean-定义"><a href="#4-解析-Bean-定义" class="headerlink" title="4. 解析 Bean 定义"></a>4. 解析 Bean 定义</h2><p>在经过一系列的流程之后，终于将 xml 资源转换成一个个的 Element，这是 w3c 定义的类，在此对应着 xml 文件中的各个节点。</p>
<p>xml 文件中有很多类型的节点，比如 <code>&lt;bean /&gt;</code>、<code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code> 等。默认的 Element 只有四种：<code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code> 和 <code>&lt;beans /&gt;</code>，这是 <code>xmlns=&quot;http://www.springframework.org/schema/beans&quot;</code> 定义的，也就是默认的命名空间（default namespace），如果想要解析别的类型，需要增加额外的命名空间。</p>
<p>解析这四种默认的 Element 是采用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签定义</span></span><br><span class="line">      <span class="comment">// &lt;alias name="fromName" alias="toName"/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义，这是我们关注的地方</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只关注处理 <code>&lt;bean /&gt;</code> 标签定义，也就是 <code>processBeanDefinition()</code> 方法。</p>
<p>这个方法实际上是把 xml 中的 bean 信息解析成 BeanDefinition，然后再包装成 BeanDefinitionHolder，最终注册到 BeanFactory 中的 beanDefinitionMap 中。</p>
<h2 id="4-5-Bean-是什么"><a href="#4-5-Bean-是什么" class="headerlink" title="4.5 Bean 是什么"></a>4.5 Bean 是什么</h2><p>学习到这里要停一下，来探讨一下 Bean 到底是个什么东西。从代码层面上讲，Spring 中的 Bean，可以简单认为是 BeanDefinition 的实例，BeanDefinition 中保存了 Bean 的信息，比如 Bean 指向的是哪个类、是否是单例的、是否懒加载等等。</p>
<p>再梳理一下关系：</p>
<ul>
<li><p>ApplicationContext 内部持有一个实例化的 BeanFactory（默认是 DefaultListableBeanFactory），以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
</li>
<li><p>BeanFactory 也就是 Bean 容器，它存放着 Spring 中的所有 Bean，存放的方式是用一张 map 存所有的 BeanDefinition（Bean 定义），在 DefaultListableBeanFactory 类中有一个 beanDefinitionMap 变量，就是那张存放所有的 Bean 定义的 map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory.java  181行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>也就是说，解析 xml，实际上就是把 xml 中的所有 Bean 信息都转换成 BeanDefinition 实例，然后存储在 beanDefinitionMap 中。</p>
</li>
</ul>
<p>来看一下 BeanDefinition 接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 默认只有两种：SINGLETON、PROTOTYPE</span></span><br><span class="line">   <span class="comment">// 作用域：单例</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   <span class="comment">// 作用域：多例（每次获取 Bean 都会生成一个新的实例）</span></span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 据说不重要，略</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* ———————————————— 以下都是一些 get()、set() 方法 ———————————————— */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 父 Bean（Bean 继承 =&gt; 继承父 Bean 的配置信息）</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String parentName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 的作用域</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 是否懒加载</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 依赖的所有的 Bean（不是属性依赖，是 depends-on="" 属性设置的值）</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否可以注入到其他类型</span></span><br><span class="line">   <span class="comment">// 当注入是根据类型注入时，该设置有效，否则无效，例如根据名称注入无效，都能注入</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同一个 BeanDefinition 接口的多个实现</span></span><br><span class="line">   <span class="comment">// 如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称</span></span><br><span class="line">   <span class="comment">// Bean 可以反射创建，也可以工厂方法创建，这里就是指定工厂</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂方法名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* ———————————————— 下面这些懒得写了 ———————————————— */</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-（继续）解析-Bean-定义"><a href="#4-（继续）解析-Bean-定义" class="headerlink" title="4. （继续）解析 Bean 定义"></a>4. （继续）解析 Bean 定义</h2><p>回来，来看通过解析 xml 得到的一个个 Element，是怎么转换成 BeanDefinition 实例的。</p>
<p>上面说到，从 Element 解析成 BeanDefinition 实际上是这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">   processBeanDefinition(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>跟进去看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有自定义属性的话，进行相应的解析</span></span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共做了三件事：</p>
<ol>
<li>把 Element 解析成 BeanDefinitionHolder</li>
<li>把 BeanDefinitionHolder 中的 BeanDefinition 加入到 Bean 容器的 map 中（注册 Bean）</li>
<li>发送事件</li>
</ol>
<p>我们先只看第一步，把相关代码贴上来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 顺便提下，这里的 Element 是 w3c 定义的，对应一个个 xml 的节点</span></span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE); <span class="comment">// id</span></span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); <span class="comment">// name</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，转成 aliases 列表</span></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// StringUtils.hasLength() 是在判断非空</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果没有指定 id, 那么用 aliases 列表的第一个名字作为 beanName，并在 aliases 中删掉第一个名字</span></span><br><span class="line">   <span class="comment">// 例如 &lt;bean name="m1, m2, m3" class="com.pz.example.MessageServiceImpl" /&gt;</span></span><br><span class="line">   <span class="comment">// id(beanName)：m1  aliases：m2、m3</span></span><br><span class="line">   String beanName = id;</span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果解析的是 Bean，不包含子 Bean</span></span><br><span class="line">   <span class="comment">// 这里会是 null，然后检查一下 id、aliases、ele 是否是非空，再记录一下新增信息</span></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中</span></span><br><span class="line">   <span class="comment">// 这行结束后，一个 BeanDefinition 实例就出来了，具体怎么做的跟进去看</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果没有 id(beanName)，会进入下面这段代码</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 没有子 Bean，containingBean 是 null，跳过</span></span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果不定义 id 和 name，那么按照刚才的举例</span></span><br><span class="line">               <span class="comment">// 1. beanName 为：com.pz.example.MessageServiceImpl#0</span></span><br><span class="line">               <span class="comment">// 2. beanClassName 为：com.pz.example.MessageServiceImpl</span></span><br><span class="line">               beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">               logger.trace(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 Bean 的类名和父 Bean</span></span><br><span class="line">    String className = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    String parent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">        parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据 className 和 parent 创建 BeanDefinition</span></span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">        error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很长很繁琐，将 Element 中的信息转换成了 BeanDefinition，其中最重要的是设置 BeanDefinition 的 beanName，也就是 Bean 的 ID。</p>
<p>至此，xml 中的一个节点，就被解析成了一个 BeanDefinition 实例（是一个）。</p>
<h2 id="5-注册-Bean-到-beanDefinitionMap-里"><a href="#5-注册-Bean-到-beanDefinitionMap-里" class="headerlink" title="5. 注册 Bean 到 beanDefinitionMap 里"></a>5. 注册 Bean 到 beanDefinitionMap 里</h2><p>当获取到一个 BeanDefinition 实例之后，需要把这个实例注册到 Bean 容器里，也就是加入到 BeanFactory 中的 beanDefinitionMap 里。</p>
<p>这一步发生在从 Element 解析到 BeanDefinition 的第二步（往上翻 <code>processBeanDefinition()</code> 方法，没多远），也就是说，注册 Bean 实际上是在解析 xml 时一并完成的，刚获取到一个 BeanDefinition 实例，就直接把这个实例加入到 beanDefinitionMap 里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 注册 Bean</span></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 往后看</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">         <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 校验</span></span><br><span class="line">    Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                                                   <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有的 Bean 注册之后都会放在 beanDefinitionMap 里（这是个 ConcurrentHashMap）</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="comment">// 处理重复名称的 Bean 定义的情况（说的是 Bean 循环引用覆盖）</span></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不允许重复，抛异常</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面分情况打日志，表明在不同情形下发生了 Bean 覆盖</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                            <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                            existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                             <span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                             <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">                logger.trace(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                             <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                             <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Bean 覆盖</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">        <span class="comment">// 注意，"注册Bean" 这个动作结束，Bean 依然还没有初始化</span></span><br><span class="line">        <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// 为了迭代器正常，这里需要加锁锁住 beanDefinitionMap</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                removeManualSingletonName(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 最正常的应该是进到这个分支</span></span><br><span class="line">            <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="comment">// 这是在处理手动注册的 singleton bean（我们一路走来并没有碰过）</span></span><br><span class="line">            <span class="comment">// 如 "environment"、"systemProperties" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">            removeManualSingletonName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它</span></span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isConfigurationFrozen()) &#123;</span><br><span class="line">        clearByTypeCache();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="prepareBeanFactory-beanFactory"><a href="#prepareBeanFactory-beanFactory" class="headerlink" title="prepareBeanFactory(beanFactory)"></a>prepareBeanFactory(beanFactory)</h1><p>看不太明白，抄一下代码和注释吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span></span><br><span class="line">   <span class="comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置 PropertyEditorRegistrar</span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span></span><br><span class="line">   <span class="comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span></span><br><span class="line">   <span class="comment">// Spring 会通过其他方式来处理这些依赖</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span></span><br><span class="line"><span class="comment">    * 之前我们说过，"当前 ApplicationContext 持有一个 BeanFactory"，这里解释了第一行。</span></span><br><span class="line"><span class="comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span></span><br><span class="line"><span class="comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span></span><br><span class="line"><span class="comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span></span><br><span class="line">   <span class="comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span></span><br><span class="line">   <span class="comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面几行代码我们可以知道，Spring 往往很 "智能" 就是因为它会帮我们默认注册一些有用的 bean，</span></span><br><span class="line"><span class="comment">    * 我们也可以选择覆盖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>到此为止，我们看完了 <code>refresh()</code> 的三个方法，Spring 已经解析并注册了所有 Bean，设置好了 BeanFactory，但是还没有真正实例化 Bean，创建 Bean 实例在 <code>finishBeanFactoryInitialization()</code> 方法中完成，本篇就先不继续学习了，到此为止。</p>
]]></content>
      <tags>
        <tag>Random Post</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Cloud 入门</title>
    <url>/2019/10/08/Spring-Cloud/</url>
    <content><![CDATA[<br>

<p>十月的第二周，来学习 Spring Cloud 。</p>
<p>Spring Cloud 在我眼里是一套东拼西凑攒出来的框架，学这个框架学的都是一个个分散的零件。</p>
<hr>
<p>一切讲 Spring Cloud 教程的视频、书籍、博客，都是从微服务讲起的。讲技术之前先讲思想，来暗示技术的存在合理性。</p>
<p>微服务是个软件架构概念，一个大项目应该拆成多个小项目，各个小项目独立部署，松散耦合，各自实现小业务功能。微服务的对立面是单体式应用程序，一个应用程序内包含了所有需要的业务功能。</p>
<p>我理解的 Spring Cloud，是一个管理微服务的工具集。工具集，工具之集合也，意即 Spring Cloud 不是一个东西，而是一堆东西，它就是一个个分散的工具合在一起的总称。就像是下图展示的这样，Spring Cloud 是由 Eureka、Ribbon、Feign 等一个个零碎的组件组成的，学习 Spring Cloud 也应该是一个个逐个学习的。</p>
<p><img src="/assets/SpringCloud%E4%BD%93%E7%B3%BB.png" alt="SpringCloud体系"></p>
<p>（这张图是我在 B 站的一个教学视频《<a href="https://www.bilibili.com/video/av55304977" target="_blank" rel="noopener">Spring Cloud 从入门到实战</a>》中，讲者所认为的 Spring Cloud 框架。BTW：我认为这个教学视频讲得很出色。）</p>
<br>

<p>Spring Cloud 这么多组件，大部分都是 netflix 提供的开源组件，导包的时候就能发现，artifactId 总是 <code>spring-cloud-netflix- ……</code>。我初看到 netflix 还有点惊讶，毕竟这是网飞的英文原名，但我还是以为这是重名巧合，后来反复去查才发现，这真的就是那家做在线视频的网飞公司。</p>
<p>总有知名品牌搞跨界来颠覆我的认知，网飞搞微服务架构技术给我的感觉，就像是卖轮胎的米其林给人推荐餐厅一样，怎么就没听说爱奇艺去做开源编程组件的……</p>
<br>

<p>我自知 Spring Cloud 是一套框架的内容，其包含的一个个组件是有整合过的，不是真的分散毫无关联的，但我依旧认为，在学习时把 Spring Cloud 理解成一个个分散的组件，是能更高效理解的方式。下文的内容，也是一个个分开来写的。</p>
<hr>
<p>我认为微服务是一种很容易理解的架构，大项目分而治之。但是 Spring Cloud 的组件实在是有点多，为了方便理解，我还是举一个现实情景好了。</p>
<p>我觉得微服务就是个智能家居系统，如果有一个家用电器，能够同时看电视、洗衣服、吹空调、冰鲜食物等等（<font color="#32CD32">单体式应用程序</font>），还是一件比较恐怖的事情，我们比较希望的事情是，电视是电视、洗衣机是洗衣机、空调是空调……每个家用电器做自己的事情（<font color="#32CD32">微服务</font>）。</p>
<ol>
<li>为了实现智能家居的效果，我们买了一个智能音箱（<font color="#32CD32">Zuul</font>），对智能音箱喊，智能音箱帮我们去做事情。</li>
<li>当然，这个的前提是，家电和智能音箱连在同一个局域网里，智能音箱能找到家电（<font color="#32CD32">Eureka</font>）。</li>
<li>我们的家电之间还要能互动（<font color="#32CD32">Feign</font>），比如红外线感应器感应到我回家了，空调就自动打开。</li>
<li>当我们有多个相同的家电时，要合理分配（<font color="#32CD32">Ribbon</font>），比如有两个扫地机器人，要让两个分开扫屋子。</li>
<li>当家电出故障时，要及时做出调整（<font color="#32CD32">Hystrix</font>），比如空调坏了，智能音箱就不要一直让空调调温度了。</li>
<li>此外还要配置家电使用时段等信息（<font color="#32CD32">Config</font>），监控家电（<font color="#32CD32">Actuator</font>），查询家电是为何而工作（<font color="#32CD32">Zipkin</font>）等等。</li>
</ol>
<p>你能感受出来，Spring Cloud 就是一套协调微服务正常运行的框架。</p>
<hr>
<p>学习 Spring Cloud 至少要有一点点的 Spring Boot 的基础，因为 Spring Cloud 这个框架是基于 Spring Boot 的，里面每个组件的配置过程，其实都是 Spring Boot 的内容，所以我们要先了解一下，Spring Boot 是怎么使用的。</p>
<p>Spring Boot，boot 这个词用得真是传神，你去查 boot 的意思，它有一个动词词性的释义：（计算机）启动、操作系统已安装。什么意思呢，就是说 Spring Boot 是一个帮你配好 Spring 几乎所有配置的框架，你使用它，相当于直接配好了所有东西，拿来就直接用。</p>
<p>对 Spring 没有任何了解，上来就看 Spring Boot 的人，可能并不理解程序员为何如此吹捧它，好像它实现的功能也就那么一回事。有这种感觉，是因为不清楚 Spring 的配置过程有多么繁琐，基本可以用“配置地狱”来形容。Spring Boot 的出现，是为了解决 Spring 配置过于复杂的痛点。写代码时你引了个包，加了个注解，实现了一个功能，看上去平平无奇，这个平平无奇就是 Spring Boot 的作用。</p>
<br>

<p>我们今天学习的是 Spring Cloud，由于它基于 Spring Boot，因此在配置方面，我们其实是在学习 Spring Boot 。</p>
<p>Spring Boot 使用起来可以简单地分两步走：</p>
<ol>
<li>添加第三方依赖。</li>
<li>注解声明，我要使用 Spring Boot 啦。</li>
</ol>
<p>第一步：添加第三方依赖。我采用 maven 来管理第三方依赖，maven 是一个管理项目的工具，对此我也基本处于小白状态，只是知道它可以用 xml 文件的形式来配置，以及简单地写写。</p>
<p>添加第三方依赖对于 maven 来讲是件很容易的事情，在 <code>dependencies</code> 中添加上需要的依赖就可以了。例如我要使用 Spring Cloud 其中一个组件 Eureka，我只需要在 Eureka 服务端的 <code>pom.xml</code> 文件中，添加这么一点代码。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>                <span class="comment">&lt;!-- 全球唯一标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- 构件标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>                            <span class="comment">&lt;!-- 版本号（自动，无需填写） --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：注解声明要使用 Spring Boot。这一步在启动类中添加，启动类怎么说呢，可以认为是新建完工程模块之后，唯一的那个 <code>java</code> 文件里面的类，哎呀我也道行不够，反正就这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种是一种通用写法，是在声明这个类是一个 Spring Boot 的启动类。如果更具体一些，例如我要使用 Spring Cloud 中的 Eureka 组件，要声明某个类是服务端，就要多加个注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于 <code>@SpringBootApplication</code> 等这些注解是怎么工作的，<code>main</code> 方法里面的 <code>SpringApplication.run()</code> 方法在干什么，这个就要自己去看 Spring Boot 的内容了。</p>
<br>

<p>Spring Boot 在设计之初就有一种理念，即“约定大于配置”，意思是说，我们约定好了就用某种方式来配置。比如说原来一个程序，里面有 A、B、C 三个地方要配置，A 有 5 种配置方法，B 有 3 种，C 有 4 种，这一排列组合就有 60 种配置方式，但是你得 A、B、C 一个个地手动配，大家都配烦了，这时 Spring Boot 配好了其中一种，说既然这种使用得最多，也就别一个个地配了，就用这种吧。Spring Boot 的代码，在字里行间中就有这种约定俗成的“潜规则”感，例如启动类起名都叫 <code>xxxApplication.java</code> ，别问，问就是约定俗成。但是潜规则这种东西，说不清道不明的，还是得自己多试试脾气。</p>
<hr>
<h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p>Eureka 是 Spring Cloud 的头号组件，它的使用方法也代表了 Spring Cloud 中组件的一般使用方法，所以我们借着 Eureka 来学习，Spring Cloud 一般是如何配置和使用的。但是在此之前，我们先要知道 Eureka 是做什么的。</p>
<p>Spring Cloud 是一种微服务架构，比如说原来一个项目实现 15 个功能点，现在这 15 个功能点拆分成 10 个小项目，由这 10 个小项目组合起来作为一个微服务大项目。如果用图示可能会更直观一些：</p>
<p><img src="/assets/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="微服务示意图"></p>
<p>这是我认为的微服务架构示意图，像是局域网一样采用星型拓扑结构，每一个小黑点代表一个微服务，联结起来组成一个微服务群。</p>
<p>Eureka 正如上图中的黑线，它的作用是把一个个分散的微服务联结起来，让这些微服务组成一个集群，让每个微服务都能“登记在册”。</p>
<br>

<p>Eureka（音标 [juˈriːkə] ），用更为专业的术语来描述它，应该称它为“服务的注册和发现中心”，服务就是微服务，注册就是让一个个的微服务登记在册，发现就是在登记册中找到这一个个服务。</p>
<p>再换句话说，每个微服务，都要到 Eureka 那里签到（注册），要找服务的话，也要去 Eureka 那里去找（发现），也就是说，Eureka 是微服务的中介中心。</p>
<p>说来 Eureka 这个词还有点美式幽默，它是阿基米德发现浮力定律后兴奋地在大街上裸奔，边跑边喊“知道了！我知道了！”的那个词，当时的含义是“我终于找到浮力定律了！”。在微服务框架中，Eureka 的含义是“啊我发现这个服务了”，即代表某个服务在中心注册过了，也代表在中心找到了这个服务，颇有幽默意味。</p>
<br>

<p>Eureka 组件中有两种角色：服务端、客户端。如果用上张图来解释这两种角色，那么服务端是灰点，客户端是黑点，黑点（客户端）注册到灰点（服务端）之后，每次可以通过灰点找到黑点。其实呢这是一个 <code>C/S 架构</code>，Eureka 就是一个基于 <code>C/S 架构</code>而设计出来的组件。</p>
<p>现在我们来思考一下，如何使用 Eureka。我们通过 Eureka，目标是实现【把一个个微服务登记在册，以备用时查找】，加以思索会发现，Eureka 的功能是【服务注册和服务发现】这样很通用的功能，对于不同的微服务、不同的项目，功能也是一样的。我们并不需要改变功能，而应该改变例如 IP 地址、端口号等等的配置信息。也就是说，【功能】和【配置】是分开的，对于【功能】，所有的微服务都是一样的，既然都是一样的那就让框架去写，我们只写【配置】。</p>
<p>Spring Cloud 的组件使用起来基本都是这样子，你并不需要写代码，只需要写一写配置文件就可以了。</p>
<br>

<p>我们来看看，Eureka 的配置文件怎么写吧。</p>
<p>Spring Cloud 所有组件的配置文件，都可以在 resource 目录下创建一个 <code>application.yml</code> 的 yml 文件。刚才说了 Eureka 分为服务端和客户端，那么分开看：</p>
<p>Eureka 的服务端配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span>                      <span class="comment"># 服务的端口号（Eureka 默认使用 8761 端口）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">pz-eureka-server</span>        <span class="comment"># 服务的名字</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>   <span class="comment"># 将当前的server作为client注册</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span>         <span class="comment"># 获取其他server的数据</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">     defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span>    <span class="comment"># 注册中心的访问地址</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span>               <span class="comment"># 关闭自我保护机制</span></span><br><span class="line"><span class="attr">    eviction-interval-timer-in-ms:</span> <span class="number">5000</span>           <span class="comment"># 每隔 5 秒清理失效服务</span></span><br></pre></td></tr></table></figure>

<p>Eureka 的客户端配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr"> port:</span> <span class="number">5750</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr"> application:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pz-eureka-client</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr"> client:</span></span><br><span class="line"><span class="attr">  service-url:</span></span><br><span class="line"><span class="attr">   defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span>   <span class="comment"># 注册中心的访问地址</span></span><br><span class="line"><span class="attr"> instance:</span></span><br><span class="line"><span class="attr">  prefer-ip-address:</span> <span class="literal">true</span>      <span class="comment"># 把当前服务的ip注册到eureka的server</span></span><br></pre></td></tr></table></figure>

<p>照着配，用的时候再去理解。yml 文件是一种更人性化的配置文件格式，它采用 YAML 语言来编写，看一眼主要特征也就看出来了：靠缩进来表示层级。</p>
<p>差点忘了讲，代码中还是要写一行的，加一行注解，表示自己要使用 Eureka 组件。这行注解就加在上文提 Spring Boot 时，启动类的上方，写在 <code>@SpringBootApplication</code> 注解旁边：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span>      <span class="comment">// 就是这行注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eureka 服务的注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是服务端，那么注解是 <code>@EnableEurekaServer</code>，如果是客户端，那么连注解都不用加。</p>
<br>

<p>我们其实相当于说完了 Eureka，只不过非常潦草，那回头来多看一看 Eureka 这个组件。Eureka 是 Spring Cloud 这一微服务框架的注册和发现中心，它专注的事情是一项历史悠久的内容：服务发现。我查询了相当长时间的资料，觉得目前的学习阶段，对于服务发现这一内容还是浅尝辄止为好：服务发现有两种模式，一种是【客户端发现模式】，一种是【服务端发现模式】，Eureka 属于前者。</p>
<p>关于 Eureka 的最基本原理，要知道的有这么几条：</p>
<ol>
<li>Eureka 采用 C/S 架构。</li>
<li>Eureka 的客户端向服务端不停地发送心跳，来保持自己的注册状态，如果不发送了，服务端会移除它。</li>
<li>Eureka 的服务端有自我保护机制，此时会认为网络本身有问题，不移除服务。</li>
</ol>
<p>推荐下面三篇文章一读：</p>
<p><a href="https://martian101.github.io/2017/04/20/微服务之服务发现-Eureka的介绍与使用/" target="_blank" rel="noopener">《微服务之服务发现 Eureka 的介绍与使用》</a></p>
<p><a href="https://www.cnblogs.com/chihirotan/p/11366394.html" target="_blank" rel="noopener">《作为服务注册中心，Eureka 比 Zookeeper 好在哪里》</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">《CAP 定理的含义》</a></p>
<br>

<hr>
<h1 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h1><p>Zuul 是 Spring Cloud 的服务网关，能够实现动态路由、IP 过滤、数据监控等功能，并内部集成负载均衡功能，不过我们今天只看动态路由这一个功能。</p>
<br>

<p>了解 zuul 的作用，我们要先知道什么是网关（Gateway）。我理解的网关（这里的网关，可以更确切地叫做 API 网关）是一个入口，入口之外是用户，入口之内服务系统，用户并不需要知道系统内部是什么样子，用户只想完成功能，那么这时让网关去处理，用户走到网关面前，跟网关说我要做什么，网关就带用户过去。</p>
<p>这里说入口之外是用户，是一个场景化的说法，其实也不一定是用户，比如 A 服务想调用 B 服务，也可以通过网关来调用。维基对于网关的解释是“ 网关是转发其他服务器通信数据的服务器 ”，但我觉得也不是很易懂，可能网关这个概念就是难表述一些，但其实是一件很常见的功能。</p>
<p><img src="/assets/api_gateway.png" alt="api_gateway"></p>
<p>zuul 是 Spring Cloud 的 API 网关组件，实现服务网关的功能。</p>
<p>举一个很简单的例子：比如有一个服务叫 serviceA，这个服务的 url 地址是 <code>http://localhost:8001/</code>，还有一个服务叫 serviceB，它的 url 地址是 <code>http://localhost:8002/</code>，两个服务的 url 地址的区别在于端口号不同，如果调用的话是一件很糟糕的事情，因为既不便于识别，也不便于维护。这里只有两个服务，若是上百个，那真的是很折磨人。通过 zuul，可以通过新的 url 来访问服务，比如通过 <code>http://localhost:8000/A</code> 访问 serviceA，再通过 <code>http://localhost:8000/B</code> 访问 serviceB，这样就很直观，也很便捷。</p>
<p>你应该看出来了网关（尤其是 API 网关）的入口作用，它把控了内外的通道，使得【外部访问 -&gt; 网关 -&gt; 内部服务】。上述只写了网关可以实现动态路由的功能，其实既然把控了入口，也完全可以做 IP 过滤、数据监控等等的功能。但是我们今天只关注动态路由这个功能，也就是上面例子中的变更访问 url 地址。</p>
<br>

<p>我们来看一下 zuul 的配置文件，我写了一则示例放在下面：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">5752</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">pz-zuul</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka</span></span><br><span class="line"></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    pz-eureka-client:</span> <span class="string">/client/**</span></span><br></pre></td></tr></table></figure>

<p>你定睛一看，发现这个配置文件一共配了四个块，前三个块都是 Spring Cloud 的通用配置内容：服务端口号、服务名、服务中心，只有第四个块，配置到了 zuul，而且只配置了一项内容。</p>
<p>配置的这项内容是，把服务名为 <code>pz-eureka-client</code> 的服务，路由到一个新的 url 地址上（** 代表任意 url）：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">http://localhost:5752/client/**</span></span><br></pre></td></tr></table></figure>

<p>何其简单呐！</p>
<p>这一次启动类的注解是 <code>@EnableZuulProxy</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zuul 服务的注册</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ZuulApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>好吧，上面的配置文件简单，是因为 zuul 的那么多网关功能，只用到【路由】，其他功能都没有用 :P 。而且设置路由的时候，还使用了省略写法。我们首先把路由的不省略的写法写出来：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 省略写法</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    pz-eureka-client:</span> <span class="string">/client/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非省略写法</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    pz-eureka-client:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/client/**</span>             <span class="comment"># 路径规则</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">pz-eureka-client</span>  <span class="comment"># 服务名，当和routes后的名字同名时可以省略</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://localhost:8000</span>   <span class="comment"># 指定url，这个和 serviceId 任选其一使用，但是这种方式无法实现负载均衡</span></span><br></pre></td></tr></table></figure>

<p>zuul 的配置还有一些别的可讲的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 路由前缀</span></span><br><span class="line"><span class="attr">zuul:</span> </span><br><span class="line"><span class="attr">  routes:</span> </span><br><span class="line"><span class="attr">    pz-eureka-client:</span> <span class="string">/client/**</span></span><br><span class="line"><span class="attr">    prefix:</span> <span class="string">/api</span>                   <span class="comment"># 设置统一的路由前缀 本例中网关访问 /api/client/**</span></span><br><span class="line"><span class="attr">    strip-prefix:</span> <span class="literal">false</span>            <span class="comment"># 表示不要把代理的前缀去掉，否则网关访问 /api/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略（即不创建路由规则）</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  ignored-services:</span> <span class="string">eureka-client</span>  <span class="comment"># 忽略服务，本例是忽略名为 eureka-client 的服务</span></span><br><span class="line"><span class="attr">  ignored-patterns:</span> <span class="string">/**/hello/**</span>   <span class="comment"># 忽略url路径，本例是忽略所有包含 /hello/ 的路径</span></span><br></pre></td></tr></table></figure>

<br>

<hr>
<h1 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h1><p>Ribbon 是 Spring Cloud 中负责负载均衡的组件。负载均衡，字面意思是指把负载合理地分摊出去，例如我们设计好了一个网站，后端有十台服务器，怎么能让十台服务器同时合理工作，而不出现有一台跑死、剩下九台闲死的状况，就是负载均衡的目标。维基对于负载均衡作用的阐释很得我心：</p>
<blockquote>
<p> 主要作用是将大量作业合理地分摊到多个操作单元上进行执行，用于解决互联网架构中的高并发和高可用的问题。 </p>
</blockquote>
<p>在微服务架构中，某个服务部署了多个是个常见的情况，那么当另一个服务需要调用这好几个同一服务时，该如何调用就是一个负载均衡的问题，Ribbon 的作用就是解决这个调用时的负载均衡问题。例如有 5 台服务器在同时运行 A 服务，B 服务该怎么调用 A 服务，是随机挑一个调用，还是找最闲的服务器调用，还是指定哪一台调用，这是个负载均衡的问题，需要 Ribbon 组件来处理。</p>
<br>

<p>下面该讲 Ribbon 的配置了，讲到现在是第三个组件，你应该发现，Spring Cloud 的配置通常是非常简单的。但 Ribbon 尤其过分，你甚至都可以不用配置 <code>application.yml</code> 文件，写一个注解就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RibbonApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RibbonApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>    <span class="comment">// @LoadBalanced 声明基于Ribbon的负载均衡</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的位置不再是启动类之上，而放在了 RestTemplate 类之上。RestTemplate 类是 Spring 框架发起 HTTP 请求的一个类，它在服务中采用 RESTful 风格（RESTful 风格自己去查）与 HTTP 服务进行通信，简化了操作，用后就会觉得非常优雅。</p>
<p>调用服务的时候，实际上也就是在发送 HTTP 请求，因此如果在调用服务时考虑负载均衡的问题，就要在发送 HTTP 请求的类—— RestTemplate 类上添加注解，加上 <code>@LoadBalanced</code>。</p>
<br>

<p>不用配置 yml 文件的原因是，ribbon 默认采用的负载均衡规则为轮询（轮流访问服务器），如果你想使用别的负载均衡规则，那还是要配置一下，例如：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pz-eureka-client:</span>  <span class="comment"># 要调用的服务的服务名（需要负载均衡的那个）</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span>  <span class="comment"># 随机选择</span></span><br></pre></td></tr></table></figure>

<p>下面是 ribbon 的负载均衡策略说明，来源：<a href="https://www.e-learn.cn/content/qita/2212784" target="_blank" rel="noopener">《ribbon负载均衡策略》</a></p>
<table>
<thead>
<tr>
<th align="left">类</th>
<th align="left">中文</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">RandomRule</td>
<td align="left">随机策略</td>
<td align="left">随机选择server</td>
</tr>
<tr>
<td align="left">RoundRobinRule</td>
<td align="left">轮询策略</td>
<td align="left">按顺序循环选择server</td>
</tr>
<tr>
<td align="left">RetryRule</td>
<td align="left">重试策略</td>
<td align="left">在配置时间内选择server不成功，则一直尝试选择一个可用的server</td>
</tr>
<tr>
<td align="left">BestAvailableRule</td>
<td align="left">最低并发策略</td>
<td align="left">逐个考察server,如果server断路打开，则忽略，再选择并发连接最低的server</td>
</tr>
<tr>
<td align="left">AvailabilityFilteringRule</td>
<td align="left">可用过滤策略</td>
<td align="left">过滤掉一直连接失败并标记为circuit breaker tripped的server,过滤掉高并发连接的server</td>
</tr>
<tr>
<td align="left">WeightedResponseTimeRule</td>
<td align="left">响应时间加权策略</td>
<td align="left">根据server的响应时间分配权重，响应时间越长，权重越低，被选择的概率越低;响应时间越高，权重越高，被 选中的概率越高</td>
</tr>
<tr>
<td align="left">ZoneAvoidanceRule</td>
<td align="left">区域权衡策略</td>
<td align="left">综合判断server所在区域的性能和server的可用性轮询选择server</td>
</tr>
</tbody></table>
<br>



<hr>
<h1 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h1><p>Hystxic 是 Spring Cloud 的容错框架，也被称为熔断器。在高并发访问下，系统服务的稳定性非常重要，各种不可控因素都会影响服务的运行，例如网络连接突然变慢、服务脱机、访问量激增等等，Hystrix 就是用来让微服务正常运行的一套容错组件。这一容错组件能实现很多功能，例如隔离、降级、熔断、监控等等。</p>
<p>Netflix 这家公司真的是起名鬼才，Eureka 的意思是阿基米德裸奔时喊的“我发现了”，Hystrix 的意思是豪猪（Hystrix 的 logo 也是一只豪猪），表示这个组件跟豪猪一样浑身是刺能很好地保护自己。我看博文的时候，看到有一哥们说：</p>
<blockquote>
<p> netflix 使用这畜生来命名这框架实在是非常的贴切。</p>
</blockquote>
<p>太草了。</p>
<br>

<p>Hystrix 最常用的三个功能分别是资源隔离、降级、熔断。</p>
<ol>
<li><p>资源隔离</p>
<p>Hystrix 的隔离分为两部分，分别是<strong>线程池隔离</strong>和<strong>信号量隔离</strong>。</p>
<p>举个具体的例子，来解释这两种隔离方法。现在有两个服务：服务1和服务2，原本这两个服务一起运行，因为某些原因，服务1的访问量特别大，把服务器给挤崩了，结果服务2跟着遭殃，也无法使用了。<strong>线程池隔离</strong>是指，给服务1和服务2分别设置一个线程池，服务1的访问在自己的线程池当中，即使自己崩了也不会影响服务2。<strong>信号量隔离</strong>是指，服务1和服务2仍然共用一个线程池，但是给这个线程池设置一个最大访问量，超过了就不接受新的访问，保证服务器不崩。</p>
<p><strong>线程池隔离</strong>有一定的性能损耗，但是依旧是默认的资源隔离策略，毕竟<strong>信号量隔离</strong>会直接丢弃请求。当服务类型很多，并发量又大，建立线程池损耗明显亏损较多时，建议采用<strong>信号量隔离</strong>。</p>
<p>这一块的配置，emm，我象征性地找了一张图，入门嘛，不学了哈哈哈。（图片来源找不到了，抱歉……）</p>
<p><img src="/assets/Hystrix%E9%85%8D%E7%BD%AE.png" alt="Hystrix配置"></p>
</li>
<li><p>降级</p>
<p>当服务负荷太高，已经无法继续下去的时候，为了不让请求阻塞，让服务器崩溃掉，可以事先准备好一个“次等”的返回结果，例如告知用户【抱歉服务器崩溃了】，或者只完成一部分核心服务，至少不会让请求无限地进行下去。这个事先准备好的“次等”的返回结果，就是<strong>降级</strong>（fallback）。</p>
<p>一般服务降级的触发原因有两种，一种是线程池满了，另一种是请求超时。</p>
<p>降级的使用方法，是在一个接口方法之上，增加 <code>@HystrixCommand</code> 注解，标明当服务崩溃时，要跳转到哪个降级接口上。部分代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原接口方法</span></span><br><span class="line"><span class="meta">@HystrixCommand</span>(defaultFallback = <span class="string">"fallClass"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryById</span> <span class="params">(@PathVariable(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">    String url = <span class="string">"http://userService/user/"</span> + id;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降级接口方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">fallClass</span> <span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"服务器异常，无法查询用户"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Hystrix 的配置参数与方法，在这里暂时不提。</p>
</li>
<li><p>熔断</p>
<p>我在三年前第一次听到“熔断”这个词，那时中国股市引入了熔断机制，如果当日股市的涨跌幅超过 5 %，熔断机制开启，股市暂停 15 分钟，暂停回来后涨跌幅超过 7 %，熔断机制再次开启，股市直接停盘。我听说股市里引入熔断的概念是为了设定一个阈值，超过阈值就暂停，让股市冷静冷静。不过当时的中国股市不是很容易冷静，开盘十几分钟就熔断，一恢复又熔断，总共交易了不到 20 分钟当天就收市了，这事一发生，第二天熔断机制就被废除了。</p>
<p>Hystrix 的熔断机制指的是，当服务器的错误率达到某个设定值时，服务暂停，之后的所有请求全部丢弃，之后服务会去试探是否恢复正常、能否重启，试探成功就重启继续运行。</p>
<p>这里的错误率、熔断时间、重启要求等，都是要进行配置的地方。这里需要配置的有点多，Hystrix 也有一套默认配置值，我觉得就暂且不深探究了。</p>
</li>
</ol>
<br>

<hr>
<h1 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h1><p>Feign 是 Spring Cloud 的服务间通信工具。这个基本上是 Spring Cloud 中最重要的组件，因为微服务作为一个集群，总是要相互调用共同协作的，Feign 的作用就是微服务之间的通信。不使用 Feign 也能通过 RestTemplate 类等方式进行通信，但是 Feign 是 Spring Cloud 已经封装好的，使用起来更为优雅快捷的组件，所以一定要学习。</p>
<p>Feign 算是 Spring Cloud 的集大成者，它集成了 Eureka、Ribbon、Hystrix 等组件（因此默认支持负载均衡和服务熔断），支持 Spring MVC 注解，在此之外还基于注解简化操作，因此你可以认为，Feign 是一个活儿全的服务通信工具。（活儿不全的服务通信组件是 Ribbon + RestTemplate）</p>
<br>

<p>在这里我们先说使用方法，再说配置。</p>
<p>服务A要调用服务B的接口方法，正常的操作是这样的：服务B有几个接口对外开放，可以调用，任何地方都可以在允许的情况下，通过发送 HTTP 请求来调用服务B的接口，服务A也不例外。因此服务A想调用服务B的接口，也要在得知服务B的请求 url 前提下， 向服务B发送 HTTP 请求（可以通过 RestTemplate 来发送）。</p>
<p>Feign 的作用在于，发 HTTP 请求这种事情大同小异，我提供一个模板，你照着这个模板把地址之类的参数写清楚，我帮你发 HTTP 请求。顺便我帮你把负载均衡、服务容错这些事情一起处理了。</p>
<p>例如下面的这段代码（涉及到一点 Spring MVC 的知识，将就着看一看）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Feign 来实现一个接口，接口中调用了服务B的获取用户信息接口</span></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"pz-service-B"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignProviderClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"user/&#123;userId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Feign 所定义的接口，让服务A能够在不发送 HTTP 请求的情况下，调用服务B的获取用户信息接口</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"feign"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FeignProviderClient feignProviderClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"user/&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserFromServiceB</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> feignProviderClient.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分上下两块。上面的代码是使用 Feign 组件，下面的代码是服务A调用服务B的接口。</p>
<p>原来呢，下面的代码，即服务A调用其他服务的接口，是需要自己发送 HTTP 请求的。现在注入了 Feign 之后（<code>@Autowired</code> 那块），直接调用 Feign 就可以了。为什么呢，因为在上面的代码中，Feign 已经连接上服务B了。</p>
<p>梳理一遍，照着代码从上到下具体走一通。</p>
<ol>
<li><p>我们首先定义了一个接口类：<code>FeignProviderClient</code> 类，该类通过注解 <code>@FeignClient</code> 表明它要使用 Feign 组件，并且指明它要连接的服务是一个名为 <code>pz-service-B</code> 的服务（服务B）。</p>
</li>
<li><p>在刚刚定义的接口类 <code>FeignProviderClient</code> 类中，声明了一个方法 <code>getUser</code>，这个方法的作用是通过用户ID获取用户信息。但是这个方法并没有实现类，它只是单纯地声明了出来：有这么一个方法。</p>
<p>为什么呢，因为这个方法在服务B那里实现，在这里我们并不需要去实现它，我们只需要声明它的存在，当使用它时，让 Feign 去发送请求调用方法。</p>
</li>
<li><p>我们又定义了一个 Controller 类：<code>FeignHandler</code> 类，这个类是我们服务A的一个 Controller 类。</p>
</li>
<li><p>在这个 <code>FeignHandler</code> 类当中，我们首先自动注入了 <code>FeignProviderClient</code> 类。</p>
</li>
<li><p>在这个 <code>FeignHandler</code> 类当中，我们新定义了一个接口方法 <code>getUserFromServiceB</code>，这个方法的目的是，调用服务B的接口，通过用户ID拿到用户信息。</p>
<p>这个新的接口方法的具体实现，就是使用刚刚定义的 Feign 接口类里面的方法。我们调用 Feign 接口类里面声明的方法，怎么发请求，怎么拿到数据，这个让 Feign 去解决。</p>
</li>
</ol>
<br>

<p>写一个使用的更全面一点的 Feign 接口类，注解属性的作用已备注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(</span><br><span class="line">        value = <span class="string">"pz-service-B"</span>,                   <span class="comment">// 指定FeignClient的服务名称，这里使用value，其实使用name、serviceId也可，作用相同</span></span><br><span class="line">        path = <span class="string">"/user"</span>,                           <span class="comment">// 请求的前缀名，例如这里是：https://192.168.1.101/8080/user</span></span><br><span class="line">        url = <span class="string">"https://192.168.1.101/8080"</span>,       <span class="comment">// 手动指定请求的url，其实在一个Eureka注册下是不必写的，写清楚服务名就可以了</span></span><br><span class="line">        configuration = FeignConfiguration.class, <span class="comment">// 配置类</span></span><br><span class="line">        fallback = UserRemoteClientHystrix.class  <span class="comment">// 集成Hystrix，服务容错的降级类</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FeignProviderClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...（省略）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><br>我们还是写一点原理，下面这段内容引自<a href="https://blog.csdn.net/neosmith/article/details/52449921" target="_blank" rel="noopener">《使用 Spring Cloud Feign 作为 HTTP 客户端调用远程 HTTP 服务》</a>。</p>
<blockquote>
<p> <code>@FeignClient</code> 用于通知 Feign 组件对该接口进行代理，使用者可直接通过 <code>@Autowired</code> 注入。Spring Cloud应用在启动时，Feign 会扫描标有 <code>@FeignClient</code> 注解的接口，生成代理，并注册到 Spring 容器中。生成代理时 Feign 会为每个接口方法创建一个 RequetTemplate 对象，该对象封装了 HTTP 请求需要的全部信息，请求参数名、请求方法等信息都是在这个过程中确定的，Feign 的模板化就体现在这里。</p>
</blockquote>
<br>

<p>最后我们来补 Feign 的配置，其实跟前文的任何一个组件都差不多，启动类加注解，application.yml 文件里配置信息。</p>
<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 就是这行注解，否则在 Controller 里 @Autowired 注入 Feign 接口类时会报错</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FeignApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>application.yml 配置文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span> <span class="comment"># 这里是开启 Hystrix 服务容错，更多配置内容这里不提</span></span><br></pre></td></tr></table></figure>

<br>]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 容器（的插入元素方法）</title>
    <url>/2020/01/12/Java-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<br>

<p>一月的第二周，来补习 Java 的容器设计。</p>
<p>自己所欠的 Java 基础实在是多，主要是因为能力不足。如今的我，感觉可以追进 Java 容器的源码中了，之前写过了 HashMap 和 TreeMap，这周来看剩下的容器。</p>
<p>像是之前写 HashMap 和 TreeMap 一样，学习每个容器时从 add() 或 put() 方法开始，牵扯出背后的代码与逻辑。</p>
<hr>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList 是列表的一种，特点是能够自动扩容（即动态数组）。</p>
<p>ArrayList 的 add() 方法本身很简短，在检查容量大小之后，在数组中添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这三行代码的方法中只能看出，ArrayList 的内部是由数组实现的，也就是代码中的 <code>elementData</code>。</p>
<p>继续追进去看里面的代码，会发现代码很零碎，一个方法嵌套着另一个，而每一个方法都只有几行代码而已。因此我整理了一下，将涉及到的代码整理成下面这个样子（每一行很长，要水平拖动才能看到全部）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;                                                                                                     |</span><br><span class="line">                                                                                                                              |</span><br><span class="line">   ┌-----------------------------------------------------------------------------------------------------------------------┐  |</span><br><span class="line">   | ensureCapacityInternal(size + <span class="number">1</span>);                                                                                     |  ■ 确保列表容量足够</span><br><span class="line">   |               ↘ ↘ ↘                                                                                                   |  |</span><br><span class="line">   | <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                                                                |  |</span><br><span class="line">   |                                                                                                                       |  |</span><br><span class="line">   |    ┌--------------------------------------------------------------------------------------------------------------┐   |  |</span><br><span class="line">   |    | ensureExplicitCapacity( ┌-------------------------------------------------------------------------------┐ ); |   |  ■ 检查列表容量足够</span><br><span class="line">   |    |                         | calculateCapacity(elementData, minCapacity)                                   |    |   |  ■ 计算列表容量，最小是<span class="number">10</span></span><br><span class="line">   |    |          ↓↓↓            |                 ↘ ↘ ↘                                                         |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            | <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123; |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |     <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;                   |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |         <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);                       |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |     &#125;                                                                         |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            |     <span class="keyword">return</span> minCapacity;                                                       |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            | &#125;                                                                             |    |   |  |</span><br><span class="line">   |    |          ↓↓↓            └-------------------------------------------------------------------------------┘    |   |  |</span><br><span class="line">   |    |                                                                                                              |   |  |</span><br><span class="line">   |    |  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                                                      |   |  |</span><br><span class="line">   |    |      modCount++;                                                                                             |   |  ■ 每一次检查容量，都会使modCount+<span class="number">1</span></span><br><span class="line">   |    |      <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)                                                               |   |  |</span><br><span class="line">   |    |                                                                                                              |   |  |</span><br><span class="line">   |    |        ┌-----------------------------------------------------------------┐                                   |   |  |</span><br><span class="line">   |    |        | grow(minCapacity);                                              |                                   |   |  ■ 当最小容量超过列表长度时，扩容</span><br><span class="line">   |    |        |     ↘ ↘ ↘                                                       |                                   |   |  |</span><br><span class="line">   |    |        | <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;                            |                                   |   |  |</span><br><span class="line">   |    |        |     <span class="keyword">int</span> oldCapacity = elementData.length;                       |                                   |   |  |</span><br><span class="line">   |    |        |     <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);         |                                   |   |  ■ 每次容量扩容<span class="number">1.5</span>倍</span><br><span class="line">   |    |        |     <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)                          |                                   |   |  |</span><br><span class="line">   |    |        |         newCapacity = minCapacity;                              |                                   |   |  |</span><br><span class="line">   |    |        |     <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)                       |                                   |   |  |</span><br><span class="line">   |    |        |         newCapacity = hugeCapacity(minCapacity);                |                                   |   |  |</span><br><span class="line">   |    |        |     elementData = Arrays.copyOf(elementData, newCapacity);      |                                   |   |  ■ 将原数组的数据，拷贝到新数组中</span><br><span class="line">   |    |        | &#125;                                                               |                                   |   |  |</span><br><span class="line">   |    |        └-----------------------------------------------------------------┘                                   |   |  |</span><br><span class="line">   |    |  &#125;                                                                                                           |   |  |</span><br><span class="line">   |    |                                                                                                              |   |  |</span><br><span class="line">   |    └--------------------------------------------------------------------------------------------------------------┘   |  |</span><br><span class="line">   | &#125;                                                                                                                     |  |</span><br><span class="line">   └-----------------------------------------------------------------------------------------------------------------------┘  |</span><br><span class="line">                                                                                                                              |</span><br><span class="line">    elementData[size++] = e;                                                                                                  |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;                                                                                                              |</span><br><span class="line">&#125;                                                                                                                             |</span><br></pre></td></tr></table></figure>

<p>从 ArrayList 添加元素的 add() 方法可以看出：</p>
<ol>
<li>ArrayList 内部由数组实现</li>
<li>ArrayList 的默认容量大小是 10，每次扩容时增加到原来的 1.5 倍（通过位运算实现）</li>
<li>ArrayList 每次扩容，都会将之前保存的内容，全部复制拷贝到新数组中。</li>
<li>每次 ArrayList 增加元素时，会在确保容量足够的时候就增加 modCount。</li>
<li>ArrayList 允许添加 null。</li>
</ol>
<br>

<h2 id="没什么用的小知识"><a href="#没什么用的小知识" class="headerlink" title="没什么用的小知识"></a>没什么用的小知识</h2><p>曾经在其他博客中看到 <code>Arrays.asList()</code> 方法，这个方法与 ArrayList 有李逵李鬼的关系。</p>
<p><code>Arrays.asList()</code> 方法可以将多个元素直接拼接为列表，并返回该列表，如下面这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>, <span class="string">","</span>, <span class="string">"world"</span>, <span class="string">"!"</span>);</span><br></pre></td></tr></table></figure>

<p>应当注意的是，这里得到列表是无法增加元素的，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="string">"准备报错"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行该语句时报错</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.lang.UnsupportedOperationException</span></span><br></pre></td></tr></table></figure>

<p>现在去探索为什么会报错。看源码时发现，在 <code>Arrays.asList()</code> 方法的内部，是这么处理的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它返回了一个 ArrayList 对象，但是很坑的是，此 ArrayList 非彼 ArrayList，这里的 ArrayList，是 Arrays 类内部定义的列表类，而不是我们常规意义上的动态列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...构造方法、类方法如size()、get()等</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个内部定义的 ArrayList 类，是没有重写父类 AbstractList 类的 add() 方法的，而父类默认的 add() 方法是直接抛 <code>UnsupportedOperationException</code> 异常的。</p>
<p>回看 <code>Arrays.asList()</code> 方法，它在注释中已经说明清楚了：</p>
<blockquote>
<p>Returns a fixed-size list …</p>
</blockquote>
<p>返回一个定长列表。</p>
<br>

<hr>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector 是上古类，从 JDK 1.0 开始就存在了（ArrayList 在 JDK 1.2 才出现）。这个类怎么说呢，我工作至今，一次都没有用过……我感觉这个类存在的意义，就是为了招聘面试。</p>
<p>Vector 能够实现的功能，跟 ArrayList 几乎完全一样，除了它是线程安全的。Vector 线程安全的实现方式是，在所有方法外面都加上 <code>synchronized</code> 关键字，同时间只允许一个线程执行方法。</p>
<br>

<p>对比 Vector 和 ArrayList 的 add() 方法，逻辑上几乎完全相同，唯二值得单独提出来的地方，一处是 Vector 的 add() 方法加了 <code>synchronized</code> 关键字，代码对比如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList的add()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vector的add()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一处稍微值得提下的地方是，ArrayList 扩容时每次增加到 1.5 倍，而 Vector 扩容时每次增加到 2 倍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList扩容的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);  <span class="comment">// 新容量 = 原始容量 + 原始容量/2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vector扩容的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ? capacityIncrement : oldCapacity);  <span class="comment">// 新容量 = 原始容量 + 原始容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么 ArrayList 扩容是到 1.5 倍，而 Vector 扩容是到 2 倍，为何设计上不相同，我试着查了一下没有查到说法。我目前只能归结为，是因为写代码的大佬不是同一个人，大佬们有自己的想法。</p>
<br>

<p>参考别的大佬给出的最佳实践，Vector 类基本是被废弃掉的，如果需要一个线程安全的 list，那么可以使用 JUC 包下的 CopyOnWriteArrayList 类，或者使用 <code>Collections.synchronizedList()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>不使用 Vector 类，是因为 Vector 类实现线程安全的方式，是在所有方法的外面加上 synchronized 关键字，这个线程同步的方式比较笨重，带来的消耗比较大，因此都建议不去使用。但是为什么 synchronized 关键字消耗大，这个我暂时不清楚，等之后积累并发基础吧。</p>
<br>

<hr>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList 是另一种数据结构的列表，它通过链表（Node）的形式构成，插入和删除快，但查找慢。</p>
<p>LinkedList 的 add() 方法，简单地令人发指：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e); ---┐</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;   ↙</span><br><span class="line">&#125;                ↙</span><br><span class="line">               ↙</span><br><span class="line">             ↙ </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是尾插节点。</p>
<p>LinkedList 的构成元素是双向链表，就是一个值带着两个指针，一个指针指向前一个节点，一个指针指向后一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList 增加元素时，如果需要扩容，那么需要拷贝全部数据，删除元素时也需要大量搬移数据。LinkedList 增加和删除元素是直接改动的，但是查找时会慢。</p>
<p>一个没啥好说的类，略了。</p>
<br>

<hr>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>LinkedHashMap 类是一个奇怪的 map，在存储上它使用 HashMap 的方式，但是在遍历时，它可以按照插入的顺序输出。举一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map1 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map&lt;String, Object&gt; map2 = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">map1.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">map1.put(<span class="string">"3"</span>, <span class="number">2</span>);</span><br><span class="line">map1.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">map2.put(<span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">map2.put(<span class="string">"3"</span>, <span class="number">3</span>);</span><br><span class="line">map2.put(<span class="string">"2"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"HashMap 输出：\t\t"</span> + map1);</span><br><span class="line">System.out.println(<span class="string">"LinkedHashMap 输出：\t"</span> + map2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="comment">// HashMap 输出：       &#123;1=1, 2=2, 3=2&#125;</span></span><br><span class="line"><span class="comment">// LinkedHashMap 输出： &#123;1=1, 3=3, 2=2&#125;</span></span><br></pre></td></tr></table></figure>

<p>分别实例化一个 HashMap 对象和一个 LinkedHashMap 对象，按照一样的顺序插入三组 key-value（key 的顺序是 “1”、”3”、”2”），然后分别输出这两个对象。发现 HashMap 按照内部存储的顺序输出 1 -&gt; 2 -&gt; 3，而 LinkedHashMap 按照插入的顺序输出 1 -&gt; 3 -&gt; 2。</p>
<p>尽管 LinkedHashMap 按照插入的顺序输出，但实际上 LinkedHashMap 存储时的内部结构，是跟 HashMap 一样的，也就是说它跟 HashMap 有一样快的查找速度。</p>
<p>这真是很有意思。</p>
<br>

<p>在学习 LinkedHashMap 之前，必须先回顾 HashMap，因为 LinkedHashMap 就是由 HashMap 而来的。</p>
<p>简单来讲，HashMap 有以下几个特征：</p>
<ol>
<li>HashMap 采用哈希算法计算存储位置，因此查找速度理论上非常快，为 O(1)。</li>
<li>HashMap 采用数组+链表+红黑树的拉链法存储结构，正常来讲存数组，哈希冲突时存链表，链表长度超过 8 则转红黑树。</li>
<li>当 HashMap 的实际存储个数超过一定大小时（规则：实际个数 &gt; 数组长度 × 负载因子，负载因子默认 0.75），数组扩容。</li>
<li>HashMap 内部用于存储的数组默认长度是 16，这个长度可以人为规定，但真正的长度只会是 2 的幂，不足则自动设为下一个 2 的幂（例如指定长度为 7 则实际长度为 8，指定长度为 19 则实际长度为 32），而且每次数组扩容时将扩容到上一次的两倍。这种设计跟 HashMap 的哈希计算存储位置有关。</li>
</ol>
<p>好吧，看来也不简单。</p>
<br>

<p>可以来看 LinkedHashMap 的 put() 方法了。</p>
<p>但是当看 LinkedHashMap 时，会发现它并没有 put() 方法，其实这在上次查看 HashMap 的 put() 方法时就初见端倪了。这是因为，LinkedHashMap 的确没有 put() 方法，它继承自 HashMap 类，直接使用 HashMap 的 put() 方法。</p>
<p>但是 HashMap 的 put() 方法中留下了空实现几个方法，LinkedHashMap 重写了这几个空实现的方法，此外还重写了另一个方法，使得它虽然是继承使用 HashMap 的 put() 方法，但是并不完全一样。</p>
<p>HashMap 的 put() 方法核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">                 ┌----------------------------------┐</span><br><span class="line">        tab[i] = | newNode(hash, key, value, <span class="keyword">null</span>); |  <span class="comment">// LinkedHashMap重写了此方法</span></span><br><span class="line">                 └----------------------------------┘</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                             ┌----------------------------------┐</span><br><span class="line">                    p.next = | newNode(hash, key, value, <span class="keyword">null</span>); |  <span class="comment">// LinkedHashMap重写了此方法</span></span><br><span class="line">                             └----------------------------------┘</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">           ┌---------------------┐</span><br><span class="line">           | afterNodeAccess(e); |  <span class="comment">// 预留给LinkedHashMap使用</span></span><br><span class="line">           └---------------------┘</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    ┌----------------------------┐</span><br><span class="line">    | afterNodeInsertion(evict); |  <span class="comment">// 预留给LinkedHashMap使用</span></span><br><span class="line">    └----------------------------┘</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这真是很有意思，看 HashMap 的源码时，总会发现一些特别巧妙的设计（以及艰涩难读的代码……）。</p>
<br>

<p>先说点基础做铺垫。</p>
<p>从总体上说，LinkedHashMap 内部维护了两套存储内容，一套跟 HashMap 完全相同（实际上就是在使用 HashMap），另一套是一条双向链表。每当继承自 HashMap 的那套存储内容发生变化的时候，例如新建、删除、插入等，都要同时在另一套自己维护的双向链表中去做处理。这样，既能白嫖到 HashMap 的极快的查找速度，也能享受到自己维护的双向链表的额外功能。</p>
<p>LinkedHashMap 实现两套存储内容，是通过特殊设计存储结构实现的。LinkedHashMap 沿用 HashMap 的设计，使用数组+链表来实现（暂时忽略红黑树），数组中存放的是链表节点。</p>
<p>HashMap 的链表节点的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法、getter方法、setter方法等等...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 的链表节点的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    <span class="comment">// 构造方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，LinkedHashMap 的链表节点类（Entry），继承自 HashMap 的链表节点类（Node）。HashMap 的链表节点具有四个信息，分别是 key、value、hash 值、下一个节点的指针。而 LinkedHashMap 的链表节点类除了具有以上四个属性之外，还具有指向 before 节点和 after 节点的指针（需要注意，after 指向的内容，跟 next 指向的内容，并不是同一个东西）。因此可以认为，LinkedHashMap 的链表节点，实际上是具有三个方向的，是一个三向链表节点，它除了具有指向下一个节点的方向之外，还额外新增了两个方向：一个指向 before，一个指向 after。</p>
<p>因此，LinkedHashMap 内部维护了两套存储逻辑，一套跟 HashMap 完全相同，另一套是一条双向链表。</p>
<p>这条双向链表，有两种用处（排序方式）：</p>
<ol>
<li>按照插入顺序排序，遍历时可以按照插入的顺序输出</li>
<li>按照访问顺序排序，遍历时按照曾经访问过的先后顺序输出（LRU 算法）</li>
</ol>
<p>这两种排序方式都是有意义的，一个可以记录 LinkedHashMap 插入数据的顺序，另一个可以记录 LinkedHashMap 访问数据的顺序，可以用作缓存，按时间先后输出最近看过的数据。</p>
<br>

<p>了解了以上这些，我们回看 LinkedHashMap 的 put() 方法，也就是使用父类 HashMap 的 put() 方法时，重写的那三个方法，究竟在做些什么。</p>
<p>LinkedHashMap 一共重写了三个方法：</p>
<ol>
<li>newNode() 方法，用于创建链表节点</li>
<li>afterNodeAccess() 方法，用于处理按照访问顺序排序的情况</li>
<li>afterNodeInsertion() 方法，用于处理按照插入顺序排序的情况</li>
</ol>
<h2 id="newNode-方法"><a href="#newNode-方法" class="headerlink" title="newNode() 方法"></a>newNode() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p = <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">   ┌------------------┐</span><br><span class="line">   | linkNodeLast(p); |  →┐</span><br><span class="line">   └------------------┘   ↓</span><br><span class="line">    <span class="keyword">return</span> p;             ↙</span><br><span class="line">&#125;                       ↙</span><br><span class="line">                      ↙</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原先创建链表节点的基础上，将该节点设为双向链表的最后一个节点。</p>
<h2 id="afterNodeAccess-方法"><a href="#afterNodeAccess-方法" class="headerlink" title="afterNodeAccess() 方法"></a>afterNodeAccess() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K, V&gt; e)</span> </span>&#123;                                  ■ 传入访问节点</span><br><span class="line">    LinkedHashMap.Entry&lt;K, V&gt; last;                                   |</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;                          |</span><br><span class="line">        LinkedHashMap.Entry&lt;K, V&gt; p = (LinkedHashMap.Entry&lt;K, V&gt;) e,  |</span><br><span class="line">                                  b = p.before,                       |</span><br><span class="line">                                  a = p.after;                        |</span><br><span class="line">        p.after = <span class="keyword">null</span>;                                               ■ 访问节点之后清空</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)                                                ■ 处理访问节点原先位置的前一个节点</span><br><span class="line">            head = a;                                                 |</span><br><span class="line">        <span class="keyword">else</span>                                                          |</span><br><span class="line">            b.after = a;                                              |</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)                                                ■ 处理访问节点原先位置的后一个节点</span><br><span class="line">            a.before = b;                                             |</span><br><span class="line">        <span class="keyword">else</span>                                                          |</span><br><span class="line">            last = b;                                                 |</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)                                             ■ 将访问节点设为双向链表的最后一个节点</span><br><span class="line">            head = p;                                                 |</span><br><span class="line">        <span class="keyword">else</span> &#123;                                                        |</span><br><span class="line">            p.before = last;                                          |</span><br><span class="line">            last.after = p;                                           |</span><br><span class="line">        &#125;                                                             |</span><br><span class="line">        tail = p;                                                     |</span><br><span class="line">        ++modCount;                                                   |</span><br><span class="line">    &#125;                                                                 |</span><br><span class="line">&#125;                                                                     |</span><br></pre></td></tr></table></figure>

<p>首先解释 accessOrder 是什么：LinkedHashMap 的双向链表有两种排序方式，一种是按照插入顺序排序，一种是按照访问顺序排序。accessOrder 是一个布尔值，当它为 true 时表示按照访问顺序排序，当它为 false 时表示按照插入顺序排序。默认情况下，accessOrder 为 false，也就是说，默认情况下 LinkedHashMap 的双向链表是按照插入顺序排序的。</p>
<p>afterNodeAccess() 方法的意义是，当 accessOrder 为 true 时（按照访问顺序排序），将最新访问的节点，放到 LinkedHashMap 双向链表的最后一个的位置处。具体的实现的逻辑是，将该节点从原位置处删除掉，并设置为双向链表的最后一个节点。</p>
<h2 id="afterNodeInsertion-方法"><a href="#afterNodeInsertion-方法" class="headerlink" title="afterNodeInsertion() 方法"></a>afterNodeInsertion() 方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (evict                           <span class="comment">// 参数1</span></span><br><span class="line">        &amp;&amp; (first = head) != <span class="keyword">null</span>       <span class="comment">// 参数2</span></span><br><span class="line">        &amp;&amp; removeEldestEntry(first)) &#123;  <span class="comment">// 参数3</span></span><br><span class="line">        </span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 LinkedHashMap 而言，afterNodeInsertion() 默认是一个无用的方法，执行前后不会发生任何变化。但是如果你自己写一个 LinkedHashMap 的子类，重写某个方法，可以让 afterNodeInsertion() 方法生效。</p>
<p>afterNodeInsertion() 方法的作用是，每当新节点插入时，就把双向链表的最开始的节点删除掉，以保持双向链表的长度在插入前后是不变的。这个方法的意义在于，如果子类想要实现缓存，而缓存的长度是有限的，可以使用该方法来做处理，当缓存的容量满了之后，每插入一个新节点，就删除掉最早插入的旧节点，维持缓存的容量。</p>
<p> afterNodeInsertion() 方法有三个执行逻辑上的参数，只有这三个参数都为 true 时，该方法才会删除双向链表的头节点：</p>
<ul>
<li><p><code>evict</code>  由 HashMap 的 putVal() 方法定义，在插入节点时默认为true，表示可以删除头结点。如果 <code>evict</code> 为 false，表示 map 处于“creation mode”（创造模式，只创造，不删除）。</p>
</li>
<li><p><code>(first = head) != null</code>  双向链表有头结点（否则没得删）</p>
</li>
<li><p><code>removeEldestEntry(first))</code>  默认返回 false，表示不删除之前插入的节点。子类如果想实现缓存，那么需要重写该方法，官方还给了一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存最大100，超过100就返回false，准备删除头节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> size() &lt; MAX_ENTRIES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<br>

<p>LinkedHashMap 还有很多地方并没有看，这里只简单探究了 LinkedHashMap 插入新元素的逻辑（而且还没关注当链表长度过长转成红黑树是怎么样的）。HashMap 和 LinkedHashMap 的源码实在是有够神奇，我很是服气……</p>
<p>LinkedHashMap 先写到这里了。</p>
<br>

<p>最后安利一篇博文：<a href="http://www.tianxiaobo.com/2018/01/24/LinkedHashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%EF%BC%88JDK1-8%EF%BC%89/" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a>。</p>
<br>

<hr>
<h1 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h1><p>跟 ArrayList 和 Vector 的关系几乎完全一样，HashMap 和 Hashtable 也是如此。</p>
<p>在 JDK 1.0 时，Java.util 包中还只有 Vector 和 Hashtable（当然还有别的类，这里是针对于 ArrayList 和 HashMap 而言的），它们两个都通过在方法前加 synchronized 关键字实现线程安全。在 JDK 1.2 时，Java.util 包中新增了 ArrayList 和 HashMap 这两个线程非安全的类，但是可以通过 Collection 类的静态方法将它们转换成线程安全的类，这样就减轻了性能要求。在 JDK 1.5 时，JUC 包中的 CopyOnWriteArrayList 和 ConcurrentHashMap 出现，基本宣告了 Vector 和 Hashtable 的死刑。</p>
<p>但是和 Vector 稍有不同的是，Hashtable 并不是和 HashMap 的各个方法只有 synchronized 关键字的区别，而是在设计上就有所不同。HashMap 和 Hashtable 都基于哈希算法实现，通过数组+链表的基本数据结构构成，但是在算法和数据存储上都略有区别。本次只关注 Hashtable 的 put() 方法。</p>
<p>Hashtable 的 put() 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;                    |</span><br><span class="line">                                                               |</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;                                       ■ value不能为<span class="keyword">null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                      |</span><br><span class="line">    &#125;                                                          |</span><br><span class="line">                                                               |</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;                                  ■ 取Hashtable的存储数组</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();                                 ■ 取哈希值（暗中要求key也不能为<span class="keyword">null</span>）</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;              |</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)                             |</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];                 ■ 根据key的哈希值找到数组的桶</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;                |</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;   ■ key相同时替换value，并直接返回</span><br><span class="line">            V old = entry.value;                               |</span><br><span class="line">            entry.value = value;                               |</span><br><span class="line">            <span class="keyword">return</span> old;                                        |</span><br><span class="line">        &#125;                                                      |</span><br><span class="line">    &#125;                                                          |</span><br><span class="line">   ┌------------------------------------┐                      |</span><br><span class="line">   | addEntry(hash, key, value, index); |                      ■ 添加key-value，详见下</span><br><span class="line">   └------------------------------------┘                      |</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;       ↙                                       |</span><br><span class="line">&#125;                    ↙                                         |</span><br><span class="line">                   ↙                                           .</span><br><span class="line">                 ↙                                             .</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;   |</span><br><span class="line">    modCount++;                                                |</span><br><span class="line">                                                               |</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;                                  |</span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;                                  ■ 如果容量饱和（默认 size &gt;= 数组大小 × <span class="number">0.75</span>）</span><br><span class="line">       ┌-----------┐                                           |</span><br><span class="line">       | rehash(); |                                           ■ 扩大数组容量，并重新装填key-value，详见下</span><br><span class="line">       └-----------┘                                           |</span><br><span class="line">        tab = table;                                           |</span><br><span class="line">        hash = key.hashCode();                                 |</span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;              ■ 计算需要插入key-value在新数组中的位置</span><br><span class="line">    &#125;                                                          |</span><br><span class="line">                                                               |</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)                             |</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];                    ■ 在数组中存储key-value，链表头插法</span><br><span class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);             |</span><br><span class="line">    count++;                                                   ■ 此时才增加容量计数，如果容量饱和，下一次再扩容</span><br><span class="line">&#125;                     ↙                                        |</span><br><span class="line">                    ↙                                          .</span><br><span class="line">                  ↙                                            .</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;                                                     |</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;                                           |</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;                                              |</span><br><span class="line">                                                                              |</span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;                                 ■ 数组扩容，扩容算法是<span class="number">2</span>n+<span class="number">1</span>，例如<span class="number">11</span>扩容到<span class="number">23</span></span><br><span class="line">                                                                              | 这样扩容使数组长度尽可能是质数，哈希算法更平均</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;                                   |</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)                                    ■ 数组最大长度是<span class="keyword">int</span>最大值-<span class="number">8</span>，照顾不同的VM情况</span><br><span class="line">            <span class="keyword">return</span>;                                                           |</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;                                         |</span><br><span class="line">    &#125;                                                                         |</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];                        |</span><br><span class="line">                                                                              |</span><br><span class="line">    modCount++;                                                               |</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);  ■ 重算容量饱和值</span><br><span class="line">    table = newMap;                                                           |</span><br><span class="line">                                                                              |</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;                                   ■ 重新装填所有的key-value</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;       |</span><br><span class="line">            Entry&lt;K,V&gt; e = old;                                               |</span><br><span class="line">            old = old.next;                                                   |</span><br><span class="line">                                                                              |</span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;                  ■ 每一个key-value都要重算哈希位置</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];                               |</span><br><span class="line">            newMap[index] = e;                                                |</span><br><span class="line">        &#125;                                                                     |</span><br><span class="line">    &#125;                                                                         |</span><br><span class="line">&#125;                                                                             |</span><br></pre></td></tr></table></figure>

<p>Hashtable 的 put() 方法，总体逻辑上是这样的：</p>
<ul>
<li>内部存储通过<code>数组+链表</code>的数据结构，没有红黑树，数组默认大小11。</li>
<li>每当增加新的 key-value 时，根据哈希值对数组长度取余，计算在数组中的位置，如果 key 存在则替换 value，如果 key 不存在，则在数组的相应位置处采用链表头插法插入。</li>
<li>当容量饱和（默认算法是<code>容量 &gt;= 数组长度 × 0.75</code>）时，扩容数组。数组扩容算法是<code>新数组长度 = 旧数组长度 × 2 + 1</code>，例如初始化数组大小是 11，第一次扩容之后变成了 23。每次扩容时，要将旧数组中的数据迁移到新数组中，每一个数据都要重算哈希位置。</li>
</ul>
<br>

<p>JDK 1.0 的 Hashtable 和 JDK 1.2 HashMap 的实现是不相同的，下面简单列一下不相同的点：</p>
<ul>
<li>HashMap 通过<code>数组+链表+红黑树</code>做底层存储（在 JDK 1.8 之后），而 Hashtable 通过<code>数组+链表</code>做底层存储。</li>
<li>HashMap 的数组大小默认是 16，如果手动指定数组大小或者数组扩容（扩容算法是扩大到两倍），数组大小也只能是 2 的幂（1、2、4、8、16、32……），而 Hashtable 的数组默认大小是 11，扩容算法是 <code>2n + 1</code>，尽可能使数组大小是质数。这个差异跟两种 map 添加 key-value 数据时的算法有关。</li>
<li>HashMap 的 key 和 value 都可以是 null，而 Hashtable 则都不可以，否则会抛出空指针异常。这要分别解释 key 和 value。<ul>
<li>我目前查到的说法，Hashtable 不支持 key 为 null，是因为这个类出现得太早，觉得一切 key 都要有 hashCode，而之后的 HashMap 考虑到了 null 的重要，为它单独做了处理，把所以 key 为 null 的数据存储在数组的第 0 个格子中。</li>
<li>Hashtable 不支持 value 为 null，是线程安全的考虑。如果 value 可以为 null，那么当 Hashtable 执行 put() 方法并且返回值是 null 时，你并不知道，究竟是因为原来没有这个 key，还是因为原来有 key 但它的 value 是null。HashMap 也是如此，但是它可以通过执行 containsKey() 的方法来判断 key 是否存在，这在单线程下是没有问题的，但是在并发状态下，containsKey() 得到的结果是并不可靠的，可能下一秒 key 就被删除掉了。因此多线程环境下，value 必须不能是 null，Hashtable 是这么设计的，ConcurrentHashMap 也是这么设计的。</li>
</ul>
</li>
<li>HashMap 和 Hashtable 在插入元素，哈希计算它在数组中的位置的算法，是不一样的。<ul>
<li>HashMap 的哈希算法一环扣一环，它希望加快计算位置的速度（这是一方面的原因），因此不使用 % 取余算法，而通过更快的按位与运算来计算位置（(n - 1) &amp; hash），这就要求了数组的长度只能是 2 的幂，以保证按位与计算出来的结果和取余计算出来的结果是相同的。而数组长度是 2 的幂，哈希计算出来的数值很容易相同（哈希冲突），那么只能让哈希值更平均一些，因此 HashMap 将哈希值的高位和低位按位与，以降低哈希冲突。</li>
<li>Hashtable 的哈希算法比较简单直接一些，直接将哈希值对数组长度取余。这种算法中数组长度很重要，如果是质数的话，取余结果能够更平均一些，因此 Hashtable 的数组长度默认是 11，而且扩容算法是 <code>2n+1</code>，扩容之后一般也是质数（但是可以手动指定成随便一个数）。尽管 HashMap 对哈希值做了处理，但我查到的资料是，也不如 Hashtable 取余结果平均，但是 Hashtable 会慢。</li>
<li>扩容时，HashMap 和 Hashtable 的实现也是不一样的，HashMap 由于数组是 2 的幂数，所以扩容更简单（具体的我没看），但是 Hashtable 只能一个个重算位置。</li>
</ul>
</li>
<li>HashMap 在 JDK 1.8 之前，在链表中插入元素都是头插法，而在 JDK 1.8 后是尾插法。Hashtable 一直是头插法。HashMap 在 JDK 1.8 之后转用尾插法的原因，是为了防止并发时链表死循环，我对此还不是很理解，一方面 HashMap 又不是线程安全的类，另一方面如果这个问题真的存在，那么前面 7 个 JDK 版本为什么不改……我还是要再积累一点经验再回来看这个问题。</li>
</ul>
<p>我从总体上理解，认为 HashMap 将优化的重心放在数据的维护上，插入慢一点，扩容快，对外兼容好，而 Hashtable 将优化的重心放在数据的插入上，存储时更平均，扩容代价很大。只是感觉而已。</p>
<p>另外我发现，原来 Hashtable 的 table 并不是首字母大写的，原来 hash 和 table 是组合成一个单词的呀。</p>
<br>

<hr>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>ConcurrentHashMap 是 HashMap 的线程安全类，在 JUC 包下，是宣告了 Hashtable 类死刑的类。</p>
<p>说实话，没看懂这个类的实现……我就先放一下 put() 方法的主要逻辑，以后再回来看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;                                             |</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();                            ■ key和value均不允许<span class="keyword">null</span>，防止并发<span class="keyword">null</span>歧义</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());                                                             ■ hashCode的高位和低位与运算</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;                                                                              ■ binCount:插入位置处的链表节点数</span><br><span class="line">    <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt;[] tab = table; ; ) &#123;                                         |</span><br><span class="line">        ConcurrentHashMap.Node&lt;K, V&gt; f;                                                            ■ f:插入位置的已有链表节点</span><br><span class="line">        <span class="keyword">int</span> n,                                                                                     ■ n:数组大小</span><br><span class="line">            i,                                                                                     ■ i:坐标，哈希计算出来</span><br><span class="line">            fh;                                                                                    ■ fh:插入位置的已有链表节点的哈希值</span><br><span class="line">                                                                                                   |</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)                                                  ■ 初始化数组（若未存储过）</span><br><span class="line">            tab = initTable();                                                                     |</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;                                   ■ CAS获取数组位置，空则直接添加</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>, <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(hash, key, value, <span class="keyword">null</span>)))  |</span><br><span class="line">                <span class="keyword">break</span>;                                                                             |</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)                                                         ■ 其他线程正在进行扩容，则帮助一起扩容</span><br><span class="line">            tab = helpTransfer(tab, f);                                                            |</span><br><span class="line">        <span class="keyword">else</span> &#123;                                                                                     ■ 已有其他节点存在该位置上（哈希冲突）</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;                                                                       |</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;                                                                     |</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;                                                          ■ 再次判断取到的节点是否是头节点（考虑并发）</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;                                                                 ■ 链表中加新节点</span><br><span class="line">                        binCount = <span class="number">1</span>;                                                              |</span><br><span class="line">                        <span class="keyword">for</span> (ConcurrentHashMap.Node&lt;K, V&gt; e = f; ; ++binCount) &#123;                   |</span><br><span class="line">                            K ek;                                                                  |</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;                                                  |</span><br><span class="line">                                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;     |</span><br><span class="line">                                oldVal = e.val;                                                    |</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)                                                 |</span><br><span class="line">                                    e.val = value;                                                 |</span><br><span class="line">                                <span class="keyword">break</span>;                                                             |</span><br><span class="line">                            &#125;                                                                      |</span><br><span class="line">                            ConcurrentHashMap.Node&lt;K, V&gt; pred = e;                                 |</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;                                            |</span><br><span class="line">                                pred.next = <span class="keyword">new</span> ConcurrentHashMap.Node&lt;K, V&gt;(hash, key,            |</span><br><span class="line">                                        value, <span class="keyword">null</span>);                                              |</span><br><span class="line">                                <span class="keyword">break</span>;                                                             |</span><br><span class="line">                            &#125;                                                                      |</span><br><span class="line">                        &#125;                                                                          |</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ConcurrentHashMap.TreeBin) &#123;                           ■ 红黑树中加新节点</span><br><span class="line">                        ConcurrentHashMap.Node&lt;K, V&gt; p;                                            |</span><br><span class="line">                        binCount = <span class="number">2</span>;                                                              |</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((ConcurrentHashMap.TreeBin&lt;K, V&gt;) f).putTreeVal(hash, key,       |</span><br><span class="line">                                value)) != <span class="keyword">null</span>) &#123;                                                 |</span><br><span class="line">                            oldVal = p.val;                                                        |</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)                                                     |</span><br><span class="line">                                p.val = value;                                                     |</span><br><span class="line">                        &#125;                                                                          |</span><br><span class="line">                    &#125;                                                                              |</span><br><span class="line">                &#125;                                                                                  |</span><br><span class="line">            &#125;                                                                                      |</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;                                                                   |</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)                                                 ■ 链表转红黑树</span><br><span class="line">                    treeifyBin(tab, i);                                                            |</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)                                                                |</span><br><span class="line">                    <span class="keyword">return</span> oldVal;                                                                 |</span><br><span class="line">                <span class="keyword">break</span>;                                                                             |</span><br><span class="line">            &#125;                                                                                      |</span><br><span class="line">        &#125;                                                                                          |</span><br><span class="line">    &#125;                                                                                              |</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);                                                                        ■ CAS统计数量+<span class="number">1</span>，同时考虑扩容</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;                                                                                   |</span><br><span class="line">&#125;                                                                                                  |</span><br></pre></td></tr></table></figure>

<p>就这样吧……</p>
<br>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>一共查看了三种 list：</p>
<ol>
<li><p>ArrayList 类基于动态数组实现，默认初始容量是 10，容量不够则扩充到 1.5 倍，非线程安全。</p>
<p>这是最常用的类，使用时尽量指定容量大小。</p>
</li>
<li><p>Vector 类是个上古残废类，跟 ArrayList 类几乎一模一样，除了能保证线程安全，笨重。</p>
</li>
<li><p>LinkedList 类基于双向链表实现，增删快，查找慢。</p>
</li>
</ol>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>重点看了两种新的 map，并且对 HashMap 有了更深的理解：</p>
<ol>
<li>LinkedHashMap 重定义了链表节点类，因此在 HashMap 的功能之外，多实现了一条双向链表，可以按照插入/访问顺序存储节点。</li>
<li>HashTable 是上古版本的、在各个方法上加了 synchronized 关键字的 HashMap，能够实现多线程安全。这个类已经是个不被推荐的类了，也就没再修改过。通过这个类，能看看 HashMap 年轻时长什么样。</li>
<li>ConcurrentHashMap 是 JUC 包下的线程安全的 HashMap，没看懂……</li>
</ol>
<br>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty 的 Bootstrap</title>
    <url>/2020/09/30/Netty-%E7%9A%84-Bootstrap/</url>
    <content><![CDATA[<br>

<p>没有想到，整整一个九月，就看了 Netty 的一个方法。</p>
<p>九月份学习完 ServerBootstrap，下个月就先不看 Netty 了，换一换脑子。</p>
<hr>
<p>在上一篇博文中，我们初识了 Netty，知道了它是基于 NIO 的异步非阻塞 I/O 框架，它能做很多事情但它也有很多类。</p>
<p>Netty 进行 I/O 操作是靠 NIO 的 Channel 类实现的，不过 Netty 自己也有一个 Channel 类，它内部包着 NIO 的 Channel（有点绕）。Netty 的 Channel 类有特别多的变量，它几乎包含着 I/O 操作所需要的全部东西，因此创建一个 Channel 并设置参数，是一件相当复杂的事。Netty 考虑到这一点，提供了 Bootstrap 类，这个类就是为创建 Channel 而生的，它的作用就是方便快捷地创建 Channel。</p>
<p>再看一遍这句解释，体会一下 Bootstrap 的作用：</p>
<blockquote>
<p>AbstractBootstrap is a helper class that makes it easy to bootstrap a Channel.</p>
</blockquote>
<p>上面所说的 AbstractBootstrap 是一切 Netty 中 Bootstrap 的父类，我们今天要学习的是两种 Bootstrap：<code>ServerBootstrap</code> 和 <code>Bootstrap</code>。前者 <code>ServerBootstrap</code> 用来创建服务端 Channel，后者 <code>Bootstrap</code> 用来创建客户端 Channel。</p>
<p>回顾一下服务端和客户端。（粗浅地讲）服务端提供中心服务功能，暴露出来一个端口，用户那边的客户端，可以通过刚才那个端口连接到服务端。服务端和客户端通过同一个端口进行 I/O 操作，服务端绑定（bind）端口，客户端连接（connect）端口，两边都连好了，就可以通信了。</p>
<p>ServerBootstrap 和 Bootstrap 可以各自通过 bind(…) 和 connect(…) 方法，生成一个 ChannelFuture 实例，这个 ChannelFuture 实例就代表着 I/O 操作的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// serverBootstrap 绑定端口 8080</span></span><br><span class="line">ChannelFuture serverFuture = serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">// bootstrap 连接端口 127.0.0.1:8080</span></span><br><span class="line">ChannelFuture clientFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>在 serverBootstrap 执行 bind(…) 方法时，它将隐含地创建 Netty 的 Channel 实例，并把自己的参数都设置到 Channel 身上，这也就是我们刚才说的，Bootstrap 的作用就是方便快捷地创建 Channel 实例（实际上我们从始至终都没看到 Channel 实例）。对于 bootstrap 也是一样，它执行 connect(…) 方法时也会隐含地创建一个 Channel 实例，设置好参数，连接端口，最后返回一个 ChannelFuture。</p>
<p>重新梳理一遍：</p>
<ul>
<li>ServerBootstrap 和 Bootstrap 各自用来快速创建<code>服务端的 Channel</code> 和<code>客户端的 Channel</code>，并用这个 Channel 来进行 I/O 操作（这个过程对外是隐藏的）。</li>
<li>ServerBootstrap 对象执行 bind(…) 方法，绑定端口，这个过程中会隐含地创建<code>服务端的 Channel</code>。</li>
<li>Bootstrap 对象执行 connect(…) 方法，连接端口，这个过程中会隐含地创建<code>客户端的 Channel</code>。</li>
</ul>
<p>如果到这里不能理解，那么接下去的内容应该也不用看了。</p>
<p>下面先不提 bind(…) 和 connect(…) 方法，先开始讲 ServerBootstrap 和 Bootstrap 是怎么创建的，又是怎么设置复杂的参数的。</p>
<hr>
<p><img src="/assets/Netty_Bootstrap.jpg" alt="Netty_Bootstrap"></p>
<h1 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h1><p>服务端 Channel 的引导类。</p>
<p>虽说是“方便快捷”地创建 Channel，但其实代码还挺多的。下面是示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 ServerBootstrap</span></span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"><span class="comment">// 配置 ServerBootstrap</span></span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">        .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>ServerBootstrap 继承自 AbstractBootstrap，两个类的实例变量加在一起有 11 个，基本都有用处。</p>
<p><img src="/assets/ServerBootstrap%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="ServerBootstrap初始化"></p>
<p>最开始的代码就是为了设置这些变量，ServerBootstrap 实例调了 6 个方法设置好了 7 个参数，设置的过程可以参照下图：</p>
<p><img src="/assets/ServerBootstrap%E8%AE%BE%E7%BD%AE.jpg" alt="ServerBootstrap设置"></p>
<p>简单地过一遍这些变量，都是用来做什么的：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>channelFactory</td>
<td>ServerBootstrap 是服务端 Channel 的引导类，它是用来快速创建并配置 Channel 的，而创建 Channel 就是通过这个变量，利用工厂方法创建的</td>
</tr>
<tr>
<td>group</td>
<td>这是一个线程池（boss），它的作用是连接，在绑定端口之后接收连接，每接到一个连接，指派给 childGroup 去做 I/O 操作</td>
</tr>
<tr>
<td>childGroup</td>
<td>这也是一个线程池（worker），它的作用是 I/O，也就是负责具体的 I/O 操作，一个线程负责一个 Channel 的 I/O</td>
</tr>
<tr>
<td>handler</td>
<td>设置 ChannelHandler，用于处理服务端 Channel 的发送</td>
</tr>
<tr>
<td>childHandler</td>
<td>设置 ChannelHandler，用于处理客户端 Channel 的接收</td>
</tr>
<tr>
<td>option</td>
<td>设置服务端 Channel 的选项参数</td>
</tr>
<tr>
<td>childOption</td>
<td>设置客户端 Channel 的选项参数</td>
</tr>
<tr>
<td>config</td>
<td>其实就是 Bootstrap 对象自身（this），作用是在父类的方法中，也能获得本对象的一些参数</td>
</tr>
</tbody></table>
<p>写累了，看代码吧。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* —————————————————————————— group —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【parentGroup】和【childGroup】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">"childGroup"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # group</span></span><br><span class="line"><span class="comment"> * 父类的 group(...) 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(group, <span class="string">"group"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"group set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.group = group;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— channel —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【channelFactory】</span></span><br><span class="line"><span class="comment">// 传入的是 Channel 子类，取它的构造方法，封装成 channelFactory，以后用它创建 channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ReflectiveChannelFactory 类的构造方法一直往下看</span></span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">"channelClass"</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory((ChannelFactory&lt;C&gt;) channelFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">"channelFactory"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"channelFactory set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类继承自 ChannelFactory</span></span><br><span class="line"><span class="comment"> * 通过反射获取指定 Channel 类的构造方法，以后用 constructor 生产 channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">"clazz"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Class "</span> + StringUtil.simpleClassName(clazz) +</span><br><span class="line">                <span class="string">" does not have a public non-arg constructor"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— childHandler —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【childHandler】</span></span><br><span class="line"><span class="comment">// 这里传入的是 ChannelInitializer，它是 ChannelHandler 的子类，相当于一个大的 handler，里面套着很多小 handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # childHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.childHandler = ObjectUtil.checkNotNull(childHandler, <span class="string">"childHandler"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— handler —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【handler】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # handler</span></span><br><span class="line"><span class="comment"> * 父类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = ObjectUtil.checkNotNull(handler, <span class="string">"handler"</span>);</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— option —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【options】</span></span><br><span class="line"><span class="comment">// 在 options（一张 LinkedHashMap）中增加 [option - value] 键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # option</span></span><br><span class="line"><span class="comment"> * 父类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(option, <span class="string">"option"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options.remove(option);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            options.put(option, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— childOptions —————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【childOptions】</span></span><br><span class="line"><span class="comment">// 在 childOptions（一张 LinkedHashMap）中增加 [option - value] 键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # childOption</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ServerBootstrap <span class="title">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(childOption, <span class="string">"childOption"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childOptions.remove(childOption);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            childOptions.put(childOption, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>客户端 Channel 的引导类。</p>
<p>Bootstrap 相比 ServerBootstrap，只有减少没有增加，简单看一个示例就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Bootstrap</span></span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"><span class="comment">// 配置 Bootstrap</span></span><br><span class="line">bootstrap.group(workerGroup)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>应该能看出一点套路了。</p>
<p>下图来自《<a href="https://www.javadoop.com/post/netty-part-1" target="_blank" rel="noopener">Netty 源码解析系列</a>》，是 ServerBootstrap 和 Bootstrap 的使用套路，再感受一下。</p>
<p><img src="/assets/bootstrap%E9%85%8D%E7%BD%AE%E5%A5%97%E8%B7%AF.png" alt="bootstrap配置套路"></p>
<hr>
<p>接下来，我们只关注一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ChannelFuture future = serverBootstrap.bind(port).sync();</span><br></pre></td></tr></table></figure>

<p>ServerBootstrap 的 <code>bind(port)</code> 方法的作用是创建一个 Channel 对象，并绑定上一个端口，它返回的是 ChannelFuture（更准确地讲，是 DefaultChannelPromise），也就是说在执行 <code>bind(port)</code> 方法之后，会获取一个 Future 对象，bind 的结果将异步设置进 Future 对象中。</p>
<p><code>sync()</code> 方法其实只是在等待，一直等到异步结果返回为止，也就是说，执行完这行代码，channel 已经绑定上端口号了。因此 <code>sync()</code> 并不是重点，我们重点要看的是 <code>bind(port)</code> 方法。下面的所有内容，都是在学习 <code>bind(port)</code> 方法究竟做了什么，很长。</p>
<br>

<p>把结果放在最前面，后续代码太多，只写注释好了。</p>
<p><code>bind(port)</code> 方法主要做了这些事情：</p>
<ol>
<li>创建 Channel 对象</li>
<li>初始化 channel（尤其是初始化 pipeline）</li>
<li>注册 channel<ol>
<li>创建 JDK 底层的 Channel 对象并注册 selectionKey</li>
<li>pipeline 上 handler 执行回调事件</li>
<li>pipeline 上 handler 执行注册事件（registered）</li>
<li>pipeline 上 handler 执行启动事件（active）</li>
</ol>
</li>
<li>channel 绑定端口号</li>
</ol>
<p>开始看代码吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将端口号 port 转换成 InetSocketAddress（java.net 的类）</span></span><br><span class="line">    <span class="comment">// 就不往里挖了，最后会转换成 [0.0.0.0/0.0.0.0:port]</span></span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验 group 和 channelFactory 是否不为空，如果为空就抛异常</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="string">"localAddress"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # doBind</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是所有逻辑的核心中转站</span></span><br><span class="line"><span class="comment"> * 1.init</span></span><br><span class="line"><span class="comment"> * 2.register</span></span><br><span class="line"><span class="comment"> * 3.bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 channel，初始化，注册，返回注册结果</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel 注册完成，直接调用 doBind0(...) 方法</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// channel 没注册完成，加一个 listener，等它完成自己去调用 doBind(...) 方法</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来有一个非常庞大的方法：<code>initAndRegister()</code>。</p>
<p>这个方法拆成 <code>init</code> 和 <code>register</code> 两部分来看，先看 <code>init</code> 的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # initAndRegister</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.创建 Channel 实例</span></span><br><span class="line"><span class="comment"> * 2.初始化 channel（设置 config、attr、pipeline、pipeline#handler）</span></span><br><span class="line"><span class="comment"> * 3.注册 channel（很复杂）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 没关注的问题：</span></span><br><span class="line"><span class="comment"> * Channel 的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 channel 实例</span></span><br><span class="line">        <span class="comment">// 内部是根据，之前通过反射获取的构造函数，创建 Channel 对象的，详见 ServerBootstrap#channel(...)</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类实现</span></span><br><span class="line">        <span class="comment">// 1. 设置了 channel 的 config、attr</span></span><br><span class="line">        <span class="comment">// 2. 把 ServerBootstrap 的 handler 加入 pipeline 中</span></span><br><span class="line">        init(channel);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常暂且不管了</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 bossGroup 线程池，注册 channel</span></span><br><span class="line">    <span class="comment">// 回忆一下，这个线程池的作用是连接客户端，然后分配给 workerGroup 执行</span></span><br><span class="line">    <span class="comment">// 这一步执行完，channel 就完全可用了</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ChannelFuture 的 cause 变量是异常信息，这里是在处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是 channel 注册的结果（DefaultChannelPromise）</span></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # init</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.设置 channel 的 config 和 attr</span></span><br><span class="line"><span class="comment"> * 2.往 pipeline 中加入 handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 AbstractBootstrap 父类的参数</span></span><br><span class="line">    <span class="comment">// 把 option 设置到 channel 的 config 里、把 attr 设置到 channel 的 attr 里</span></span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取刚刚创建的 Channel 对象的 pipeline</span></span><br><span class="line">    <span class="comment">// 现在它只有 head 和 tail 两个 handler 节点，下面将在中间添加一个新节点</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取了一些 ServerBootstrap 子类的成员变量</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在刚刚创建的 Channel 对象的 pipeline 中增加一个 handler</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个方法之后会调到，传进来的 channel 就是刚才的 channel（此时它已经 JDK 底层注册 selector，并且有 eventLoop 了）</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 拿到 channel 的 pipeline</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把最初 ServerBootstrap 中设置的 handler 参数，加到 pipeline 中</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是 channel 未来将有的 eventLoop，channel 执行的所有异步任务都交给它做</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 往 pipeline 中加入了一个 ServerBootstrapAcceptor，这个类继承自 ChannelInboundHandlerAdapter</span></span><br><span class="line">                    <span class="comment">// 这个 handler 的作用是接收客户端的请求</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— bind -pipeline#addLast —————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # addLast</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是 executor（线程池）</span></span><br><span class="line">    <span class="comment">// 如果是 null，之后会默认使用 channel 绑定的 eventLoop</span></span><br><span class="line">    <span class="comment">// 如果不是 null，可以指定一个 EventExecutorGroup（避免在 ChannelHandler 中使用阻塞操作）</span></span><br><span class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # addLast</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(handlers, <span class="string">"handlers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对多个 handler 逐个执行 addLast(...) 方法</span></span><br><span class="line">    <span class="comment">// 目前只有一个 handler，就是 ServerBootstrap 的 handler（此处是 LoggingHandler 对象）</span></span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # addLast</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.将 handler 加到 pipeline 链表中除了 tail 节点外的最后一个</span></span><br><span class="line"><span class="comment"> * 2.执行 handler 加入链表成功的回调事件（不一定直接能执行）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查 handler 是否重复添加、是否可以重复添加</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 handler 包装成 handlerContext（带 pipeline 上下文的 handler）</span></span><br><span class="line">        <span class="comment">// 后面不使用 handler，转而使用包装后的 handlerContext，以便 handler 能拿到 pipeline</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将包装过的 handler 加入 pipeline 链表当中</span></span><br><span class="line">        <span class="comment">// 实现就是 [xxx]&lt;-&gt;[tail] 变成 [xxx]&lt;-&gt;[handlerContext]&lt;-&gt;[tail]</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// —————————————————————————————————————————————————————</span></span><br><span class="line">        <span class="comment">// handler 加入 pipeline 之后，会执行 handler 的回调事件，比如 ChannelInitializer 就会把自己删除</span></span><br><span class="line">        <span class="comment">// 下面是在执行 handler 加入后的回调事件（回调事件是提交给线程池，异步执行的）</span></span><br><span class="line">        <span class="comment">// 下面有三条路，不论那条最后都会执行 callHandlerAdded0(...) 方法，也就是执行回调事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// registered 实际是指 channel 有没有被注册，现在还是 false，以后会看到它被赋值为 true</span></span><br><span class="line">        <span class="comment">// 当 channel 还没有被注册的时候，channel 绑定的 eventLoop 可能还没有被创建，即可能还没有线程池</span></span><br><span class="line">        <span class="comment">// 因此不能执行 handler 的回调事件，那么就先把这个 handler 记录下来，等以后注册完了再执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            <span class="comment">// 设置 handler 的状态为 ADD_PENDING，等待执行回调</span></span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            <span class="comment">// 记录下来这个 handler，等以后 channel 注册完了再执行它的回调事件</span></span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里代表 channel 被注册过，那么可以让线程池执行 handler 的回调事件了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程不是 eventLoop 线程，那么提交给 eventLoop 线程完成</span></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="comment">// 这个方法就执行了两行代码，handler 设置状态为 ADD_PENDING，然后异步提交 callHandlerAdded0(...) 方法</span></span><br><span class="line">            <span class="comment">// newCtx.setAddPending();</span></span><br><span class="line">            <span class="comment">// executor.execute(() -&gt; &#123; callHandlerAdded0(newCtx); &#125;);</span></span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程是 eventLoop 线程，直接执行</span></span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # callHandlerCallbackLater</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此时 channel 还没有注册</span></span><br><span class="line"><span class="comment"> * 保存 handlerContext，包装成 PendingHandlerCallback，存储在 pipeline 的 pendingHandlerCallbackHead 变量中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerCallbackLater</span><span class="params">(AbstractChannelHandlerContext ctx, <span class="keyword">boolean</span> added)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断言：channel 没有注册过（如果注册过，不需要来保存 handler，等待执行回调事件）</span></span><br><span class="line">    <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 handlerContext 包装成 PendingHandlerAddedTask</span></span><br><span class="line">    <span class="comment">// 这个类实现了 Runnable 接口，执行它的 execute() 方法，就可以执行 handler 的回调事件</span></span><br><span class="line">    <span class="comment">// 在后续代码，channel 注册之后，将执行 task.execute()，它内部会执行 callHandlerAdded0(...) 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// added 为 true 表示 HandlerAdd 任务，false 表示 HandlerRemove 任务</span></span><br><span class="line">    DefaultChannelPipeline.PendingHandlerCallback task = added ? <span class="keyword">new</span> DefaultChannelPipeline.PendingHandlerAddedTask(ctx) : <span class="keyword">new</span> DefaultChannelPipeline.PendingHandlerRemovedTask(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipeline 有一个成员变量：pendingHandlerCallbackHead</span></span><br><span class="line">    <span class="comment">// 这个变量存储的是【需要存储下来，等待执行回调事件的 handler】的链表头结点</span></span><br><span class="line">    <span class="comment">// 等后续 channel 注册之后，获取 pipeline 的这个变量，逐个触发全部 handler 的回调事件</span></span><br><span class="line">    DefaultChannelPipeline.PendingHandlerCallback pending = pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">if</span> (pending == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pendingHandlerCallbackHead = task;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (pending.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pending = pending.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pending.next = task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PendingHandlerAddedTask</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 后续代码将执行该类的 execute() 方法，内部在执行 callHandlerAdded0(...) 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerAddedTask</span> <span class="keyword">extends</span> <span class="title">DefaultChannelPipeline</span>.<span class="title">PendingHandlerCallback</span> </span>&#123;</span><br><span class="line">    PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="comment">// 父类的构造方法：this.ctx = ctx;</span></span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callHandlerAdded0(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventExecutor executor = ctx.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAdded0(ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executor.execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Can't invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;."</span>, executor, ctx.name(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                atomicRemoveFromHandlerList(ctx);</span><br><span class="line">                ctx.setRemoved();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面看完了 <code>initAndRegister()</code> 方法的 <code>init</code> 部分，接下来看 <code>register</code> 部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MultithreadEventLoopGroup # register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取一个 eventLoop，执行它的 register(...) 方法</span></span><br><span class="line"><span class="comment"> * 辗转后，实际上是在 channel.unsafe() 中执行的 register(...) 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个 EventLoop 线程</span></span><br><span class="line">    <span class="comment">// 具体不看了，最后返回 executors[idx.getAndIncrement() &amp; executors.length - 1]</span></span><br><span class="line">    <span class="keyword">return</span> next()</span><br><span class="line">            <span class="comment">// 注册，往下看</span></span><br><span class="line">            .register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SingleThreadEventLoop # register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册，往下看</span></span><br><span class="line">    <span class="keyword">return</span> register(</span><br><span class="line">            <span class="comment">// 这个构造方法不看了，就俩赋值</span></span><br><span class="line">            <span class="comment">// this.channel = channel</span></span><br><span class="line">            <span class="comment">// this.executor = executor（就是 EventLoop 线程）</span></span><br><span class="line">            <span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SingleThreadEventLoop # register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel 注册，往下看</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册的结果会放入 promise 中（异步），返回这个结果</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannel.AbstractUnsafe # register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.channel 设置 eventLoop 线程</span></span><br><span class="line"><span class="comment"> * 2.eventLoop 执行 register0() 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">"eventLoop"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果以前注册过，promise 设置失败</span></span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 eventLoop 线程类型是否是兼容的，如果不是 NioEventLoop 对象，promise 设置失败</span></span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此之后，channel 就是有 eventLoop 线程的了</span></span><br><span class="line">    <span class="comment">// channel 的所有异步操作，都将使用这个 eventLoop 完成</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发起 register 的线程就是 eventLoop 里的线程，直接执行 register0()（这里是不会的，以后 unregister 才会）</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// eventLoop 去执行 register0() 方法</span></span><br><span class="line">            eventLoop.execute(() -&gt; &#123; register0(promise); &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 异常暂且忽略</span></span><br><span class="line">            logger.warn(<span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>, AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannel.AbstractUnsafe # register0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK 底层注册，就执行了一行代码</span></span><br><span class="line">        <span class="comment">// selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span></span><br><span class="line">        <span class="comment">// 三个参数分别代表：【JDK 底层的 selector】【对所有事件都不感兴趣】【本 channel，这样以后就可以通过 selector 获取 channel】</span></span><br><span class="line">        doRegister();</span><br><span class="line"></span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 ChannelInitializer 内部添加的 handlers 添加到 pipeline 中</span></span><br><span class="line">        <span class="comment">// 我们接下来相当长的部分，都是在看这个方法</span></span><br><span class="line">        <span class="comment">// 这个方法执行完，pipeline 有关服务端的部分就已经全部完成了</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 promise 注册完成</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时 channel 已经被注册，通知所有关心这件事的 handler，让它们处理这件事</span></span><br><span class="line">        <span class="comment">// fire 这个词很形象，可以翻译成”传火“，让 pipeline 从 head 节点开始，一个个地去处理</span></span><br><span class="line">        <span class="comment">// 每一个订阅该事件的 handler 都会执行 channelRegistered(...) 方法，执行完之后找到下一个订阅的节点，让它再去执行</span></span><br><span class="line">        <span class="comment">// 这是一个递归的过程，总之就是让所有订阅 channel 注册事件的 handler，都去执行 channelRegistered(...) 方法</span></span><br><span class="line">        <span class="comment">// 比如 LoggingHandler 就会在 channelRegistered(...) 方法中执行【logger.log(internalLevel, format(ctx, "REGISTERED"));】</span></span><br><span class="line">        <span class="comment">// 这块的代码也比较复杂，不往里看了</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 JDK 的 channel 已经打开</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="comment">// 如果首次注册（是的）</span></span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// pipeline file 所有的 handler 响应 ChannelActive 事件（就是按顺序执行所有 handler 重写的 channelActive(...) 方法）</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// channel 之前就被注册过了，现在立即去监听通道内的 OP_READ 事件</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # invokeHandlerAddedIfNeeded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断言：当前线程就是 channel 绑定的线程</span></span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">        firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 在初始化 channel 设置 pipeline 时，我们将 ServerBootstrap 的 handler 变量保存起来</span></span><br><span class="line">        <span class="comment">// 因为当时 channel 还没有注册，还没有绑定 eventLoop，无法执行 handler 的回调事件</span></span><br><span class="line">        <span class="comment">// 现在可以执行 handler 的回调事件了</span></span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # callHandlerAddedForAllHandlers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAddedForAllHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultChannelPipeline.PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是 pipeline 的变量，是指 channel 是否已经注册，可以使用 channel 的 eventLoop 了</span></span><br><span class="line">        <span class="comment">// 这个变量我们已经在 pipeline 的 addLast() 方法中见过了，当时是 false，从现在开始变为 true</span></span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出当时 addLast(handler) 的 handler，当时没有执行 handler 的回调事件，现在准备来执行</span></span><br><span class="line">        pendingHandlerCallbackHead = <span class="keyword">this</span>.pendingHandlerCallbackHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.pendingHandlerCallbackHead = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipeline 之前存储了一些没有执行回调事件的 handler，他们排成了一个链表，pipeline 存储了链表头</span></span><br><span class="line">    <span class="comment">// 现在逐个执行这些 handler 的回调事件</span></span><br><span class="line">    DefaultChannelPipeline.PendingHandlerCallback task = pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行 handler 的回调事件</span></span><br><span class="line">        <span class="comment">// 回去看 pipeline 的 addLast(...) 的代码，会发现这行代码实际上在执行 callHandlerAdded0(...)</span></span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们到这里回忆一下</span></span><br><span class="line"><span class="comment">// 在之前初始化 channel 时，设置了 pipeline，将 ServerBootstrap 的 handler 包装起来加入到 pipeline 链表中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span></span><br><span class="line"><span class="comment">//     @Override</span></span><br><span class="line"><span class="comment">//     public void initChannel(final Channel ch) &#123;</span></span><br><span class="line"><span class="comment">//        ...</span></span><br><span class="line"><span class="comment">//        pipeline.addLast(handler);</span></span><br><span class="line"><span class="comment">//        ...</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 也就是说，pipeline 加入了一个 handler（一个 ChannelInitializer 实例），它里面包着 ServerBootstrap 的 handler</span></span><br><span class="line"><span class="comment">// pipeline 加入了这个 handler 之后，要执行回调事件 callHandlerAdded0(...)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 但是回调事件只能在 channel 绑定的 eventLoop 中执行，此时还没有绑定 eventLoop</span></span><br><span class="line"><span class="comment">// 因此只好先存储一下 handler，等待之后 channel 注册完成，绑定了 eventLoop 后再执行 handler 的回调事件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当时将 handler 又包装了一层，包装成了 PendingHandlerCallback 实例</span></span><br><span class="line"><span class="comment">// 这是一个实现了 Runnable 接口的类，handler 的回调事件，被放进了 Runnable 的 execute() 方法中</span></span><br><span class="line"><span class="comment">// 这里的 task 实际上就是当初包装后的 PendingHandlerCallback</span></span><br><span class="line"><span class="comment">// 这里执行 task.execute() 方法，实际上就是在执行 handler 的回调事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # callHandlerAdded0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * （省略了一个方法）task.execute() -&gt; callHandlerAdded0(ctx)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 ctx 就是 handlerContext，之前被包装过的 handler</span></span><br><span class="line">        <span class="comment">// 执行它的回调事件</span></span><br><span class="line">        ctx.callHandlerAdded();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常不去看了</span></span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            atomicRemoveFromHandlerList(ctx);</span><br><span class="line">            ctx.callHandlerRemoved();</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to remove a handler: "</span> + ctx.name(), t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(ctx.handler().getClass().getName() + <span class="string">".handlerAdded() has thrown an exception; removed."</span>, t));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(ctx.handler().getClass().getName() + <span class="string">".handlerAdded() has thrown an exception; also failed to remove."</span>, t));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannelHandlerContext # callHandlerAdded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">callHandlerAdded</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 先设置 handlerContext 的状态是 ADD_COMPLETE</span></span><br><span class="line">    <span class="keyword">if</span> (setAddComplete()) &#123;</span><br><span class="line">        <span class="comment">// 执行内部包着的 handler 的回调事件</span></span><br><span class="line">        handler().handlerAdded(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelInitializer # handlerAdded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 确保 channel 已经被注册</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        <span class="comment">// 执行 initChannel(...) 方法，往里看，柳暗花明</span></span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">            <span class="comment">// 这里并不是在 pipeline 中删除自己，只是标记一下状态</span></span><br><span class="line">            removeState(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelInitializer # initChannel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 防止加载多次，先记录下来这个（避免并发）</span></span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这个方法我们之前使用过</span></span><br><span class="line">            <span class="comment">// ChannelInitializer 是一个抽象类，每次实例化必须要实现它的 initChannel(...) 方法</span></span><br><span class="line">            <span class="comment">// 我们之前创建 ChannelInitializer 对象的时候，就重写过这个方法了</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// 异常处理不看了</span></span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在 pipeline 中删掉 ChannelInitializer 对象，它的作用已经结束了</span></span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 至此，我们的 pipeline 有关服务端的部分已经完成了</span></span><br><span class="line">            <span class="comment">// 它的内部是：head &lt;-&gt; ServerBootstrap 的 handler &lt;-&gt; 用于接收客户端请求的 handler &lt;-&gt; tail</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # init</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回想一下这个方法</span></span><br><span class="line"><span class="comment"> * bind() -&gt; doBind() -&gt; initAndRegister() -&gt; init()</span></span><br><span class="line"><span class="comment"> * 此时 channel 刚刚创建，正在初始化它，这个方法就是在初始化，设置 channel 的 pipeline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 channel 的 options 和 attrs 参数</span></span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出一堆东西来，准备初始化 pipeline</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Map.Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 pipeline 中加入一个 ChannelInitializer，这里面包着 ServerBootstrap 的 handler</span></span><br><span class="line">    <span class="comment">// 创建 ChannelInitializer 对象，必须要重写它的 initChannel 方法</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们终于看到这个方法被执行了</span></span><br><span class="line">        <span class="comment">// 回忆一下：</span></span><br><span class="line">        <span class="comment">// 1. 我们在初始化 channel 时，设置 pipeline，往里面加入了一个 ChannelInitializer 对象，里面装着 handler</span></span><br><span class="line">        <span class="comment">//    执行 pipeline.addLast(...) 方法时，将这个被包装的 handler 加入到 pipeline 的尾部</span></span><br><span class="line">        <span class="comment">// 2. 每一个 handler 加入 pipeline 之后，都要执行回调事件（对于 ChannelInitializer，是把它内部 handler 们加入到 pipeline 中，再删除掉自己）</span></span><br><span class="line">        <span class="comment">//    但是回调事件是需要异步完成的，需要 channel 绑定的 eventLoop 线程来执行，但是此时 channel 还没有被注册</span></span><br><span class="line">        <span class="comment">//    因此先把这个 handler 存储下来，先包装成 handlerContext，再包装成 pendingHandlerCallback，以链表的形式存储在 pipeline 中</span></span><br><span class="line">        <span class="comment">// 3. 当 channel 被注册之后，channel 有了 eventLoop，可以执行 handler 的回调事件了</span></span><br><span class="line">        <span class="comment">//    此时取出 pipeline 的 pendingHandlerCallback，取出里面的 handlerContext</span></span><br><span class="line">        <span class="comment">//    给 eventLoop 提交一个任务，让它去执行 handler 的回调事件，ChannelInitializer 的回调事件是执行 initChannel(...)，最终一步步走到了这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 pipeline</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 ServerBootstrap 的 handler</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 handler 加入到 pipeline 中，这个 handler 的回调事件可以直接执行</span></span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里还往 pipeline 中加入了一个 handler</span></span><br><span class="line">            <span class="comment">// 这个 handler 的作用是接收客户端请求</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有大量的代码在处理 handler，下面画一张图，来描述一下 handler 是如何从 ServerBootstrap 加入到 pipeline 中的。</p>
<p><img src="/assets/netty_pipeline.jpg" alt="netty_pipeline"></p>
<p>还有最后一点代码，把 <code>bind0()</code> 方法看完。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # doBind</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 很早之前的方法了，最开始的时候</span></span><br><span class="line"><span class="comment"> * 此时 channel 已经创建并注册好了，要执行绑定端口的操作了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 channel 已经完成初始化的代码（异步执行，可能还没完成）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经完成注册，在当前线程执行 doBind0(...) 方法</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有完成注册，给注册 future 增加一个完成后的回调，让它完成后去调用 doBind0(...) 方法</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此时没有注册完成，channel 还不一定有绑定的 eventLoop，不能让 channel 生成 promise</span></span><br><span class="line">        <span class="comment">// 因此创建一个 PendingRegistrationPromise 对象</span></span><br><span class="line">        <span class="keyword">final</span> AbstractBootstrap.PendingRegistrationPromise promise = <span class="keyword">new</span> AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 怎么加监听，以及完成后处理监听的逻辑就暂且忽略了</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 完成后的回调方法 operationComplete</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 如果 channel 注册失败，就记录失败</span></span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 channel 注册成功，执行 doBind0(...)</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录注册成功</span></span><br><span class="line">                    promise.registered();</span><br><span class="line">                    <span class="comment">// 执行 doBind0(...) 方法</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # doBind0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// 在 channel 注册成功的前提下，绑定端口</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannel # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannelHandlerContext # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(localAddress, <span class="string">"localAddress"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查一下 promise 的类型等要素，如果有问题直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个对订阅【绑定事件】的 outbound handler</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 handler 归属 channel 的 eventLoop，执行 invokeBind(...) 方法</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 直接加载 invokeBind(...) 方法</span></span><br><span class="line">        next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// eventLoop 懒加载 invokeBind(...) 方法</span></span><br><span class="line">        safeExecute(executor, () -&gt; &#123; next.invokeBind(localAddress, promise); &#125;, promise, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannelHandlerContext # invokeBind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测该 handler 是否加入到 pipeline 中</span></span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 该 handler 执行绑定事件</span></span><br><span class="line">            <span class="comment">// 每个 handler 的执行内容都不相同，比如 LoggingHandler 就是打印 ”BIND“</span></span><br><span class="line">            <span class="comment">// 但是每个 handler 执行完之后，都会再次调用 AbstractChannelHandlerContext#bind() 方法，继续执行下去</span></span><br><span class="line">            <span class="comment">// 执行到最后，会执行到 head 节点，执行它的 bind(...) 方法，往下看</span></span><br><span class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果该 handler 还没有初始化完成，跳过它，执行下一个 handler 的绑定</span></span><br><span class="line">        bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline$HeadContext # bind</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * head handler 的 bind(...) 方法</span></span><br><span class="line"><span class="comment"> * 真正的绑定端口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 unsafe 类来执行 bind(...) 方法</span></span><br><span class="line">    <span class="comment">// 底层是通过 JDK 的 channel 来实现绑定端口的，不看了</span></span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就写到这里吧。</p>
]]></content>
      <tags>
        <tag>Weekly Post</tag>
      </tags>
  </entry>
</search>
