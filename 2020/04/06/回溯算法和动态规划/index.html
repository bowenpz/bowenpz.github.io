<!DOCTYPE html>
<html lang=Ch>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="四月的第二周，开始学习算法题：回溯算法。 在二月底就零星地看了一些算法题，当时想着从四月份开始突击一个月的算法，但因为看 Java 并发耽误了一周。从本周开始，博文内容将全部是算法。  回溯（backtracking）是暴力搜索法中的一种，它采用试错的思想，尝试分布地解决一个问题，在分步解决问题的过程中，当它通过尝试，发现现有的分步答案不能得到有效的正确解答时，它将取消上一步甚至是上几步的计算">
<meta name="keywords" content="Weekly Post">
<meta property="og:type" content="article">
<meta property="og:title" content="算法：回溯">
<meta property="og:url" content="http://hellopz.netlify.com/2020/04/06/回溯算法和动态规划/index.html">
<meta property="og:site_name" content="这里是pz阁下">
<meta property="og:description" content="四月的第二周，开始学习算法题：回溯算法。 在二月底就零星地看了一些算法题，当时想着从四月份开始突击一个月的算法，但因为看 Java 并发耽误了一周。从本周开始，博文内容将全部是算法。  回溯（backtracking）是暴力搜索法中的一种，它采用试错的思想，尝试分布地解决一个问题，在分步解决问题的过程中，当它通过尝试，发现现有的分步答案不能得到有效的正确解答时，它将取消上一步甚至是上几步的计算">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://hellopz.netlify.com/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg">
<meta property="og:image" content="http://hellopz.netlify.com/assets/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.jpg">
<meta property="og:image" content="http://hellopz.netlify.com/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg">
<meta property="og:updated_time" content="2020-04-13T00:57:37.428Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="算法：回溯">
<meta name="twitter:description" content="四月的第二周，开始学习算法题：回溯算法。 在二月底就零星地看了一些算法题，当时想着从四月份开始突击一个月的算法，但因为看 Java 并发耽误了一周。从本周开始，博文内容将全部是算法。  回溯（backtracking）是暴力搜索法中的一种，它采用试错的思想，尝试分布地解决一个问题，在分步解决问题的过程中，当它通过尝试，发现现有的分步答案不能得到有效的正确解答时，它将取消上一步甚至是上几步的计算">
<meta name="twitter:image" content="http://hellopz.netlify.com/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>算法：回溯</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/2019/07/21/helloworld/">About</a></li>
         
          <li><a href="/tags/Weekly-Post/">Weekly Post</a></li>
         
          <li><a href="/tags/Random-Post/">Random Post</a></li>
         
          <li><a href="/tags/tips/">Tips</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2020/04/05/Lock/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://hellopz.netlify.com/2020/04/06/回溯算法和动态规划/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://hellopz.netlify.com/2020/04/06/回溯算法和动态规划/&text=算法：回溯"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://hellopz.netlify.com/2020/04/06/回溯算法和动态规划/&is_video=false&description=算法：回溯"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode39-组合总和"><span class="toc-number">1.</span> <span class="toc-text">LeetCode39 组合总和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode46-全排列"><span class="toc-number">2.</span> <span class="toc-text">LeetCode46 全排列</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        算法：回溯
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">这里是pz阁下</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-04-06T09:03:42.000Z" itemprop="datePublished">2020-04-06</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Weekly-Post/">Weekly Post</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <br>

<p>四月的第二周，开始学习算法题：回溯算法。</p>
<p>在二月底就零星地看了一些算法题，当时想着从四月份开始突击一个月的算法，但因为看 Java 并发耽误了一周。从本周开始，博文内容将全部是算法。</p>
<hr>
<p>回溯（backtracking）是暴力搜索法中的一种，它采用试错的思想，尝试分布地解决一个问题，在分步解决问题的过程中，当它通过尝试，发现现有的分步答案不能得到有效的正确解答时，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。</p>
<p>回溯是基于深度优先遍历（DFS）的一种暴力搜索方法，因此使用回溯算法的前提是，问题本身的数据结构是树，在树的基础上采取 DFS 的方式遍历，在遍历的过程中，保存符合题目条件的叶子节点。</p>
<p>举一个例子，比如全排列问题（给定几个数字，返回所有可能的全排列），这个问题本身就是一棵树，以[1, 2, 3]这三个数字为例，可以画成如下的树。这一类的问题我们可以通过回溯算法解决。</p>
<p><img src="/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg" alt="树示例"></p>
<p>回溯算法的内核是遍历，如果一个问题能够转化为树，就可以通过回溯算法，遍历树的每一片叶子，暴力解决。在这一背景之下，回溯算法还有以下特征：</p>
<ol>
<li>遍历树的方式是递归，因此回溯是通过递归解决的。</li>
<li>遍历树时，收集叶子（收集结果）往往有约束，比如要求结果不能重复（[1, 2]和[2, 1]只保留其中一个），收集时要根据要求收集。</li>
<li>遍历树时，在知道某些分支下一定不可能出现结果，就可以忽略遍历这部分，这被称为“剪枝”，是回溯算法提高性能的主要方式。</li>
</ol>
<br>

<p>下面试着整理一下套路，但是就我个人经验而言，背过了套路也用处不大，多做一点题目就会慢慢熟悉起来。推荐的做题路线是（使用 LeetCode），39 题 -&gt; 46 题 -&gt; 77 题 -&gt; 78 题 -&gt; 40 题 -&gt; 47 题 -&gt; 90 题，都比较简单，是用来培养手感的。</p>
<p><strong>先铭记最重要的一条，做回溯算法题，第一步，先画树，画完了再做题。</strong></p>
<p>回溯算法的主要流程是：试探 - 子递归 - 回溯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">doSub(list, ...)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    list.add(item);               <span class="comment">// 试探着加入一个元素</span></span><br><span class="line">    doSub(list, ...);             <span class="comment">// 子递归</span></span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>); <span class="comment">// 把刚才试探加入的元素删掉</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是先加入一个元素，执行子递归操作，再删除掉刚才加的元素。这个套路我们一会在真题中使用。</p>
<p>初学时由于递归使用得少，因此对递归的结构、递归的方法参数，通常会苦恼很久。在初始阶段，可以试着这么写递归：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最终的结果可以记在全局变量中，不设置返回值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSub</span><span class="params">(List candidates, <span class="keyword">int</span> level, Object tem)</span> </span>&#123;</span><br><span class="line">                           成员         递归层数    本级递归的结果</span><br><span class="line">                               </span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (成功条件，准备记录结果) &#123;</span><br><span class="line">        <span class="comment">// 记录结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        doSub(candidates, level + <span class="number">1</span>, tem);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常递归需要三个参数：操作的所有元素、递归的层数（通常用于判断什么时候要终止递归）、本级递归的结果（成功后，将参数记录下来）。这么写可能会有冗余代码（ if 的判断条件），但是按照这种思路来写，通常能写出来递归的骨架，然后再慢慢调整。</p>
<p>除了这三个参数之外，通常递归还需要其他参数，这个需要具体分析。就我做题而言，一般是需要增加两种参数，一会做题时详述。</p>
<br>

<h1 id="LeetCode39-组合总和"><a href="#LeetCode39-组合总和" class="headerlink" title="LeetCode39 组合总和"></a>LeetCode39 组合总和</h1><blockquote>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。</p>
<table>
<thead>
<tr>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td>candidates = [2,3,6,7], target = 7</td>
<td>[<br>&nbsp;&nbsp;[7],<br>&nbsp;&nbsp;[2,2,3]<br>]</td>
</tr>
<tr>
<td>candidates = [2,3,5], target = 8</td>
<td>[<br>&nbsp;&nbsp;[2,2,2,2],<br>&nbsp;&nbsp;[2,3,3],<br>&nbsp;&nbsp;[3,5]<br>]</td>
</tr>
</tbody></table>
</blockquote>
<p>先画树（其实只需要画出终止条件和满足条件就足够分析了）：</p>
<p><img src="/assets/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.jpg" alt="组合总和"></p>
<p>主要的逻辑是递归树</p>
<ul>
<li>如果求和不足，那么继续递归</li>
<li>如果求和正好，那么记录结果，返回（返回后删除，进行下一次循环）</li>
<li>如果求和超了，那么返回（返回后删除，进行下一次循环）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode39</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combinationSum方法返回的是什么，就直接在此定义一个该类型的变量，作为全局变量，最后直接返回该变量就可以了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 很多算法题的测试数据都会搞些数据恶心人，比如输入参数为空字符串，要预过滤</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == candidates || candidates.length == <span class="number">0</span> || target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 核心逻辑，本方法是一个无返回值的方法，因为结果记录在一个全局变量result里，省去了处理返回</span></span><br><span class="line">        process(candidates, target, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解释一下核心逻辑，每进入下一层树，在list中增加一个数字，再进入下一层递归</span></span><br><span class="line">    <span class="comment">// 直到求和相同时，记录求和内容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一步：先处理递归终止条件，此题是判断</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 第二步：当递归抵达成功时，记录结果</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意深拷贝</span></span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        <span class="comment">// 第三步：当递归没终止、没成功，准备进入下一层递归</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历所有节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 先加</span></span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                <span class="comment">// 递归</span></span><br><span class="line">                process(candidates, target - candidates[i], list);</span><br><span class="line">                <span class="comment">// 再删，删完出循环，准备再进循环加下一个</span></span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是基础套路：</p>
<ol>
<li><p>定义一个全局变量记录结果</p>
</li>
<li><p>递归处理</p>
<ol>
<li><p>先处理递归终止，直接返回</p>
</li>
<li><p>再处理递归成功，记录结果后返回</p>
</li>
<li><p>没终止、没成功，就意味着还需要继续递归</p>
<p>在循环中执行回溯算法的核心</p>
<ol>
<li>先加</li>
<li>递归</li>
<li>再删</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>执行上述方法，得到这样的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LeetCode39.combinationSum(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, <span class="number">7</span>);</span><br><span class="line"><span class="comment">// 结果 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]</span></span><br></pre></td></tr></table></figure>

<p>会发现结果没有去重，出现了[2, 2, 3]和[2, 3, 2]这样内容一样但是排序不一样的情况，我们来分析一下如何去重。</p>
<p>重复的主要原因在于，当我们记录完[2, 2, ?]之后，进入[2, 3, ?]，选择第三个数时，我们不应当再考虑 2 了，因为在[2, 2, ?]的情况下，我们已经全部处理完有 2 的情况了，再之后我们不应该处理 2 了。细琢磨一下这句话：遍历时我们要设置一个起始点，处理过的要素，之后就跳过不参与考虑了。</p>
<p>这是递归新增参数的第一种情况，增加一个 <code>int start</code> 的参数，目的是为了在遍历时，从 start 位置开始，跳过某些元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;Integer&gt; list, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ... </span></span><br><span class="line">    <span class="comment">// 每次遍历从start开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="LeetCode46-全排列"><a href="#LeetCode46-全排列" class="headerlink" title="LeetCode46 全排列"></a>LeetCode46 全排列</h1><blockquote>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<table>
<thead>
<tr>
<th>示例输入</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td>[1,2,3]</td>
<td>[<br>&nbsp;&nbsp;[1,2,3],<br>&nbsp;&nbsp;[1,3,2],<br>&nbsp;&nbsp;[2,1,3],<br>&nbsp;&nbsp;[2,3,1],<br>&nbsp;&nbsp;[3,1,2],<br>&nbsp;&nbsp;[3,2,1]<br>]</td>
</tr>
</tbody></table>
</blockquote>
<p>同样，还是先画递归树：</p>
<p><img src="/assets/%E6%A0%91%E7%A4%BA%E4%BE%8B.jpg" alt="树示例"></p>
<p>直接写代码了噢，是完全一样的套路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode46</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == nums || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] select = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        doPermute(nums, <span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;(), select);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPermute</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> level, List&lt;Integer&gt; list, <span class="keyword">boolean</span>[] select)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &gt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (select[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    select[i] = <span class="keyword">true</span>;</span><br><span class="line">                    doPermute(nums, level + <span class="number">1</span>, list, select);</span><br><span class="line">                    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">                    select[i] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里递归在原先的三个参数基础上，又增加了一个新的参数，<code>boolean[] select</code>，一个布尔值的数组。</p>
<p>对于某些题目，就比如这道题，每个元素并不是可以无限使用的，而是只能只用一次，如果使用完一次，怎么标记下来呢，就是使用一个布尔值的数组，记录下标为x的元素，已经被使用过了，不能再使用。</p>
<p>回溯套路，就从原来的三行，变成了五行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.add(nums[i]);                   -&gt;   list.add(nums[i]);</span><br><span class="line">                                     -&gt;   select[i] = <span class="keyword">true</span>;</span><br><span class="line">doPermute(nums, level + <span class="number">1</span>, list);    -&gt;   doPermute(nums, level + <span class="number">1</span>, list, select);</span><br><span class="line">                                     -&gt;   select[i] = <span class="keyword">false</span>;</span><br><span class="line">list.remove(list.size() - <span class="number">1</span>);        -&gt;   list.remove(list.size() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>（上一道题每个元素可以无限制地使用，因此不需要一个布尔值数组记录是否能使用）</p>
<br>

<p>上面的套路，只是初期不熟悉时的套路，并不能解决所有回溯问题，但是可以在初接触回溯问题时尝试做出来。最好的学习方式仍然是做题，做十几道题，就自然明白了。再发一遍学习路线（LeetCode）：39 题 -&gt; 46 题 -&gt; 77 题 -&gt; 78 题 -&gt; 40 题 -&gt; 47 题 -&gt; 90 题。</p>

  </div>
</article>



    </div>
    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 pz
  </div>
  <div class="footer-right">
    <nav>
      pz阁下的blog
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



