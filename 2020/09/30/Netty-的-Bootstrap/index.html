<!DOCTYPE html>
<html lang=Ch>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="没有想到，整整一个九月，就看了 Netty 的一个方法。 九月份学习完 ServerBootstrap，下个月就先不看 Netty 了，换一换脑子。  在上一篇博文中，我们初识了 Netty，知道了它是基于 NIO 的异步非阻塞 I/O 框架，它能做很多事情但它也有很多类。 Netty 进行 I/O 操作是靠 NIO 的 Channel 类实现的，不过 Netty 自己也有一个 Channel">
<meta name="keywords" content="Weekly Post">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 的 Bootstrap">
<meta property="og:url" content="http://hellopz.netlify.com/2020/09/30/Netty-的-Bootstrap/index.html">
<meta property="og:site_name" content="这里是pz阁下">
<meta property="og:description" content="没有想到，整整一个九月，就看了 Netty 的一个方法。 九月份学习完 ServerBootstrap，下个月就先不看 Netty 了，换一换脑子。  在上一篇博文中，我们初识了 Netty，知道了它是基于 NIO 的异步非阻塞 I/O 框架，它能做很多事情但它也有很多类。 Netty 进行 I/O 操作是靠 NIO 的 Channel 类实现的，不过 Netty 自己也有一个 Channel">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://hellopz.netlify.com/assets/Netty_Bootstrap.jpg">
<meta property="og:image" content="http://hellopz.netlify.com/assets/ServerBootstrap%E5%88%9D%E5%A7%8B%E5%8C%96.jpg">
<meta property="og:image" content="http://hellopz.netlify.com/assets/ServerBootstrap%E8%AE%BE%E7%BD%AE.jpg">
<meta property="og:image" content="http://hellopz.netlify.com/assets/bootstrap%E9%85%8D%E7%BD%AE%E5%A5%97%E8%B7%AF.png">
<meta property="og:image" content="http://hellopz.netlify.com/assets/netty_pipeline.jpg">
<meta property="og:updated_time" content="2020-09-30T08:44:51.147Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty 的 Bootstrap">
<meta name="twitter:description" content="没有想到，整整一个九月，就看了 Netty 的一个方法。 九月份学习完 ServerBootstrap，下个月就先不看 Netty 了，换一换脑子。  在上一篇博文中，我们初识了 Netty，知道了它是基于 NIO 的异步非阻塞 I/O 框架，它能做很多事情但它也有很多类。 Netty 进行 I/O 操作是靠 NIO 的 Channel 类实现的，不过 Netty 自己也有一个 Channel">
<meta name="twitter:image" content="http://hellopz.netlify.com/assets/Netty_Bootstrap.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Netty 的 Bootstrap</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/2019/07/21/helloworld/">About</a></li>
         
          <li><a href="/tags/Weekly-Post/">Weekly Post</a></li>
         
          <li><a href="/tags/Random-Post/">Random Post</a></li>
         
          <li><a href="/tags/tips/">Tips</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2020/09/18/Prometheus-监控方案简述/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://hellopz.netlify.com/2020/09/30/Netty-的-Bootstrap/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://hellopz.netlify.com/2020/09/30/Netty-的-Bootstrap/&text=Netty 的 Bootstrap"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://hellopz.netlify.com/2020/09/30/Netty-的-Bootstrap/&is_video=false&description=Netty 的 Bootstrap"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ServerBootstrap"><span class="toc-number">1.</span> <span class="toc-text">ServerBootstrap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bootstrap"><span class="toc-number">2.</span> <span class="toc-text">Bootstrap</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Netty 的 Bootstrap
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">这里是pz阁下</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-09-30T10:12:33.000Z" itemprop="datePublished">2020-09-30</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Weekly-Post/">Weekly Post</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <br>

<p>没有想到，整整一个九月，就看了 Netty 的一个方法。</p>
<p>九月份学习完 ServerBootstrap，下个月就先不看 Netty 了，换一换脑子。</p>
<hr>
<p>在上一篇博文中，我们初识了 Netty，知道了它是基于 NIO 的异步非阻塞 I/O 框架，它能做很多事情但它也有很多类。</p>
<p>Netty 进行 I/O 操作是靠 NIO 的 Channel 类实现的，不过 Netty 自己也有一个 Channel 类，它内部包着 NIO 的 Channel（有点绕）。Netty 的 Channel 类有特别多的变量，它几乎包含着 I/O 操作所需要的全部东西，因此创建一个 Channel 并设置参数，是一件相当复杂的事。Netty 考虑到这一点，提供了 Bootstrap 类，这个类就是为创建 Channel 而生的，它的作用就是方便快捷地创建 Channel。</p>
<p>再看一遍这句解释，体会一下 Bootstrap 的作用：</p>
<blockquote>
<p>AbstractBootstrap is a helper class that makes it easy to bootstrap a Channel.</p>
</blockquote>
<p>上面所说的 AbstractBootstrap 是一切 Netty 中 Bootstrap 的父类，我们今天要学习的是两种 Bootstrap：<code>ServerBootstrap</code> 和 <code>Bootstrap</code>。前者 <code>ServerBootstrap</code> 用来创建服务端 Channel，后者 <code>Bootstrap</code> 用来创建客户端 Channel。</p>
<p>回顾一下服务端和客户端。（粗浅地讲）服务端提供中心服务功能，暴露出来一个端口，用户那边的客户端，可以通过刚才那个端口连接到服务端。服务端和客户端通过同一个端口进行 I/O 操作，服务端绑定（bind）端口，客户端连接（connect）端口，两边都连好了，就可以通信了。</p>
<p>ServerBootstrap 和 Bootstrap 可以各自通过 bind(…) 和 connect(…) 方法，生成一个 ChannelFuture 实例，这个 ChannelFuture 实例就代表着 I/O 操作的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// serverBootstrap 绑定端口 8080</span></span><br><span class="line">ChannelFuture serverFuture = serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line"><span class="comment">// bootstrap 连接端口 127.0.0.1:8080</span></span><br><span class="line">ChannelFuture clientFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>在 serverBootstrap 执行 bind(…) 方法时，它将隐含地创建 Netty 的 Channel 实例，并把自己的参数都设置到 Channel 身上，这也就是我们刚才说的，Bootstrap 的作用就是方便快捷地创建 Channel 实例（实际上我们从始至终都没看到 Channel 实例）。对于 bootstrap 也是一样，它执行 connect(…) 方法时也会隐含地创建一个 Channel 实例，设置好参数，连接端口，最后返回一个 ChannelFuture。</p>
<p>重新梳理一遍：</p>
<ul>
<li>ServerBootstrap 和 Bootstrap 各自用来快速创建<code>服务端的 Channel</code> 和<code>客户端的 Channel</code>，并用这个 Channel 来进行 I/O 操作（这个过程对外是隐藏的）。</li>
<li>ServerBootstrap 对象执行 bind(…) 方法，绑定端口，这个过程中会隐含地创建<code>服务端的 Channel</code>。</li>
<li>Bootstrap 对象执行 connect(…) 方法，连接端口，这个过程中会隐含地创建<code>客户端的 Channel</code>。</li>
</ul>
<p>如果到这里不能理解，那么接下去的内容应该也不用看了。</p>
<p>下面先不提 bind(…) 和 connect(…) 方法，先开始讲 ServerBootstrap 和 Bootstrap 是怎么创建的，又是怎么设置复杂的参数的。</p>
<hr>
<p><img src="/assets/Netty_Bootstrap.jpg" alt="Netty_Bootstrap"></p>
<h1 id="ServerBootstrap"><a href="#ServerBootstrap" class="headerlink" title="ServerBootstrap"></a>ServerBootstrap</h1><p>服务端 Channel 的引导类。</p>
<p>虽说是“方便快捷”地创建 Channel，但其实代码还挺多的。下面是示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 ServerBootstrap</span></span><br><span class="line">ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line"><span class="comment">// 配置 ServerBootstrap</span></span><br><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> DiscardServerHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">        .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">        .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>ServerBootstrap 继承自 AbstractBootstrap，两个类的实例变量加在一起有 11 个，基本都有用处。</p>
<p><img src="/assets/ServerBootstrap%E5%88%9D%E5%A7%8B%E5%8C%96.jpg" alt="ServerBootstrap初始化"></p>
<p>最开始的代码就是为了设置这些变量，ServerBootstrap 实例调了 6 个方法设置好了 7 个参数，设置的过程可以参照下图：</p>
<p><img src="/assets/ServerBootstrap%E8%AE%BE%E7%BD%AE.jpg" alt="ServerBootstrap设置"></p>
<p>简单地过一遍这些变量，都是用来做什么的：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>channelFactory</td>
<td>ServerBootstrap 是服务端 Channel 的引导类，它是用来快速创建并配置 Channel 的，而创建 Channel 就是通过这个变量，利用工厂方法创建的</td>
</tr>
<tr>
<td>group</td>
<td>这是一个线程池（boss），它的作用是连接，在绑定端口之后接收连接，每接到一个连接，指派给 childGroup 去做 I/O 操作</td>
</tr>
<tr>
<td>childGroup</td>
<td>这也是一个线程池（worker），它的作用是 I/O，也就是负责具体的 I/O 操作，一个线程负责一个 Channel 的 I/O</td>
</tr>
<tr>
<td>handler</td>
<td>设置 ChannelHandler，用于处理服务端 Channel 的发送</td>
</tr>
<tr>
<td>childHandler</td>
<td>设置 ChannelHandler，用于处理客户端 Channel 的接收</td>
</tr>
<tr>
<td>option</td>
<td>设置服务端 Channel 的选项参数</td>
</tr>
<tr>
<td>childOption</td>
<td>设置客户端 Channel 的选项参数</td>
</tr>
<tr>
<td>config</td>
<td>其实就是 Bootstrap 对象自身（this），作用是在父类的方法中，也能获得本对象的一些参数</td>
</tr>
</tbody></table>
<p>写累了，看代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* —————————————————————————— group —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【parentGroup】和【childGroup】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # group</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.childGroup = ObjectUtil.checkNotNull(childGroup, <span class="string">"childGroup"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # group</span></span><br><span class="line"><span class="comment"> * 父类的 group(...) 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(group, <span class="string">"group"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"group set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.group = group;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— channel —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【channelFactory】</span></span><br><span class="line"><span class="comment">// 传入的是 Channel 子类，取它的构造方法，封装成 channelFactory，以后用它创建 channel</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ReflectiveChannelFactory 类的构造方法一直往下看</span></span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(</span><br><span class="line">            ObjectUtil.checkNotNull(channelClass, <span class="string">"channelClass"</span>)</span><br><span class="line">    ));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(io.netty.channel.ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channelFactory((ChannelFactory&lt;C&gt;) channelFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(channelFactory, <span class="string">"channelFactory"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"channelFactory set already"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个类继承自 ChannelFactory</span></span><br><span class="line"><span class="comment"> * 通过反射获取指定 Channel 类的构造方法，以后用 constructor 生产 channel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(clazz, <span class="string">"clazz"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.constructor = clazz.getConstructor();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Class "</span> + StringUtil.simpleClassName(clazz) +</span><br><span class="line">                <span class="string">" does not have a public non-arg constructor"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— childHandler —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【childHandler】</span></span><br><span class="line"><span class="comment">// 这里传入的是 ChannelInitializer，它是 ChannelHandler 的子类，相当于一个大的 handler，里面套着很多小 handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # childHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.childHandler = ObjectUtil.checkNotNull(childHandler, <span class="string">"childHandler"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— handler —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【handler】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # handler</span></span><br><span class="line"><span class="comment"> * 父类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">handler</span><span class="params">(ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = ObjectUtil.checkNotNull(handler, <span class="string">"handler"</span>);</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— option —————————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【options】</span></span><br><span class="line"><span class="comment">// 在 options（一张 LinkedHashMap）中增加 [option - value] 键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # option</span></span><br><span class="line"><span class="comment"> * 父类实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(option, <span class="string">"option"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            options.remove(option);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            options.put(option, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————— childOptions —————————————————————— */</span></span><br><span class="line"><span class="comment">// 设置【childOptions】</span></span><br><span class="line"><span class="comment">// 在 childOptions（一张 LinkedHashMap）中增加 [option - value] 键值对</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # childOption</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ServerBootstrap <span class="title">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(childOption, <span class="string">"childOption"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            childOptions.remove(childOption);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            childOptions.put(childOption, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>客户端 Channel 的引导类。</p>
<p>Bootstrap 相比 ServerBootstrap，只有减少没有增加，简单看一个示例就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Bootstrap</span></span><br><span class="line">Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"><span class="comment">// 配置 Bootstrap</span></span><br><span class="line">bootstrap.group(workerGroup)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>应该能看出一点套路了。</p>
<p>下图来自《<a href="https://www.javadoop.com/post/netty-part-1" target="_blank" rel="noopener">Netty 源码解析系列</a>》，是 ServerBootstrap 和 Bootstrap 的使用套路，再感受一下。</p>
<p><img src="/assets/bootstrap%E9%85%8D%E7%BD%AE%E5%A5%97%E8%B7%AF.png" alt="bootstrap配置套路"></p>
<hr>
<p>接下来，我们只关注一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = serverBootstrap.bind(port).sync();</span><br></pre></td></tr></table></figure>

<p>ServerBootstrap 的 <code>bind(port)</code> 方法的作用是创建一个 Channel 对象，并绑定上一个端口，它返回的是 ChannelFuture（更准确地讲，是 DefaultChannelPromise），也就是说在执行 <code>bind(port)</code> 方法之后，会获取一个 Future 对象，bind 的结果将异步设置进 Future 对象中。</p>
<p><code>sync()</code> 方法其实只是在等待，一直等到异步结果返回为止，也就是说，执行完这行代码，channel 已经绑定上端口号了。因此 <code>sync()</code> 并不是重点，我们重点要看的是 <code>bind(port)</code> 方法。下面的所有内容，都是在学习 <code>bind(port)</code> 方法究竟做了什么，很长。</p>
<br>

<p>把结果放在最前面，后续代码太多，只写注释好了。</p>
<p><code>bind(port)</code> 方法主要做了这些事情：</p>
<ol>
<li>创建 Channel 对象</li>
<li>初始化 channel（尤其是初始化 pipeline）</li>
<li>注册 channel<ol>
<li>创建 JDK 底层的 Channel 对象并注册 selectionKey</li>
<li>pipeline 上 handler 执行回调事件</li>
<li>pipeline 上 handler 执行注册事件（registered）</li>
<li>pipeline 上 handler 执行启动事件（active）</li>
</ol>
</li>
<li>channel 绑定端口号</li>
</ol>
<p>开始看代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将端口号 port 转换成 InetSocketAddress（java.net 的类）</span></span><br><span class="line">    <span class="comment">// 就不往里挖了，最后会转换成 [0.0.0.0/0.0.0.0:port]</span></span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验 group 和 channelFactory 是否不为空，如果为空就抛异常</span></span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="string">"localAddress"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # doBind</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是所有逻辑的核心中转站</span></span><br><span class="line"><span class="comment"> * 1.init</span></span><br><span class="line"><span class="comment"> * 2.register</span></span><br><span class="line"><span class="comment"> * 3.bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 channel，初始化，注册，返回注册结果</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel 注册完成，直接调用 doBind0(...) 方法</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// channel 没注册完成，加一个 listener，等它完成自己去调用 doBind(...) 方法</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来有一个非常庞大的方法：<code>initAndRegister()</code>。</p>
<p>这个方法拆成 <code>init</code> 和 <code>register</code> 两部分来看，先看 <code>init</code> 的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # initAndRegister</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.创建 Channel 实例</span></span><br><span class="line"><span class="comment"> * 2.初始化 channel（设置 config、attr、pipeline、pipeline#handler）</span></span><br><span class="line"><span class="comment"> * 3.注册 channel（很复杂）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 没关注的问题：</span></span><br><span class="line"><span class="comment"> * Channel 的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 channel 实例</span></span><br><span class="line">        <span class="comment">// 内部是根据，之前通过反射获取的构造函数，创建 Channel 对象的，详见 ServerBootstrap#channel(...)</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类实现</span></span><br><span class="line">        <span class="comment">// 1. 设置了 channel 的 config、attr</span></span><br><span class="line">        <span class="comment">// 2. 把 ServerBootstrap 的 handler 加入 pipeline 中</span></span><br><span class="line">        init(channel);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常暂且不管了</span></span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 bossGroup 线程池，注册 channel</span></span><br><span class="line">    <span class="comment">// 回忆一下，这个线程池的作用是连接客户端，然后分配给 workerGroup 执行</span></span><br><span class="line">    <span class="comment">// 这一步执行完，channel 就完全可用了</span></span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ChannelFuture 的 cause 变量是异常信息，这里是在处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的是 channel 注册的结果（DefaultChannelPromise）</span></span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # init</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.设置 channel 的 config 和 attr</span></span><br><span class="line"><span class="comment"> * 2.往 pipeline 中加入 handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 AbstractBootstrap 父类的参数</span></span><br><span class="line">    <span class="comment">// 把 option 设置到 channel 的 config 里、把 attr 设置到 channel 的 attr 里</span></span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取刚刚创建的 Channel 对象的 pipeline</span></span><br><span class="line">    <span class="comment">// 现在它只有 head 和 tail 两个 handler 节点，下面将在中间添加一个新节点</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取了一些 ServerBootstrap 子类的成员变量</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在刚刚创建的 Channel 对象的 pipeline 中增加一个 handler</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个方法之后会调到，传进来的 channel 就是刚才的 channel（此时它已经 JDK 底层注册 selector，并且有 eventLoop 了）</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 拿到 channel 的 pipeline</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把最初 ServerBootstrap 中设置的 handler 参数，加到 pipeline 中</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这是 channel 未来将有的 eventLoop，channel 执行的所有异步任务都交给它做</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 往 pipeline 中加入了一个 ServerBootstrapAcceptor，这个类继承自 ChannelInboundHandlerAdapter</span></span><br><span class="line">                    <span class="comment">// 这个 handler 的作用是接收客户端的请求</span></span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* —————————————————————————— bind -pipeline#addLast —————————————————————————— */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # addLast</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是 executor（线程池）</span></span><br><span class="line">    <span class="comment">// 如果是 null，之后会默认使用 channel 绑定的 eventLoop</span></span><br><span class="line">    <span class="comment">// 如果不是 null，可以指定一个 EventExecutorGroup（避免在 ChannelHandler 中使用阻塞操作）</span></span><br><span class="line">    <span class="keyword">return</span> addLast(<span class="keyword">null</span>, handlers);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # addLast</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup executor, ChannelHandler... handlers)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(handlers, <span class="string">"handlers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对多个 handler 逐个执行 addLast(...) 方法</span></span><br><span class="line">    <span class="comment">// 目前只有一个 handler，就是 ServerBootstrap 的 handler（此处是 LoggingHandler 对象）</span></span><br><span class="line">    <span class="keyword">for</span> (ChannelHandler h: handlers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addLast(executor, <span class="keyword">null</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # addLast</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.将 handler 加到 pipeline 链表中除了 tail 节点外的最后一个</span></span><br><span class="line"><span class="comment"> * 2.执行 handler 加入链表成功的回调事件（不一定直接能执行）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查 handler 是否重复添加、是否可以重复添加</span></span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 handler 包装成 handlerContext（带 pipeline 上下文的 handler）</span></span><br><span class="line">        <span class="comment">// 后面不使用 handler，转而使用包装后的 handlerContext，以便 handler 能拿到 pipeline</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将包装过的 handler 加入 pipeline 链表当中</span></span><br><span class="line">        <span class="comment">// 实现就是 [xxx]&lt;-&gt;[tail] 变成 [xxx]&lt;-&gt;[handlerContext]&lt;-&gt;[tail]</span></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// —————————————————————————————————————————————————————</span></span><br><span class="line">        <span class="comment">// handler 加入 pipeline 之后，会执行 handler 的回调事件，比如 ChannelInitializer 就会把自己删除</span></span><br><span class="line">        <span class="comment">// 下面是在执行 handler 加入后的回调事件（回调事件是提交给线程池，异步执行的）</span></span><br><span class="line">        <span class="comment">// 下面有三条路，不论那条最后都会执行 callHandlerAdded0(...) 方法，也就是执行回调事件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// registered 实际是指 channel 有没有被注册，现在还是 false，以后会看到它被赋值为 true</span></span><br><span class="line">        <span class="comment">// 当 channel 还没有被注册的时候，channel 绑定的 eventLoop 可能还没有被创建，即可能还没有线程池</span></span><br><span class="line">        <span class="comment">// 因此不能执行 handler 的回调事件，那么就先把这个 handler 记录下来，等以后注册完了再执行回调</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">            <span class="comment">// 设置 handler 的状态为 ADD_PENDING，等待执行回调</span></span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            <span class="comment">// 记录下来这个 handler，等以后 channel 注册完了再执行它的回调事件</span></span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行到这里代表 channel 被注册过，那么可以让线程池执行 handler 的回调事件了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前线程不是 eventLoop 线程，那么提交给 eventLoop 线程完成</span></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) &#123;</span><br><span class="line">            <span class="comment">// 这个方法就执行了两行代码，handler 设置状态为 ADD_PENDING，然后异步提交 callHandlerAdded0(...) 方法</span></span><br><span class="line">            <span class="comment">// newCtx.setAddPending();</span></span><br><span class="line">            <span class="comment">// executor.execute(() -&gt; &#123; callHandlerAdded0(newCtx); &#125;);</span></span><br><span class="line">            callHandlerAddedInEventLoop(newCtx, executor);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程是 eventLoop 线程，直接执行</span></span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # callHandlerCallbackLater</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 此时 channel 还没有注册</span></span><br><span class="line"><span class="comment"> * 保存 handlerContext，包装成 PendingHandlerCallback，存储在 pipeline 的 pendingHandlerCallbackHead 变量中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerCallbackLater</span><span class="params">(AbstractChannelHandlerContext ctx, <span class="keyword">boolean</span> added)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断言：channel 没有注册过（如果注册过，不需要来保存 handler，等待执行回调事件）</span></span><br><span class="line">    <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 handlerContext 包装成 PendingHandlerAddedTask</span></span><br><span class="line">    <span class="comment">// 这个类实现了 Runnable 接口，执行它的 execute() 方法，就可以执行 handler 的回调事件</span></span><br><span class="line">    <span class="comment">// 在后续代码，channel 注册之后，将执行 task.execute()，它内部会执行 callHandlerAdded0(...) 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// added 为 true 表示 HandlerAdd 任务，false 表示 HandlerRemove 任务</span></span><br><span class="line">    DefaultChannelPipeline.PendingHandlerCallback task = added ? <span class="keyword">new</span> DefaultChannelPipeline.PendingHandlerAddedTask(ctx) : <span class="keyword">new</span> DefaultChannelPipeline.PendingHandlerRemovedTask(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipeline 有一个成员变量：pendingHandlerCallbackHead</span></span><br><span class="line">    <span class="comment">// 这个变量存储的是【需要存储下来，等待执行回调事件的 handler】的链表头结点</span></span><br><span class="line">    <span class="comment">// 等后续 channel 注册之后，获取 pipeline 的这个变量，逐个触发全部 handler 的回调事件</span></span><br><span class="line">    DefaultChannelPipeline.PendingHandlerCallback pending = pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">if</span> (pending == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pendingHandlerCallbackHead = task;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (pending.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pending = pending.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pending.next = task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PendingHandlerAddedTask</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 后续代码将执行该类的 execute() 方法，内部在执行 callHandlerAdded0(...) 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingHandlerAddedTask</span> <span class="keyword">extends</span> <span class="title">DefaultChannelPipeline</span>.<span class="title">PendingHandlerCallback</span> </span>&#123;</span><br><span class="line">    PendingHandlerAddedTask(AbstractChannelHandlerContext ctx) &#123;</span><br><span class="line">        <span class="comment">// 父类的构造方法：this.ctx = ctx;</span></span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        callHandlerAdded0(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventExecutor executor = ctx.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            callHandlerAdded0(ctx);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executor.execute(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Can't invoke handlerAdded() as the EventExecutor &#123;&#125; rejected it, removing handler &#123;&#125;."</span>, executor, ctx.name(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                atomicRemoveFromHandlerList(ctx);</span><br><span class="line">                ctx.setRemoved();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面看完了 <code>initAndRegister()</code> 方法的 <code>init</code> 部分，接下来看 <code>register</code> 部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MultithreadEventLoopGroup # register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 获取一个 eventLoop，执行它的 register(...) 方法</span></span><br><span class="line"><span class="comment"> * 辗转后，实际上是在 channel.unsafe() 中执行的 register(...) 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个 EventLoop 线程</span></span><br><span class="line">    <span class="comment">// 具体不看了，最后返回 executors[idx.getAndIncrement() &amp; executors.length - 1]</span></span><br><span class="line">    <span class="keyword">return</span> next()</span><br><span class="line">            <span class="comment">// 注册，往下看</span></span><br><span class="line">            .register(channel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SingleThreadEventLoop # register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册，往下看</span></span><br><span class="line">    <span class="keyword">return</span> register(</span><br><span class="line">            <span class="comment">// 这个构造方法不看了，就俩赋值</span></span><br><span class="line">            <span class="comment">// this.channel = channel</span></span><br><span class="line">            <span class="comment">// this.executor = executor（就是 EventLoop 线程）</span></span><br><span class="line">            <span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SingleThreadEventLoop # register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// channel 注册，往下看</span></span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册的结果会放入 promise 中（异步），返回这个结果</span></span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannel.AbstractUnsafe # register</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.channel 设置 eventLoop 线程</span></span><br><span class="line"><span class="comment"> * 2.eventLoop 执行 register0() 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(eventLoop, <span class="string">"eventLoop"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果以前注册过，promise 设置失败</span></span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 eventLoop 线程类型是否是兼容的，如果不是 NioEventLoop 对象，promise 设置失败</span></span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从此之后，channel 就是有 eventLoop 线程的了</span></span><br><span class="line">    <span class="comment">// channel 的所有异步操作，都将使用这个 eventLoop 完成</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发起 register 的线程就是 eventLoop 里的线程，直接执行 register0()（这里是不会的，以后 unregister 才会）</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// eventLoop 去执行 register0() 方法</span></span><br><span class="line">            eventLoop.execute(() -&gt; &#123; register0(promise); &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 异常暂且忽略</span></span><br><span class="line">            logger.warn(<span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>, AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannel.AbstractUnsafe # register0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// JDK 底层注册，就执行了一行代码</span></span><br><span class="line">        <span class="comment">// selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</span></span><br><span class="line">        <span class="comment">// 三个参数分别代表：【JDK 底层的 selector】【对所有事件都不感兴趣】【本 channel，这样以后就可以通过 selector 获取 channel】</span></span><br><span class="line">        doRegister();</span><br><span class="line"></span><br><span class="line">        neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 ChannelInitializer 内部添加的 handlers 添加到 pipeline 中</span></span><br><span class="line">        <span class="comment">// 我们接下来相当长的部分，都是在看这个方法</span></span><br><span class="line">        <span class="comment">// 这个方法执行完，pipeline 有关服务端的部分就已经全部完成了</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 promise 注册完成</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 此时 channel 已经被注册，通知所有关心这件事的 handler，让它们处理这件事</span></span><br><span class="line">        <span class="comment">// fire 这个词很形象，可以翻译成”传火“，让 pipeline 从 head 节点开始，一个个地去处理</span></span><br><span class="line">        <span class="comment">// 每一个订阅该事件的 handler 都会执行 channelRegistered(...) 方法，执行完之后找到下一个订阅的节点，让它再去执行</span></span><br><span class="line">        <span class="comment">// 这是一个递归的过程，总之就是让所有订阅 channel 注册事件的 handler，都去执行 channelRegistered(...) 方法</span></span><br><span class="line">        <span class="comment">// 比如 LoggingHandler 就会在 channelRegistered(...) 方法中执行【logger.log(internalLevel, format(ctx, "REGISTERED"));】</span></span><br><span class="line">        <span class="comment">// 这块的代码也比较复杂，不往里看了</span></span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 JDK 的 channel 已经打开</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="comment">// 如果首次注册（是的）</span></span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// pipeline file 所有的 handler 响应 ChannelActive 事件（就是按顺序执行所有 handler 重写的 channelActive(...) 方法）</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                <span class="comment">// channel 之前就被注册过了，现在立即去监听通道内的 OP_READ 事件</span></span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # invokeHandlerAddedIfNeeded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 断言：当前线程就是 channel 绑定的线程</span></span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">        firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 在初始化 channel 设置 pipeline 时，我们将 ServerBootstrap 的 handler 变量保存起来</span></span><br><span class="line">        <span class="comment">// 因为当时 channel 还没有注册，还没有绑定 eventLoop，无法执行 handler 的回调事件</span></span><br><span class="line">        <span class="comment">// 现在可以执行 handler 的回调事件了</span></span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # callHandlerAddedForAllHandlers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAddedForAllHandlers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> DefaultChannelPipeline.PendingHandlerCallback pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">assert</span> !registered;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这是 pipeline 的变量，是指 channel 是否已经注册，可以使用 channel 的 eventLoop 了</span></span><br><span class="line">        <span class="comment">// 这个变量我们已经在 pipeline 的 addLast() 方法中见过了，当时是 false，从现在开始变为 true</span></span><br><span class="line">        registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出当时 addLast(handler) 的 handler，当时没有执行 handler 的回调事件，现在准备来执行</span></span><br><span class="line">        pendingHandlerCallbackHead = <span class="keyword">this</span>.pendingHandlerCallbackHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.pendingHandlerCallbackHead = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pipeline 之前存储了一些没有执行回调事件的 handler，他们排成了一个链表，pipeline 存储了链表头</span></span><br><span class="line">    <span class="comment">// 现在逐个执行这些 handler 的回调事件</span></span><br><span class="line">    DefaultChannelPipeline.PendingHandlerCallback task = pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行 handler 的回调事件</span></span><br><span class="line">        <span class="comment">// 回去看 pipeline 的 addLast(...) 的代码，会发现这行代码实际上在执行 callHandlerAdded0(...)</span></span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们到这里回忆一下</span></span><br><span class="line"><span class="comment">// 在之前初始化 channel 时，设置了 pipeline，将 ServerBootstrap 的 handler 包装起来加入到 pipeline 链表中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</span></span><br><span class="line"><span class="comment">//     @Override</span></span><br><span class="line"><span class="comment">//     public void initChannel(final Channel ch) &#123;</span></span><br><span class="line"><span class="comment">//        ...</span></span><br><span class="line"><span class="comment">//        pipeline.addLast(handler);</span></span><br><span class="line"><span class="comment">//        ...</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 也就是说，pipeline 加入了一个 handler（一个 ChannelInitializer 实例），它里面包着 ServerBootstrap 的 handler</span></span><br><span class="line"><span class="comment">// pipeline 加入了这个 handler 之后，要执行回调事件 callHandlerAdded0(...)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 但是回调事件只能在 channel 绑定的 eventLoop 中执行，此时还没有绑定 eventLoop</span></span><br><span class="line"><span class="comment">// 因此只好先存储一下 handler，等待之后 channel 注册完成，绑定了 eventLoop 后再执行 handler 的回调事件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 当时将 handler 又包装了一层，包装成了 PendingHandlerCallback 实例</span></span><br><span class="line"><span class="comment">// 这是一个实现了 Runnable 接口的类，handler 的回调事件，被放进了 Runnable 的 execute() 方法中</span></span><br><span class="line"><span class="comment">// 这里的 task 实际上就是当初包装后的 PendingHandlerCallback</span></span><br><span class="line"><span class="comment">// 这里执行 task.execute() 方法，实际上就是在执行 handler 的回调事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # callHandlerAdded0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * （省略了一个方法）task.execute() -&gt; callHandlerAdded0(ctx)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里的 ctx 就是 handlerContext，之前被包装过的 handler</span></span><br><span class="line">        <span class="comment">// 执行它的回调事件</span></span><br><span class="line">        ctx.callHandlerAdded();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 异常不去看了</span></span><br><span class="line">        <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            atomicRemoveFromHandlerList(ctx);</span><br><span class="line">            ctx.callHandlerRemoved();</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to remove a handler: "</span> + ctx.name(), t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">            fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(ctx.handler().getClass().getName() + <span class="string">".handlerAdded() has thrown an exception; removed."</span>, t));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireExceptionCaught(<span class="keyword">new</span> ChannelPipelineException(ctx.handler().getClass().getName() + <span class="string">".handlerAdded() has thrown an exception; also failed to remove."</span>, t));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannelHandlerContext # callHandlerAdded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">callHandlerAdded</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 先设置 handlerContext 的状态是 ADD_COMPLETE</span></span><br><span class="line">    <span class="keyword">if</span> (setAddComplete()) &#123;</span><br><span class="line">        <span class="comment">// 执行内部包着的 handler 的回调事件</span></span><br><span class="line">        handler().handlerAdded(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelInitializer # handlerAdded</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 确保 channel 已经被注册</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">        <span class="comment">// 执行 initChannel(...) 方法，往里看，柳暗花明</span></span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">            <span class="comment">// 这里并不是在 pipeline 中删除自己，只是标记一下状态</span></span><br><span class="line">            removeState(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelInitializer # initChannel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 防止加载多次，先记录下来这个（避免并发）</span></span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这个方法我们之前使用过</span></span><br><span class="line">            <span class="comment">// ChannelInitializer 是一个抽象类，每次实例化必须要实现它的 initChannel(...) 方法</span></span><br><span class="line">            <span class="comment">// 我们之前创建 ChannelInitializer 对象的时候，就重写过这个方法了</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            <span class="comment">// 异常处理不看了</span></span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在 pipeline 中删掉 ChannelInitializer 对象，它的作用已经结束了</span></span><br><span class="line">            ChannelPipeline pipeline = ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 至此，我们的 pipeline 有关服务端的部分已经完成了</span></span><br><span class="line">            <span class="comment">// 它的内部是：head &lt;-&gt; ServerBootstrap 的 handler &lt;-&gt; 用于接收客户端请求的 handler &lt;-&gt; tail</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServerBootstrap # init</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 回想一下这个方法</span></span><br><span class="line"><span class="comment"> * bind() -&gt; doBind() -&gt; initAndRegister() -&gt; init()</span></span><br><span class="line"><span class="comment"> * 此时 channel 刚刚创建，正在初始化它，这个方法就是在初始化，设置 channel 的 pipeline</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 channel 的 options 和 attrs 参数</span></span><br><span class="line">    setChannelOptions(channel, newOptionsArray(), logger);</span><br><span class="line">    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出一堆东西来，准备初始化 pipeline</span></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Map.Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 pipeline 中加入一个 ChannelInitializer，这里面包着 ServerBootstrap 的 handler</span></span><br><span class="line">    <span class="comment">// 创建 ChannelInitializer 对象，必须要重写它的 initChannel 方法</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们终于看到这个方法被执行了</span></span><br><span class="line">        <span class="comment">// 回忆一下：</span></span><br><span class="line">        <span class="comment">// 1. 我们在初始化 channel 时，设置 pipeline，往里面加入了一个 ChannelInitializer 对象，里面装着 handler</span></span><br><span class="line">        <span class="comment">//    执行 pipeline.addLast(...) 方法时，将这个被包装的 handler 加入到 pipeline 的尾部</span></span><br><span class="line">        <span class="comment">// 2. 每一个 handler 加入 pipeline 之后，都要执行回调事件（对于 ChannelInitializer，是把它内部 handler 们加入到 pipeline 中，再删除掉自己）</span></span><br><span class="line">        <span class="comment">//    但是回调事件是需要异步完成的，需要 channel 绑定的 eventLoop 线程来执行，但是此时 channel 还没有被注册</span></span><br><span class="line">        <span class="comment">//    因此先把这个 handler 存储下来，先包装成 handlerContext，再包装成 pendingHandlerCallback，以链表的形式存储在 pipeline 中</span></span><br><span class="line">        <span class="comment">// 3. 当 channel 被注册之后，channel 有了 eventLoop，可以执行 handler 的回调事件了</span></span><br><span class="line">        <span class="comment">//    此时取出 pipeline 的 pendingHandlerCallback，取出里面的 handlerContext</span></span><br><span class="line">        <span class="comment">//    给 eventLoop 提交一个任务，让它去执行 handler 的回调事件，ChannelInitializer 的回调事件是执行 initChannel(...)，最终一步步走到了这里</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 pipeline</span></span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出 ServerBootstrap 的 handler</span></span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 handler 加入到 pipeline 中，这个 handler 的回调事件可以直接执行</span></span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里还往 pipeline 中加入了一个 handler</span></span><br><span class="line">            <span class="comment">// 这个 handler 的作用是接收客户端请求</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有大量的代码在处理 handler，下面画一张图，来描述一下 handler 是如何从 ServerBootstrap 加入到 pipeline 中的。</p>
<p><img src="/assets/netty_pipeline.jpg" alt="netty_pipeline"></p>
<p>还有最后一点代码，把 <code>bind0()</code> 方法看完。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # doBind</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 很早之前的方法了，最开始的时候</span></span><br><span class="line"><span class="comment"> * 此时 channel 已经创建并注册好了，要执行绑定端口的操作了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时 channel 已经完成初始化的代码（异步执行，可能还没完成）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经完成注册，在当前线程执行 doBind0(...) 方法</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有完成注册，给注册 future 增加一个完成后的回调，让它完成后去调用 doBind0(...) 方法</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此时没有注册完成，channel 还不一定有绑定的 eventLoop，不能让 channel 生成 promise</span></span><br><span class="line">        <span class="comment">// 因此创建一个 PendingRegistrationPromise 对象</span></span><br><span class="line">        <span class="keyword">final</span> AbstractBootstrap.PendingRegistrationPromise promise = <span class="keyword">new</span> AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 怎么加监听，以及完成后处理监听的逻辑就暂且忽略了</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 完成后的回调方法 operationComplete</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">// 如果 channel 注册失败，就记录失败</span></span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 channel 注册成功，执行 doBind0(...)</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录注册成功</span></span><br><span class="line">                    promise.registered();</span><br><span class="line">                    <span class="comment">// 执行 doBind0(...) 方法</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractBootstrap # doBind0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// 在 channel 注册成功的前提下，绑定端口</span></span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannel # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannelHandlerContext # bind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(localAddress, <span class="string">"localAddress"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查一下 promise 的类型等要素，如果有问题直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isNotValidPromise(promise, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下一个对订阅【绑定事件】的 outbound handler</span></span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext next = findContextOutbound(MASK_BIND);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取 handler 归属 channel 的 eventLoop，执行 invokeBind(...) 方法</span></span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="comment">// 直接加载 invokeBind(...) 方法</span></span><br><span class="line">        next.invokeBind(localAddress, promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// eventLoop 懒加载 invokeBind(...) 方法</span></span><br><span class="line">        safeExecute(executor, () -&gt; &#123; next.invokeBind(localAddress, promise); &#125;, promise, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AbstractChannelHandlerContext # invokeBind</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeBind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测该 handler 是否加入到 pipeline 中</span></span><br><span class="line">    <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 该 handler 执行绑定事件</span></span><br><span class="line">            <span class="comment">// 每个 handler 的执行内容都不相同，比如 LoggingHandler 就是打印 ”BIND“</span></span><br><span class="line">            <span class="comment">// 但是每个 handler 执行完之后，都会再次调用 AbstractChannelHandlerContext#bind() 方法，继续执行下去</span></span><br><span class="line">            <span class="comment">// 执行到最后，会执行到 head 节点，执行它的 bind(...) 方法，往下看</span></span><br><span class="line">            ((ChannelOutboundHandler) handler()).bind(<span class="keyword">this</span>, localAddress, promise);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            notifyOutboundHandlerException(t, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果该 handler 还没有初始化完成，跳过它，执行下一个 handler 的绑定</span></span><br><span class="line">        bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DefaultChannelPipeline$HeadContext # bind</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * head handler 的 bind(...) 方法</span></span><br><span class="line"><span class="comment"> * 真正的绑定端口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 unsafe 类来执行 bind(...) 方法</span></span><br><span class="line">    <span class="comment">// 底层是通过 JDK 的 channel 来实现绑定端口的，不看了</span></span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就写到这里吧。</p>

  </div>
</article>



    </div>
    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 pz
  </div>
  <div class="footer-right">
    <img src="/images/govPolice.png">
    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502006101">粤公网安备 44030502006101号</a>
    <a>&nbsp;</a>
    <a href="http://beian.miit.gov.cn">粤ICP备2020090003号</a>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



