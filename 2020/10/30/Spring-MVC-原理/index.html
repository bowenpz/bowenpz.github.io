<!DOCTYPE html>
<html lang=Ch>
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="十月的尾巴赶出来一篇吧，这周学习 Spring MVC 的原理。 十月份是放松的一个月，国庆出游，节后迎接朋友，还没怎么学习就过去了，回到生活的常态了，认真学习。  我一直不太清楚 Spring 官方文档的结构和入口，比如，似乎根本就不存在 Spring MVC 这个模块，它被包含在 Spring Web Flow 或是 Web on Servlet Stack 的模块中，而且这两个模块我也搞">
<meta name="keywords" content="Weekly Post">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring MVC 原理">
<meta property="og:url" content="http://hellopz.netlify.com/2020/10/30/Spring-MVC-原理/index.html">
<meta property="og:site_name" content="这里是pz阁下">
<meta property="og:description" content="十月的尾巴赶出来一篇吧，这周学习 Spring MVC 的原理。 十月份是放松的一个月，国庆出游，节后迎接朋友，还没怎么学习就过去了，回到生活的常态了，认真学习。  我一直不太清楚 Spring 官方文档的结构和入口，比如，似乎根本就不存在 Spring MVC 这个模块，它被包含在 Spring Web Flow 或是 Web on Servlet Stack 的模块中，而且这两个模块我也搞">
<meta property="og:locale" content="Chinese">
<meta property="og:image" content="http://hellopz.netlify.com/assets/SpringMVC%E4%B8%91%E5%9B%BE.JPG">
<meta property="og:updated_time" content="2020-10-30T06:31:34.247Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring MVC 原理">
<meta name="twitter:description" content="十月的尾巴赶出来一篇吧，这周学习 Spring MVC 的原理。 十月份是放松的一个月，国庆出游，节后迎接朋友，还没怎么学习就过去了，回到生活的常态了，认真学习。  我一直不太清楚 Spring 官方文档的结构和入口，比如，似乎根本就不存在 Spring MVC 这个模块，它被包含在 Spring Web Flow 或是 Web on Servlet Stack 的模块中，而且这两个模块我也搞">
<meta name="twitter:image" content="http://hellopz.netlify.com/assets/SpringMVC%E4%B8%91%E5%9B%BE.JPG">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Spring MVC 原理</title>
    <!-- styles -->
    <link rel="stylesheet" href="/css/style.css">
    <!-- rss -->
    
    
</head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/2019/07/21/helloworld/">About</a></li>
         
          <li><a href="/tags/Weekly-Post/">Weekly Post</a></li>
         
          <li><a href="/tags/Random-Post/">Random Post</a></li>
         
          <li><a href="/tags/tips/">Tips</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2020/09/30/Netty-的-Bootstrap/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://hellopz.netlify.com/2020/10/30/Spring-MVC-原理/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://hellopz.netlify.com/2020/10/30/Spring-MVC-原理/&text=Spring MVC 原理"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://hellopz.netlify.com/2020/10/30/Spring-MVC-原理/&is_video=false&description=Spring MVC 原理"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-进入-DispatcherServlet-之前"><span class="toc-number">1.</span> <span class="toc-text">-1. 进入 DispatcherServlet 之前</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0-DispatcherServlet-类"><span class="toc-number">2.</span> <span class="toc-text">0. DispatcherServlet 类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-找出能处理该请求的-handler"><span class="toc-number">3.</span> <span class="toc-text">1. 找出能处理该请求的 handler</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-找出负责执行-handler-的-handlerAdapter"><span class="toc-number">4.</span> <span class="toc-text">2. 找出负责执行 handler 的 handlerAdapter</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-处理缓存"><span class="toc-number">5.</span> <span class="toc-text">3. 处理缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-执行-handler"><span class="toc-number">6.</span> <span class="toc-text">4. 执行 handler</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-渲染视图结果"><span class="toc-number">7.</span> <span class="toc-text">5. 渲染视图结果</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HandlerExecutionChain"><span class="toc-number">8.</span> <span class="toc-text">HandlerExecutionChain</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HandlerMapping"><span class="toc-number">9.</span> <span class="toc-text">HandlerMapping</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HandlerAdapter"><span class="toc-number">10.</span> <span class="toc-text">HandlerAdapter</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Spring MVC 原理
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">这里是pz阁下</span>
      </span>
      
    <div class="postdate">
        <time datetime="2020-10-30T06:31:19.000Z" itemprop="datePublished">2020-10-30</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Weekly-Post/">Weekly Post</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <br>

<p>十月的尾巴赶出来一篇吧，这周学习 Spring MVC 的原理。</p>
<p>十月份是放松的一个月，国庆出游，节后迎接朋友，还没怎么学习就过去了，回到生活的常态了，认真学习。</p>
<hr>
<p>我一直不太清楚 Spring 官方文档的结构和入口，比如，似乎根本就不存在 Spring MVC 这个模块，它被包含在 Spring Web Flow 或是 Web on Servlet Stack 的模块中，而且这两个模块我也搞不懂是什么关系。</p>
<p>我大致梳理出来这么一个逻辑：Spring MVC 并不在 Spring 的顶层结构中，Spring Web 才是顶层的设计，Spring MVC 只是 Web 中的一种解决方案，如果不用它，还可以使用 Struts 等其他的网络应用框架（但是现在大家都在使用 Spring MVC）。这种逻辑跟 Spring 的设计调性有关，它们希望做得更开放包容一些。</p>
<p>我在去年刚入行时学习 Spring 全家桶，就反复看到这张奇丑无比的图（为什么行业的审美这么低……）：</p>
<p><img src="/assets/SpringMVC%E4%B8%91%E5%9B%BE.JPG" alt="SpringMVC丑图"></p>
<p>当时连 Java 的语法都写得不利索，按照这个学习更是像趟沼泽似的一脚深一脚浅。如今回来看就豁然开朗了很多。</p>
<p>Spring MVC 的核心中转站是 DispatcherServlet，网络请求的接收、执行、渲染视图、返回等，它跟 Spring 接触的全过程，都发生在这个类当中。这篇文章说是学习 Spring MVC 的原理，其实也只是学习这个 DispatcherServlet 类。</p>
<p>在学习这部分时，发现了写得非常好的博客，记录一下：《<a href="https://blog.csdn.net/andy_zhang2007/category_9285198.html" target="_blank" rel="noopener">安迪源文-专栏-Spring MVC 分析</a>》。</p>
<hr>
<p>dispatcher 的意思是调度员，因此 DispatcherServlet 类是一个用于调度、中转的类，这是 Spring MVC 的前端控制器。它调用了很多个方法，把一个请求从接收到返回的所有方法逐个执行完毕，这中间一共有 5 个步骤，下面一个个步骤过。</p>
<p>以下分析基于 spring-webmvc-5.2.9.RELEASE 版本。</p>
<h1 id="1-进入-DispatcherServlet-之前"><a href="#1-进入-DispatcherServlet-之前" class="headerlink" title="-1. 进入 DispatcherServlet 之前"></a>-1. 进入 DispatcherServlet 之前</h1><p>Spring MVC 的底层使用的是 Tomcat。一个 HTTP 请求，将首先到达 Tomcat，再又 Tomcat 转发给 Spring MVC 去处理。</p>
<p>一个 HTTP 请求根据 Java EE 的网络协议，将首先进入到 Servlet 接口中，就是 Tomcat，Tomcat 将这个请求处理后，封装出两个对象：<code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>，最终交付给 Spring MVC，进入到 DispatcherServlet 类中。</p>
<p>进入 DispatcherServlet 类之前的动作，需要理解网络通信和 Tomcat 的设计，这部分暂且忽略，以后再学习。</p>
<p>最终我们进入到 DispatcherServlet 类中，调用 <code>doDispatch(...)</code> 方法，这个方法有两个参数，分别是 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>。</p>
<h1 id="0-DispatcherServlet-类"><a href="#0-DispatcherServlet-类" class="headerlink" title="0. DispatcherServlet 类"></a>0. DispatcherServlet 类</h1><p>任何 Spring MVC 的教程帖，包括官方文档，都会重点说 DispatcherServlet 类。它被称为 Spring MVC 的前端控制器，这是因为它是所有 HTTP 请求的总中转站。这个类在 JavaDoc 中是这么描述的：</p>
<blockquote>
<p>Central dispatcher for HTTP request handlers/controllers……</p>
</blockquote>
<p>我们这篇只关注 DispatcherServlet 类的一个方法：<code>doDispatch(...)</code>。</p>
<p>Spring 框架接到 HTTP 请求后，将会执行 DispatcherServlet 类的 <code>doDispatch(...)</code> 方法，用来做分发（dispatch）。后端 Java 应用有那么多的接口，这个 HTTP 请求到底是访问哪一个接口，得找出来，并且得执行这个接口，分发就是指找到并执行这个接口（把这个请求分发出去）。</p>
<p>Spring MVC 把处理请求的对象称为 <code>handler</code>，与之相关的概念还有 <code>HandlerExecutionChain</code> 和 <code>HandlerAdapter</code>，它们都跟 <code>handler</code> 有关，下文讲到了再说。</p>
<p><code>doDispatch(...)</code> 方法按顺序做了这些事情：</p>
<ol>
<li>找出 handler</li>
<li>找出负责执行 handler 的 handlerAdapter</li>
<li>处理缓存</li>
<li>执行 handler</li>
<li>渲染视图结果</li>
</ol>
<p>首先将这部分代码贴在下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理异步请求的 manager</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// handler 处理的结果</span></span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否是上传文件的请求，如果是，转换 request</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            <span class="comment">// boolean 变量：是否是上传文件的请求（request 有没有发生过转换）</span></span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ① 找出能处理该请求的 handler —————————— */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="comment">// 如果没找到 handler，response 返回 404 异常（在 noHandlerFound(...) 方法中）</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ② 获取 HandlerAdapter，用以执行 handler —————————— */</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ③ 处理缓存（允许的话可以直接返回） —————————— */</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="comment">// 默认情况下 lastModified 是 -1</span></span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="comment">// 由于 lastModified 是 -1，checkNotModified(...) 方法什么都没做，最后返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* —————————— ④ handler 开始处理请求 —————————— */</span></span><br><span class="line">            <span class="comment">// 前置拦截</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行 handler，获取结果 modelAndView</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是异步请求，直接返回，response 将一直保持打开状态</span></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 modelAndView 不为空，但 view 为空时，根据 request 设置默认的 view</span></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后置拦截</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* —————————— ⑤ 解析、渲染 mv（或者是异常） —————————— */</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-找出能处理该请求的-handler"><a href="#1-找出能处理该请求的-handler" class="headerlink" title="1. 找出能处理该请求的 handler"></a>1. 找出能处理该请求的 handler</h1><p>（省略了一些声明变量、检查上传文件的代码）</p>
<p><code>doDispatch(...)</code> 方法做的第一件事，是找到请求要分发到哪个接口上。</p>
<p>Spring MVC 将处理用户请求的接口叫做 handler，它可能是程序员开发的 Controller 方法，也有可能是框架自动配置出的某个方法。</p>
<p>我们首先需要找到这个方法，也就是找到 handler，这一步是执行 <code>getHandler(...)</code> 方法。如果没有找到这个方法，那么就可以直接返回 404 了，返回 404 的过程是在执行 <code>noHandlerFound(...)</code> 方法。这里很简单，直接看代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* —————————— ① 找出能处理该请求的 handler —————————— */</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="comment">// 如果没找到 handler，response 返回 404 异常（在 noHandlerFound(...) 方法中）</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    noHandlerFound(processedRequest, response);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这第一步可以拆成两个部分，怎么找到 handler 的，以及如果找不到是怎么返回 404 的。</p>
<ol>
<li><p><code>getHandler(...)</code> 方法</p>
<p>首先寻找 handler，从 handlerMappings 中进行遍历寻找能够匹配的 handler，如果找不到就返回 null。</p>
<p>handlerMappings 是一个 <code>List&lt;HandlerMapping&gt;</code>，它在首个请求进来时进行初始化，把所有的 handler 都包装起来加入到一个 List 中，之后每当有请求进来就遍历这个 List，逐个匹配。如果匹配上了，就通过这个 handlerMapping 获取 handler。</p>
<p>需要注意的是，这里获取到的 handler 的类型，实际上是 HandlerExecutionChain，它在 handler 的基础上增加了若干个 interceptor（拦截器），可以实现类似 AOP 的效果。有关这个类的设计，我们在最后面详述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// handlerMappings：</span></span><br><span class="line">    <span class="comment">// 这是一个 List&lt;HandlerMapping&gt;，装着所有的 handler，应用启动的时候进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 handlerMappings</span></span><br><span class="line">        <span class="keyword">for</span> (HandlerMapping mapping : <span class="keyword">this</span>.handlerMappings) &#123;</span><br><span class="line">            <span class="comment">// 如果找到了合适的 handler，包装成 HandlerExecutionChain 对象</span></span><br><span class="line">            <span class="comment">// HandlerExecutionChain 除了包含 handler 外，还包含拦截器（HandlerInterceptor 列表）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// mapping.getHandler(...) 这个方法比较深，主要做了这几件事：</span></span><br><span class="line">            <span class="comment">//  1. 获取 url</span></span><br><span class="line">            <span class="comment">//  2. 通过 RequestCondition 的设计，比对接口参数（如路径、头部信息、请求参数等）</span></span><br><span class="line">            <span class="comment">//  3. 比对参数找到 handler 后，将 handler 转换成 HandlerExecutionChain 对象</span></span><br><span class="line">            HandlerExecutionChain handler = mapping.getHandler(request);</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>handlerMappings 的初始化是在 DispatcherServlet 的 <code>initHandlerMappings(...)</code> 方法内完成的，在默认情况下，会从容器（以及祖先容器）获取所有类型为 <code>HandlerMapping</code> 的 <code>bean</code> 组件，记录到 <code>handlerMappings</code> 并排序。这个过程可以参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/87694206" target="_blank" rel="noopener">Spring MVC DispatcherServlet 策略初始化 – initHandlerMappings</a>》</p>
</li>
<li><p><code>noHandlerFound(...)</code> 方法</p>
<p>（按照常理来想）如果没有对应的接口，寻找 handler 时会找不到，从而进入到 <code>noHandlerFound(...)</code> 方法，返回 404 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">noHandlerFound</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pageNotFoundLogger.isWarnEnabled()) &#123;</span><br><span class="line">        pageNotFoundLogger.warn(<span class="string">"No mapping for "</span> + request.getMethod() + <span class="string">" "</span> + getRequestUri(request));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.throwExceptionIfNoHandlerFound) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoHandlerFoundException(request.getMethod(), getRequestUri(request), <span class="keyword">new</span> ServletServerHttpRequest(request).getHeaders());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里就是 404</span></span><br><span class="line">        response.sendError(HttpServletResponse.SC_NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是神奇的是，Spring MVC 提供了一个 handler，它的路径匹配是 <code>\**</code>，也就是对所有路径都匹配，因而每次有请求进来，都可以找到 handler，不会出现 handler 为 null 的情况，也就不会进入到 <code>noHandlerFound(...)</code> 方法中。它会在更晚的地方，handler 开始处理接口的时候去处理，最终返回 404。</p>
<p>这种情况我还不是很确定，但并不关乎核心内容，因此暂且放过了。</p>
</li>
</ol>
<h1 id="2-找出负责执行-handler-的-handlerAdapter"><a href="#2-找出负责执行-handler-的-handlerAdapter" class="headerlink" title="2. 找出负责执行 handler 的 handlerAdapter"></a>2. 找出负责执行 handler 的 handlerAdapter</h1><p>获取 handler 之后并不是直接执行它的，负责执行 handler 的类是 HandlerAdapter，也就是说一个请求的真正执行，是由 HandlerAdapter 来处理的。这是单一职责原则的体现，有关这个类的具体设计见本文最后。</p>
<p>获取 handlerAdapter 只要一行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* —————————— ② 获取 HandlerAdapter，用以执行 handler —————————— */</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>

<p>跟进去看 <code>getHandlerAdapter(...)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line">            <span class="comment">// 自己写的接口，默认的 handlerAdapter 是 RequestMappingHandlerAdapter</span></span><br><span class="line">            <span class="comment">// 这个类对 @RequestMapping 的方法提供支持</span></span><br><span class="line">            <span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">                <span class="keyword">return</span> adapter;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 默认情况下是不可能的，只要不瞎改源码瞎扩展</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler + <span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也比较简单，遍历 handlerAdapters，找到合适的 handlerAdapter。</p>
<p>对于自己在 Controller 中写的接口（使用 @RequestMapping 注解的方法），默认的 handlerAdapter 是 RequestMappingHandlerAdapter 的实现类。</p>
<p>要遍历的 handlerAdapters 是 DispatcherServlet 的一个成员变量，它跟 handlerMappings 一样，都是在第一个请求进来时进行加载，加载的方法是 <code>initHandlerAdapters(...)</code>。</p>
<h1 id="3-处理缓存"><a href="#3-处理缓存" class="headerlink" title="3. 处理缓存"></a>3. 处理缓存</h1><p>第三步是处理缓存相关的事情，这一部分主要跟 HTTP 的 304 状态码相关，先贴代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* —————————— ③ 处理缓存（允许的话可以直接返回） —————————— */</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">    <span class="comment">// 默认情况下 lastModified 是 -1</span></span><br><span class="line">    <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">    <span class="comment">// 由于 lastModified 是 -1，checkNotModified(...) 方法什么都没做，最后返回 false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认的实现，这里什么都没做，也就是说默认情况下，自己写的接口是不会使用缓存机制的。</p>
<p>关于 HTTP 的 304 状态码，last-modified 的含义，HTTP 缓存的概念，可以参考这篇文章《<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP 缓存</a>》。</p>
<h1 id="4-执行-handler"><a href="#4-执行-handler" class="headerlink" title="4. 执行 handler"></a>4. 执行 handler</h1><p>在 DispatcherServlet 中，执行 handler 分五步走</p>
<ol>
<li>前置拦截</li>
<li>执行 handler</li>
<li>考虑处理异步请求</li>
<li>考虑设置默认 view</li>
<li>后置拦截</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* —————————— ④ handler 开始处理请求 —————————— */</span></span><br><span class="line"><span class="comment">// 前置拦截</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 handler，获取结果 modelAndView</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是异步请求，直接返回，response 将一直保持打开状态</span></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 modelAndView 不为空，但 view 为空时，根据 request 设置默认的 view</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置拦截</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>前置拦截</p>
<p>前文有说过，真正执行 handler 的是 handleAdapter，这个类是在 handler 的基础上增加了若干个 interceptor，起到前后拦截的作用。第一步，就是遍历 interceptors 进行前置拦截，来看 <code>mappedHandler.applyPreHandle(processedRequest, response)</code> 这行代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 interceptors 是否不为空</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 interceptors</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 让每个 interceptor 执行 preHandle(...) 方法，执行前置拦截方法</span></span><br><span class="line">            <span class="comment">// 具体前置拦截执行内容，由 interceptor 自己定义</span></span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 只有在 preHandle(...) 方法返回 false 的情况下才会执行下面（也就是说前置拦截中途失败了）</span></span><br><span class="line">                <span class="comment">// 这个方法会执行 interceptor 的 afterCompletion(...) 方法，然后请求直接返回</span></span><br><span class="line">                <span class="comment">// 意思是如果前置执行失败了，那么 handler 就不执行了，处理完一些操作请求就直接返回了</span></span><br><span class="line">                triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.interceptorIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 handler</p>
<p>处理完前置拦截的 interceptor 们之后，就可以正式执行 handler 了，对应于我们自己的业务代码，就是去执行 <code>@RequestMapping</code> 注解的 Controller 方法。</p>
<p>执行 Controller 方式是通过反射实现的，步骤很深，就不细研究了。主要的思路是，从 handler 中获取 handlerMethod（也就是 Controller 方法），从 request 中获取接口参数，然后使用反射调用方法，获取结果，包装进 response 里。具体的执行细节可以去看 <code>RequestMappingHandlerAdapter</code> 类中的 <code>invokeHandlerMethod(...)</code> 方法。</p>
<p>执行 handle 方法，接口返回的是 ModelAndView，这是 MVC 中的 M（Model）和 V（View），但是对于我们自己编写 Controller 方法而言（使用 RestController），handle 方法返回的 ModelAndView 是 null，因为并没有必要返回视图，结果直接被封装进 response 里了。这里涉及到 HTTP 协议和返回体相关的知识，以后再补吧（怎么这么多要补的……）</p>
</li>
<li><p>考虑处理异步请求</p>
<p>如果请求是异步的，那么可以提前返回，之后再异步传回请求结果。</p>
<p>判断请求是否异步的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConcurrentHandlingStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.asyncWebRequest.isAsyncStarted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑设置默认 view</p>
<p>如果  ModelAndView 对象不为 null，但是对象内部的 view 部分是空的，那么考虑设置默认的 view。</p>
<p>这个方法并没有执行，因为 ModelAndView 对象此时是 null，方法直接就返回了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyDefaultViewName</span><span class="params">(HttpServletRequest request, @Nullable ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 ModelAndView 对象不为空，但是 view 为空，那么考虑设置默认的 view</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.hasView()) &#123;</span><br><span class="line">        String defaultViewName = getDefaultViewName(request);</span><br><span class="line">        <span class="keyword">if</span> (defaultViewName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mv.setViewName(defaultViewName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后置拦截</p>
<p>跟前置拦截的过程差不多，但是这次是从后往前遍历执行拦截方法的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 interceptors 不为空</span></span><br><span class="line">    HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="comment">// 从后往前遍历每个 interceptor</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">            <span class="comment">// 执行每个 interceptor 的 postHandle(...) 方法</span></span><br><span class="line">            interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h1 id="5-渲染视图结果"><a href="#5-渲染视图结果" class="headerlink" title="5. 渲染视图结果"></a>5. 渲染视图结果</h1><p>执行到这里时（<code>processDispatchResult(...)</code> 方法），有三种可能：</p>
<ol>
<li><p>执行正常，且不需要 ModelAndView（RestController 直接返回了 JSON/XML 数据）</p>
<p><code>processDispatchResult(...)</code> 什么都没执行，逛一圈就返回了。</p>
</li>
<li><p>执行正常，且需要 ModelAndView</p>
<p>将 ModelAndView 渲染进 response 里（也就是渲染视图结果）</p>
</li>
<li><p>执行异常</p>
<p>将异常转换为 ModelAndView 对象（转换成视图对象），然后渲染进 response 里（如果转换不了就再抛出去异常）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   @Nullable Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果执行 handler 发生了异常，将 mv 转换为异常情况下的 mv</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是 ModelAndViewDefiningException 类型的异常，可以直接获取 mv</span></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是其他异常，需要找一个 HandlerExceptionResolver 处理异常获取 mv</span></span><br><span class="line">        <span class="comment">// 也有可能这里也处理不了，那就再抛异常出去</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析、渲染 mv</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// render：渲染</span></span><br><span class="line">        <span class="comment">// 将 mv 解析渲染进 response 中</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"No view rendering, null ModelAndView returned."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步并发相关，不懂，略</span></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理每个 interceptor 的完成拦截逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个方法在第四步处理 handler 的第一步前置拦截时看到过，如果前置拦截发生了异常，就会执行这个方法，然后直接返回</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>doDispatch(...)</code> 方法的五步就都看完了。</p>
<hr>
<p>Spring MVC 设计了很多接口类，将各自的职责摘得很干净，这里学习其中几个类的设计。</p>
<h1 id="HandlerExecutionChain"><a href="#HandlerExecutionChain" class="headerlink" title="HandlerExecutionChain"></a>HandlerExecutionChain</h1><p><code>doDispatch(...)</code> 方法在第一步获取的 handler，它的类型是 HandlerExecutionChain。这个类在 handler 的基础上，还有若干个 HandlerInterceptor 对象，在 handler 执行的前后起到拦截的效果。</p>
<p>HandlerExecutionChain 的内部有两部分：</p>
<ul>
<li>handler：实际执行请求方法</li>
<li>interceptors：在 handler 的前后做拦截方法，起到类似 AOP 的效果</li>
</ul>
<p>官方在 Javadoc 中对 HandlerExecutionChain 的描述有这么一句，可以感受一下：</p>
<blockquote>
<p>a handler and any interceptors for this request.</p>
</blockquote>
<p>interceptors 是 HandlerInterceptor 接口对象的集合，这个接口定义了三个方法，具体的实现可能由框架提供，也可能由开发人员提供。这三个方法会在 <code>doDispatch(...)</code> 方法的第四步执行 handle 时被调用，分别是：</p>
<ul>
<li><p>preHandle(…)</p>
<p>前置拦截方法，按照 interceptors 的顺序逐个执行，方法有返回值，如果返回 false 则不会执行 handle 方法，调用 afterCompletion(…) 后返回</p>
</li>
<li><p>postHandle(…)</p>
<p>后置拦截方法，按照 interceptors 的顺序，倒序逐个执行，方法没有返回值</p>
</li>
<li><p>afterCompletion(…)</p>
<p>完成后拦截方法（完成既指正常完成，也指异常完成，总之一定会执行），方法没有返回值</p>
</li>
</ul>
<p>学习该类可参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/99286145?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160386981019724836749805%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=160386981019724836749805&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-3-99286145.first_rank_ecpm_v3_pc_rank_v2&utm_term=HandlerExecutionChain&spm=1018.2118.3001.4187" target="_blank" rel="noopener">Spring MVC : 概念模型 HandlerExecutionChain</a>》。</p>
<h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><p>在 <code>doDispatch(...)</code> 方法的第一步获取 handler 的过程中，匹配 handler 是通过 HandlerMapping 来实现的。</p>
<p>HandlerMapping 代表着【请求 URL】到【请求处理器】之间的映射，在首个请求进入 Spring MVC 之后，框架将整理出 handlerMappings 集合，然后 DispatcherServlet 会为每个请求遍历 handlerMappings，询问哪个请求处理器能够处理当下的请求。</p>
<p>HandlerMapping 接口只定义了一个方法 <code>getHandler(request)</code>，它的接收参数是一个请求，它返回一个 handler。如果返回的 handler 不为 null，就代表它可以处理这个请求，这个返回的 handler 也就是上面所说的 HandlerExecutionChain 的实例对象。</p>
<p>学习该类可参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/88061102" target="_blank" rel="noopener">Spring MVC : HandlerMapping 和 HandlerAdapter 简介 : 概念和如何工作</a>》。</p>
<h1 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h1><p>在 <code>doDispatch(...)</code> 方法获取到 handler 之后，并不是使用它直接执行请求方法的，而是又找到 HandlerAdapter 对象，使用它来处理请求，执行请求方法。</p>
<p>HandlerAdapter 抽象了对【请求处理器】的【真正执行】，这使得 DispatcherServlet 可以无视 handler 的执行细节，当要支持更多的 handler 类型时，只需要实现 HandlerAdapter 接口就可以了。</p>
<p>学习该类可参考博文《<a href="https://blog.csdn.net/andy_zhang2007/article/details/98845094" target="_blank" rel="noopener">DispatcherServlet 请求处理主逻辑 : 2. 选择 Handler 对应的 HandlerAdapter</a>》。</p>
<br>

<p>本周先学习到这里吧。</p>

  </div>
</article>



    </div>
    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2020 pz
  </div>
  <div class="footer-right">
    <img src="/images/govPolice.png">
    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502006101">粤公网安备 44030502006101号</a>
    <a>&nbsp;</a>
    <a href="http://beian.miit.gov.cn">粤ICP备2020090003号</a>
  </div>
</footer>

</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
<link rel="stylesheet" href="/lib/meslo-LG/styles.css">
<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">

<!-- jquery -->
<script src="/lib/jquery/jquery.min.js"></script>
<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>
<script src="/js/main.js"></script>


    <!-- Google Analytics -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-37473492-6', 'auto');
        ga('send', 'pageview');
    </script>



